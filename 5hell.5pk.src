// 5hell v 3.9.9 by Plu70
// released v 3.9.9
// imports .5pk files from /root/src
ver = "3.9.9.9.1_nightly_terrors"
DEBUG = false // set to true by launching 5hell with --debug as any parameter
if params and params.indexOf("--debug") >= 0 then DEBUG = true
/////// check for nightly, we don't want certain functions called if we are on public
/////// set to true if playing nightly, false if playing public
globals.NIGHTLY = false
f = get_shell.host_computer.File("/")
if f and f.__isa.hasIndex("symlink") then globals.NIGHTLY = true
////// end check for nightly
size_of_5hell = "158.474"
///////////////////////////////////////

if DEBUG then print("<size=75%>loading globals...</size>") else print("<align=center><mark=red><color=black>#</color></mark></align>")
apt_get = include_lib("/lib/aptclient.so")
if not apt_get then apt_get = include_lib(current_path+"/aptclient.so")
if not apt_get then print("WARNING: aptclient.so not found in /lib")
mlib = true
globals.metaxploit = include_lib("/lib/metaxploit.so")
if not globals.metaxploit then
	mlib = false
	globals.metaxploit = include_lib(current_path+"/metaxploit.so")
end if
if not globals.metaxploit then print("WARNING: metaxploit.so not found")
clib = true
globals.crypto = include_lib("/lib/crypto.so")
if not crypto then
	clib = false
	globals.crypto = include_lib(current_path+"/crypto.so")
end if
if not crypto then print("WARNING: crypto.so not found")

meta_path = "/lib/metaxploit.so"
if mlib == false then meta_path = current_path+"/metaxploit.so"
cryp_path = "/lib/crypto.so"
if clib == false then cryp_path = current_path+"/crypto.so"

metaLibVersion = "0.0.0"
cryptoLibVersion = "0.0.0"
if globals.metaxploit then metaLibVersion = globals.metaxploit.load(meta_path).version
if crypto and metaxploit then cryptoLibVersion = globals.metaxploit.load(cryp_path).version

globals.localip = function()
	return localmachine.local_ip
end function
globals.pubip = function()
	return localmachine.public_ip
end function

globals.BIGBRAIN = false
globals.GLASSPOOL = 0
globals.command_buffer = []
globals.shell = get_shell
globals.metaLib = null
globals.debugLib = null
globals.net_session = null
globals.localmachine = shell.host_computer
globals.currentPath = current_path
globals.homePath = home_dir
globals.enumerated = []
globals.tagged_for_scp = ""
globals.backup_meta = null
//globals.services = {}

targ = {"ip":"0.0.0.0", "pt":0} // edit this to match your server or pass ip and port when calling transmit or target ip and port
if params and params.len > 0 then targ.ip = params[0]
if params and params.len > 1 then targ.pt = params[1].to_int
//globals.localip = localmachine.local_ip
//globals.pubip = localmachine.public_ip
globals.neurobox_user = ""
globals.neurobox_pass = ""
globals.clip_board_alpha = "" 
globals.clip_board_beta = ""
globals.clip_board_gamma = ""
globals.clip_board_delta = "" // for do
globals.debug_username = ""
globals.debug_password = "" // neurobox debug credentials

globals.instance = globals.localmachine.File(program_path)

// import 5phinx -- this contains critical shared functions and the backbone of the hacking suite
import_code("/root/src/5phinx.5pk")

//
// while importing a starting dictionary is still possible it is no longer supported
// current runtime loading of cerebrum is 20 seconds and importing from filesystem is less than 1 second
// start dictionaries are therefore superfluous
if DEBUG then print("<size=75%>loading dictionary...</size>")
// this function puts the dictionary in the custom object for use between nested launches without breaking legacy dictionary calls
globals.dict_a = function(import=0)  
	cobble = get_custom_object
	if typeof(import) == "list" then cobble.dictionary = import // set a new dicitonary from input: list
	if not cobble.hasIndex("dictionary") then cobble.dictionary = ["a"] // set default dictionary if it doesn't exist
	return cobble.dictionary // return the dictionary in all cases as a list
end function
//// UPDATING THE DICTIONARY IS HANDLED BY COMMAND.CEREBRUM //////
//// COB import and COB export are now deprecated commented out
//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
if DEBUG then ds = dict_a.len
if DEBUG then print("<size=75%>dictionary loaded...("+(ds/1000)+"kb)</size>")
globals.SAFEWORD = "stop_code" // use @STOP (or this value) in a do script and/or in an if statement within a do script to 'break' the do loop
globals.routerLib = null
globals.targetIP = null
globals.targetPort = "router"
globals.PORT_MAP = {}
globals.HERMES = false
globals.inbox = null
globals.BUFFER = [get_shell]
globals.XPLOITS = []
globals.MEMORY = null
globals.meta_scan = []
globals.T_BUF = [(localip+"@"+pubip)] // transmission buffer
//globals.T_BUF = []
globals.portInfo = null
globals.tarLan = null
globals.grepped_file = null
globals.airing = false
globals.mail_user = null
globals.last_mail = null
globals.this_mail = 0


colorRed = "<color=#FF0000FF><b>"
colorGreen = "<color=#00FF00FF><b>"
colorOlive = "<color=#048004FF><b>"
colorWhite = "<color=#FFFFFFFF><b>"
colorCyan = "<color=#00FFFFFF><b>"
colorGold = "<color=#CCCC00FF><b>"
colorBlack = "<color=#000000FF><b>"
colorOrange = "<color=#FF8400FF><b>"
colorViolet = "<color=#8821FDFF><b>"
colorMagenta = "<color=#FF00C8FF><b>"
colorLightBlue = "<color=#2382FFFF><b>"
CT = "</color></b>"

globals.get_file = function(input_string)
	if DEBUG then print("debug: in_get_file: "+@input_string)
	if typeof(input_string) == "file" then return input_string.path
	if typeof(@input_string) != "string" then return 0
	if input_string == "" or input_string == " " or not input_string then return 0
	if DEBUG then print "debug: get_file: processing string: "+@input_string
	if input_string.split("/")[0] == "" then
		file = localmachine.File(input_string)
	else
		file = localmachine.File(currentPath+"/"+input_string)
  	if not file then file = localmachine.File(currentPath+input_string)
	end if
	if DEBUG then
		if file then print("File: ["+file.path+"]") else print("File: [not found]")
	end if
  if file then return file else return 0
end function
// end globals
if DEBUG then print("<size=75%>loaded get_file...</size>")                       ////////////////////////////////
if DEBUG then print("<size=75%>loading 5hell.5pk...("+size_of_5hell+"kb)</size>")                   /////LOADING 5HELL///////////////////////////////////
if DEBUG then print("<size=75%>loading clipcommander.5pk...(6.660kb)</size>")     ////////////////////////////////
command.clipa = function(arg1=0, arg2=0, arg3=0, arg4=0)
	if typeof(@arg1) == "function" then
		globals.clip_board_alpha = @arg1
		print(colorCyan+"</b>clipped: "+typeof(@globals.clip_board_alpha))
		return @globals.clip_board_alpha
	end if
	if arg1 == "help" or arg1 == "-h" then return "<u>clipboard alpha || clipa || clipspace</u>"+char(10)+"Usage:"+char(10)+" clipa: pipe outputs to clipa with: command | clipa"+char(10)+" clipa [optional:arg|string|list|map|@tbuf|@cc|@B {opt:-m|#}]"+char(10)+"-- add any of the above to clipa"+char(10)+"clipa -- <b>Returns</b> contents of clipa if no arguments."+char(10)+"scribus @clipa -- edit clipa directly with the text editor."
	if arg1 == "0" then
		globals.clip_board_alpha = "0"
		print(colorCyan+"</b>clipped: "+typeof(@globals.clip_board_alpha))
		return globals.clip_board_alpha
	end if
	if arg1 == 0 then
		if typeof(@globals.clip_board_alpha) == "function" then return @globals.clip_board_alpha else	return globals.clip_board_alpha
	end if
	globals.clip_board_alpha = arg1
	if arg1 == "@tbuf" then
		globals.T_BUF.pull
		globals.clip_board_alpha = globals.T_BUF.join(char(10))
		globals.T_BUF = [(localip+"@"+pubip)]
		//globals.T_BUF = []
	end if
	if arg1 == "@cc" then globals.clip_board_alpha = globals.command_buffer.join(char(10))
	if arg1 == "@B" then
		if globals.BUFFER.len < 1 then return "BUFFER is empty."
		i = 0
		for b in globals.BUFFER
			if typeof(@b) == "function" then print("["+colorWhite+i+CT+"] - <b>"+checkUser(@b)+":"+typeof(@b)+"</b>") else print("["+colorWhite+i+CT+"] - <b>"+checkUser(b)+":"+typeof(b)+"</b>")
			i = i + 1
		end for
		get = arg2
    if get and get != "-m" then get = arg2.to_int
    if get == "-m" then get = user_input("clipa:> ").to_int
		if typeof(get) != "number" then return "BUFFER: invalid selection."
		if get >= 0 and get < BUFFER.len then globals.clip_board_alpha = globals.BUFFER[get] else return "BUFFER: invalid selection."
	end if
	print(colorCyan+"</b>clipa: clipped: "+typeof(@globals.clip_board_alpha))
	if typeof(@globals.clip_board_alpha) == "function" then return @globals.clip_board_alpha else	return globals.clip_board_alpha
end function
command.clipb = function(arg1=0, arg2=0, arg3=0, arg4=0)
	if typeof(@arg1) == "function" then
		globals.clip_board_beta = @arg1
		print(colorCyan+"</b>clipped: "+typeof(@globals.clip_board_beta))
		return @globals.clip_board_beta
	end if
	if arg1 == "help" or arg1 == "-h" then return "<u>clipboard beta || clipb || clipspace</u>"+char(10)+"Usage:"+char(10)+" clipb: pipe outputs to clipb with: command | clipb"+char(10)+" clipb [optional:arg|string|list|map|@tbuf|@cc|@B {opt:-m|#}|function]"+char(10)+"-- add any of the above to clipb"+char(10)+"clipb -- <b>Returns</b> contents of clipb if no arguments."+char(10)+"scribus @clipb -- edit clipb directly with the text editor."+char(10)+"N.B. please be awake that command.<b>append</b> works a bit differently with clipb than with clipa or clipc."+char(10)+"-- see append -h for more info."
	if arg1 == "0" then
		globals.clip_board_beta = "0"
		print(colorCyan+"</b>clipped: "+typeof(@globals.clip_board_beta))
		return globals.clip_board_beta
	end if
	if arg1 == 0 then
		if typeof(@globals.clip_board_beta) == "function" then return @globals.clip_board_beta else	return globals.clip_board_beta
	end if
	globals.clip_board_beta = arg1
	if arg1 == "@tbuf" then
		globals.T_BUF.pull
		globals.clip_board_beta = globals.T_BUF.join(char(10))
		globals.T_BUF = [(localip+"@"+pubip)]
		//globals.T_BUF = []
	end if
	if arg1 == "@cc" then	globals.clip_board_beta = globals.command_buffer.join(char(10))
	if arg1 == "@B" then
		if globals.BUFFER.len < 1 then return "BUFFER is empty."
		i = 0
		for b in globals.BUFFER
			if typeof(@b) == "function" then print("["+colorWhite+i+CT+"] - <b>"+checkUser(@b)+":"+typeof(@b)+"</b>") else print("["+colorWhite+i+CT+"] - <b>"+checkUser(b)+":"+typeof(b)+"</b>")
			i = i + 1
		end for
		get = arg2
		if get and get != "-m" then get = arg2.to_int
		if get == "-m" then get = user_input("clipb:> ").to_int
		if typeof(get) != "number" then return "BUFFER: invalid selection."
		if get >= 0 and get < BUFFER.len then globals.clip_board_beta = BUFFER[get] else return "BUFFER: invalid selection."
	end if
	print(colorCyan+"</b>clipb: clipped: "+typeof(@globals.clip_board_beta))
	if typeof(@globals.clip_board_beta) == "function" then return @globals.clip_board_beta else	return globals.clip_board_beta
end function
command.clipc = function(arg1=0, arg2=0, arg3=0, arg4=0)
	if typeof(@arg1) == "function" then
		globals.clip_board_gamma = @arg1
		print(colorCyan+"</b>clipped: "+typeof(@globals.clip_board_gamma))
		return @globals.clip_board_gamma
	end if
	if arg1 == "help" or arg1 == "-h" then return "<u>clipboard gamma || clipc || clipspace</u>"+char(10)+"Usage:"+char(10)+" clipc: pipe outputs to clipc with: command | clipc"+char(10)+" clipc [optional:arg|string|list|map|@tbuf|@cc|@B {opt:-m|#}]"+char(10)+"-- add any of the above to clipc"+char(10)+"clipc -- <b>Returns</b> contents of clipc if no arguments."+char(10)+"scribus @clipc -- edit clipc directly with the text editor."
	if arg1 == "0" then
		globals.clip_board_gamma = "0"
		print(colorCyan+"</b>clipped: "+typeof(@globals.clip_board_gamma))
		return globals.clip_board_gamma
	end if
	if arg1 == 0 then
		if typeof(@globals.clip_board_gamma) == "function" then return @globals.clip_board_gamma else	return globals.clip_board_gamma
	end if
	globals.clip_board_gamma = arg1
	if arg1 == "@tbuf" then
		globals.T_BUF.pull
		globals.clip_board_gamma = globals.T_BUF.join(char(10))
		globals.T_BUF = [(localip+"@"+pubip)]
		//globals.T_BUF = []
	end if
	if arg1 == "@cc" then	globals.clip_board_gamma = globals.command_buffer.join(char(10))
	if arg1 == "@B" then
		if globals.BUFFER.len < 1 then return "BUFFER is empty."
		i = 0
		for b in globals.BUFFER
			if typeof(@b) == "function" then print("["+colorWhite+i+CT+"] - <b>"+checkUser(@b)+":"+typeof(@b)+"</b>") else print("["+colorWhite+i+CT+"] - <b>"+checkUser(b)+":"+typeof(b)+"</b>")
			i = i + 1
		end for
		get = arg2
		if get and get != "-m" then get = arg2.to_int
		if get == "-m" then get = user_input("clipc:> ").to_int
		if typeof(get) != "number" then return "BUFFER: invalid selection."
		if get >= 0 and get < BUFFER.len then globals.clip_board_gamma = BUFFER[get] else return "BUFFER: invalid selection."
	end if
	print(colorCyan+"</b>clipc: clipped: "+typeof(@globals.clip_board_gamma))
	if typeof(@globals.clip_board_gamma) == "function" then return @globals.clip_board_gamma else	return globals.clip_board_gamma
end function
command.passwd = function(arg1, arg2, arg3=0, arg4=0)
  if arg1 == "help" or arg1 == "-h" then return "<u>Password || Change Password || passwd"+char(10)+"Usage: passwd [opt: user] [opt: password] -- change password for user"+char(10)+"- will prompt for missing options"
	user = null
	pass = null
	if arg1 then user = arg1
	if arg2 then pass = arg2
	if not user then user = user_input("passwd: change password for which user? :> ")
  if not pass then pass = user_input("passwd: select a new password for: "+user+":> ",1,0)
	if pass == "" or pass == " " then return "aborting..."
  try = localmachine.change_password( user, pass)
  if try == 1 then return "passwd: "+colorWhite+"password updated to: "+char(10)+pass
  return try
end function
command.echo = function(arg1, arg2=0, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "ECHO || echo || Echo || echO"+char(10)+
	"Usage: echo [up] [to] [four] [params] -- returns concatonated params to the terminal"+char(10)+char(10)+
	"General usage is to echo text back to the terminal during batch script/macro execution."+char(10)+
	"However, it may also be used to feed input to another command or concatonate outputs"+char(10)+
	"of multiple commands. You may use floating quotes (single quotes not touching another"+char(10)+
	"character) to wrap complex input parameters. Examples:"+char(10)+
	"|> echo bob burger  --  output: bob burger"+char(10)+
	"|> echo "" Eat at Joe's Diner. "" <color=red>Because</color> "" it's the best. "" "+char(10)+
	"-- output: Eat at Joe's diner. <color=red>Because</color> it's the best."+char(10)+
	"|> echo three four | echo one two -- output: one two three four"+char(10)+
	"Here's a fairly useless example, lol:"+char(10)+
	"|> cat file.txt | echo | poke file2.txt | cat | echo | poke file3.txt"+char(10)+char(10)+
	"Simple enough. You may use richtext in the echo to spruce it up."+char(10)+
	"Resizing text and adding color allows the echo to stand out when text"+char(10)+
	"is flying by during a complex <b>dig</b>, for example."
	ec = arg1+" "
	if arg2 then ec = ec + arg2+" "
	if arg3 then ec = ec + arg3+" "
	if arg4 then ec = ec + arg4
	return ec.trim
end function
command.clear = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "Clear Screen || Terminal Wipe || clearscreen"+char(10)+"Usage: clear -- clears the terminal of all text"
	clear_screen
	return 0
end function
command.ps = function(arg1, arg2, arg3=0, arg4=0)
	ps_usage = "Show Processes || PS || show procs || not actually top or htop"+char(10)+
	"<b>Usage: ps [opt:-r] [opt:shell|computer] -- show processess running on the active host_computer"+char(10)+
	"-- when glasspool is active:"+char(10)+
	"-- the active shell/computer is the active host_computer"+char(10)+
	"-- optional [-r] parameter returns raw, uncolorized output"+char(10)+
	"--eg: ps -r"+char(10)+
	"<b>Usage: ps [opt:-r] [shell|computer] -- show processes running on the piped object"+char(10)+
	"-- optional [-r] parameter returns raw, uncolorized output"+char(10)+
	"--eg: rsi 1 7 | ps"
	if arg1 == "-h" or arg1 == "help" then return ps_usage
	output = null
	raw = false
	verbose = false 
	if arg3 == "--verbose" then verbose = true
	locals.hold_comp = globals.localmachine
	if arg1 == "-r" then
		raw = true 
		arg1 = arg2 
		arg2 = arg3
		arg3 = arg4 
	end if
	if arg1 and (typeof(arg1) == "shell" or typeof(arg1) == "computer") then 
		if typeof(arg1) == "shell" then locals.hold_comp = arg1.host_computer
		if typeof(arg1) == "computer" then locals.hold_comp = arg1 
		//swapped = true
	end if
	if verbose then print("<size=75%>Showing processes...")
	if raw == true then return format_columns(locals.hold_comp.show_procs)
	p_buf = hold_comp.show_procs.split(char(10))
	i = 0
	if DEBUG then print "debug: "+p_buf
	for line in p_buf 
		if i == 0 then 
			line = colorWhite+"</b>"+line+"</color>".replace("USER","<color=#F5F5F5></b>USER</color>")
			p_buf[i] = line
			i = i + 1
			continue 
		end if
		line = colorCyan+"</b>"+line
		line = line.replace("dsession",colorRed+"</b>dsession").replace("Xorg",colorLightBlue+"</b>Xorg").replace("kernel_task",colorLightBlue+"</b>kernel_task").replace("ps",colorRed+"</b>ps(suspicious!)").replace("5hell",colorRed+"5"+colorWhite+"hell")//.replace("root",colorOrange+"<b>root</color>").replace("guest",colorWhite+"<b>guest</color>")
		p_buf[i] = line
		i = i + 1
	end for
	output = format_columns(p_buf.join(char(10)))
	return output
end function
command.kill = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == 0  or arg1 == "-h" or arg1 == "help" then return "KILL || END PROCESS || TERMINATE SCRIPT"+char(10)+
	"Usage: kill [PID] [opt: shell|computer] -- terminate PID"+char(10)+
	"-- PID should be process number or ALL"+char(10)+
	"-- see the <b>ps</b> command for process ID's"+char(10)+
	"--<b> kill ALL </b>will attempt to close all programs."+char(10)+
	"n.b. if<b> kill ALL </b>kills the terminal that launched the program,"+char(10)+
	"---- it might not complete its task."+char(10)+char(10)+
	"Usage: kill [process_name] [opt: shell|computer] --"+char(10)+
	"-- kill processes by process name instead of PID"+char(10)+
	"-- NOTE: kills ALL processes of that name"+char(10)+char(10)+
	"Note: piping a shell or computer object runs kill on the object instead of locally"+char(10)+
	"Note: running kill while glasspool is active runs kill on the active object"
	target_machine = globals.localmachine
	if typeof(arg2) == "shell" then 
		target_machine = arg2.host_computer
	end if
	if typeof(arg2) == "computer" then 
		target_machine = arg2
	end if
	if typeof(arg1) == "string" then 

		if typeof(arg1.to_int) == "number" then PID = arg1.to_int else PID = arg1
	else 
		return "kill: invalid input"+char(10)+"Usage: kill [pid|process_name] [opt:shell|computer]"
	end if
	if typeof(PID) == "string" then
		processes = target_machine.show_procs.split(char(10))
		killed = false
		for p in processes
			if p == "USER PID CPU MEM COMMAND" then continue
			process = p.split(" ")
			process_ID = process[1]
			process_CMD = process[4]
			stor = globals.localmachine
			globals.localmachine = target_machine
			if PID == "ALL" or PID == process_CMD then 
				print(command.kill(process_ID))
				killed = true 
			end if
			globals.localmachine = stor
		end for
		if killed == false then return "kill: process <u>" + PID + "</u> not found" else return 0
	end if
	output = target_machine.close_program(PID)
	if output == true then return("kill: terminating process: " + PID + "...");
	if output then return(output)
	return "kill: process <u>" + PID + "</u> not found"
end function
command.pwd = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "Usage: pwd -- print working directory"+char(10)+"-- returns the current path as a string"
	return currentPath
end function
// command.psudo = function(arg1, arg2, arg3=0, arg4=0)
// 	// if arg1 == "-h" or arg1 == "help" then return "Usage: psudo -- shell session management; without args prompts user for input:"+char(10)+
// 	// 	"-- 'y' to open current active shell, 'c' to enter credentials (ie escalate privileges)"+char(10)+
// 	// 	"Usage: psudo -s [opt:password] -- get root a shell and send it to BUFFER (prompts for password if not supplied)"+char(10)+
// 	// 		"Usage: [shell_returned_by_function] | psudo -- open piped shell"+char(10)+
// 	// 		"Example: ssh root@pass 1.1.1.1 | psudo  -- to be prompted to open terminal immediately instead of sending shell to buffer."+char(10)+
// 	// 		"N.B. psudo may be used to 'go live' from glasspool (ie open the shell) but running a binary via glasspool"+char(10)+
// 	// 		"i.e. glasspool >> run 5hell"+char(10)+
// 	// 		"(shell.launch(5hell))... running psudo will end the shell.launch session and return you to the glasspool session."+char(10)+
// 	// 		"This is not something I can control."+char(10)+
// 	// 		"Advanced: psudo -- answer 'y' at prompt. Pipes current session, useful for hiding the ip of your previous connection."
	

// 	if arg1 == "help" or arg1 == "-h" then return "<u>PSUDO || sudo || shell switcher || escalate"+char(10)+char(10)+
// 	colorWhite+"</b>Usage: "+colorCyan+"</b>psudo</color> -- display psudo menu and perform selected action"+char(10)+
// 	colorWhite+"</b>-- allows selecting the below options from a menu"+char(10)+char(10)+
// 	colorWhite+"</b>Usage: psudo ["+colorCyan+"-s</b></color>] [opt:password] -- escalate"+char(10)+
// 	"-- attempt get_shell(""root"", ""password"") and BUFFER result"+char(10)+
// 	"-- prompts for password if not provided"+char(10)+
// 	"-- simplest way to escalate privileges "+char(10)+char(10)+
// 	colorWhite+"</b>Usage: psudo [<b>-u</b>] [opt:user] [opt:pass] -- switch user"+char(10)+
// 	"-- attempt get_shell(""user"",""password"") and BUFFER result"+char(10)+
// 	"-- prompts for user and/or password if not supplied"+char(10)+
// 	"--note: "+char(10)+char(10)+
// 	colorWhite+"</b>Usage: psudo [<b>-l|-y</b>] [opt:shell_object] -- ""loop"" shell session"+char(10)+
// 	"-- supplying a shell object results in running shell_object.start_terminal"+char(10)+
// 	"-- omitting a shell object results in running get_shell.start_terminal"+char(10)+
// 	"---- running get_shell.start_terminal is ""looping"" your current shell connection"+char(10)+
// 	"---- the direct result of this is two-fold:"+char(10)+
// 	"---- first, your active trace time limit is increased (each use of start_terminal does this)"+char(10)+
// 	"---- second, the IP left with file deleted logs will be the IP of the looped connection"+char(10)+
// 	"---- the IP left with file deleted logs is that of the shell that did start_terminal"+char(10)+
// 	"------ NOT the started terminal; looping solves this issue"+char(10)+
// 	"--note: supplying a shell object is better referred to as pivoting, not looping"+char(10)+
// 	"---- but I'm not gonna add another flag for that when this will do"+char(10)+char(10)+
// 	"N.B.: psudo will no longer offer to run start_terminal when it obtains a shell"+char(10)+
// 	"-- running start_terminal is not recommended unless strictly necessary"+char(10)+
// 	"-- doing so ends 5hell and therefore is worth the extra effort to initiate"

// 	origin_shell = globals.shell 
// 	user = null 
// 	pass = null
// 	if not arg1 then return globals._shell_prompt(origin_shell,"-m")

// 	if arg1 and typeof(arg1) != "string" and arg1 != "-m" and arg1 != "-s" and arg1 != "-u" and arg1 != "-l" then return "psudo: invalid flag"
// 	flag = arg1
// 	if flag == "-l" and typeof(arg2) == "shell" then origin_shell = arg2 

// 	if typeof(arg3) == "string" then locals.user = arg3 
// 	if typeof(arg4) == "string" then locals.pass = arg4
	
// 	return globals._shell_prompt(origin_shell,flag,user,pass)
	
	
// 	//	psl = globals.shell
// 	//	if arg1 and arg1 == "-s" and not arg2 then
// 	//		psl = user_input("root pass:> ",1,0)
// 	//	end if
// 	//	if arg2 and arg1 == "-s" then
// 	//		psl = arg2
// 	//	else
// 	//		if arg1 and (typeof(arg1) == "shell" or typeof(arg1) == "ftpshell") then psl = arg1
// 	//	end if


// 	//return globals.shell_prompt( psl )
// end function
// psudo 2.0 by Plu70
// conditions:
// 
// psudo -- show menu
// psudo [shell] -- prompt to start terminal on shell
// psudo [-l] -- start terminal on current active shell
// psudo [-y|-l] [shell] -- same as psudo [shell] but does not prompt
// psudo [-u] [user] [pass] -- get_shell(user,pass)
// psudo [-s] [pass] -- get_shell("root",pass)
command.psudo = function(operation, arg2, arg3, arg4)
    if operation == "help" or operation == "-h" then return "PSUDO || sudo || get shell || get_shell || start terminal"+char(10)+
	colorCyan+"<u>Start_terminal options:"+char(10)+"--"+char(10)+
    "Usage: "+colorGold+"</b>psudo"+CT+" -- display the psudo menu"+char(10)+"--"+char(10)+
    "Usage: "+colorGold+"</b>psudo"+CT+" ["+colorWhite+"shell_object"+CT+"] -- execute <b>start_terminal</b> on the shell_object"+char(10)+
    "-- unlike <b>run</b>, this command will <b>end</b> the script"+char(10)+"--"+char(10)+
    "Usage: "+colorGold+"</b>psudo"+CT+" ["+colorWhite+"-l"+CT+"] -- execute start_terminal on the currently active shell object"+char(10)+
	"-- unlike <b>run</b>, this command will <b>end</b> the script"+char(10)+"--"+char(10)+
	colorCyan+"<u>Get_shell options:"+char(10)+"--"+char(10)+
    "Usage: "+colorGold+"</b>psudo"+CT+" ["+colorWhite+"-u"+CT+"] [opt:"+colorWhite+"user"+CT+"] [opt:"+colorWhite+"password"+CT+"] -- "+colorOrange+"BUFFER"+CT+" a shell object using credentials"+char(10)+"--"+char(10)+
	"Usage: "+colorGold+"</b>psudo"+CT+" ["+colorWhite+"-s"+CT+"] [opt:"+colorWhite+"password"+CT+"] -- "+colorOrange+"BUFFER"+CT+" a <b>root</b> shell object using credentials"
//
    _psudo_menu = function()
        // display options
        print colorGold+"</b>psudo: "+CT+"["+colorWhite+"y</b>|<b>l"+CT+"] execute "+colorCyan+"</b>start_terminal"+CT+" on the currently active shell object"
        print colorGold+"</b>psudo: "+CT+"["+colorWhite+"u"+CT+"] BUFFER a <b>local</b> user shell using credentials"
        print colorGold+"</b>psudo: "+CT+"["+colorWhite+"s"+CT+"] BUFFER a <b>root</b> shell using credentials"
        print colorGold+"</b>-- press any other key to abort"
        op = user_input(colorWhite+"||: "+colorGold+"</b>",0,1).lower
        if "ylus".indexOf(op) == null then return 0 else return "-"+op
    end function
//
    _go_time = function(user=null,pass=null)
		if DEBUG then print "debug: go time: "+char(10)+"usr: "+user+" is a: "+typeof(user)+char(10)+"pass: "+pass+" is a: "+typeof(pass)
        if not user or not pass or user == "" or pass == "" then return colorGold+"</b>psudo: aborting..."
		if typeof(user) != "string" or typeof(pass) != "string" then return colorGold+"</b>psudo: aborting..."
        locals.sh = get_shell(user,pass)
        if typeof( locals.sh ) == "shell" then 
            colorLightBlue+"</b>malp: "+colorGreen+"success</color></b>; new shell sent to "+colorOrange+"BUFFER"
            open_it = user_input(colorGreen+"</b>-- view context menu in "+colorOrange+"BUFFER"+CT+"? [y/<b>N</b>] ||: "+colorWhite,0,1)
            if open_it.lower == "y" then return command.malp("-b",locals.sh) else globals.BUFFER.push(locals.sh)
            colorGold+"</b>psudo: returning shell object..."
            return locals.sh
        else 
            return colorGold+"</b>psudo: "+colorRed+"</b>failed</color> to obtain shell object"+char(10)+colorGold+"</b>-- check credentials and try again"
        end if
    end function
//
    _shell_prompt = function(sh)
		if typeof(sh) != "shell" then return colorGold+"psudo: error, expected shell, got: "+sh
        if user_input(colorGold+"</b>psudo: "+colorOrange+"warning; start_terminal ends the script!"+char(10)+
            colorGold+"psudo: "+colorOrange+"warning; start_terminal may result in an active trace"+char(10)+
            colorGold+"</b>Continue? ["+colorWhite+"y"+CT+colorGold+"</b>/"+CT+colorWhite+"N"+CT+colorGold+"</b>] ||: "+colorWhite,0,1).lower == "y" then
                exit locals.sh.start_terminal
                exit "starting_terminal on target shell..."
                return char(10)+
                colorGold+"psudo:"+colorOrange+" Attention: if you are seeing this message:"+char(10)+
                colorOrange+"</b>-- A game anomoly has kept the script running"+char(10)+
                colorOrange+"</b>-- despite having used start_terminal."+char(10)+
                colorOrange+"</b>-- You will need to manually exit out of 5hell to start the terminal."+char(10)+
                colorOrange+"</b>-- Note: you must <b>exit</b>; do not use ctrl+c"
                exit "This is a game bug, not mine."
            return 0
		else 
		 	return colorGold+"</b>psudo: aborting..."
        end if
    end function
//
	if not operation then operation = _psudo_menu
	if not operation then return colorGold+"</b>psudo: aborting..."
    // if it's a shell we warn and confirm
    if typeof(operation) == "shell" then _shell_prompt(operation)
//
    // otherwise we parse the flag or return if invalid flag
    if typeof(operation) != "string" then return colorGold+"</b>psudo: aborting..."
// 
    if operation == "-l" or operation == "-y" then return _shell_prompt(globals.shell)
//
	usr = null
	psw = null
    if operation == "-u" then 
		if not arg2 then usr = user_input("user name:> ") else usr = arg2 
		if arg3 then psw = arg3 else psw = user_input("user passwor:> ")
		return _go_time(usr,psw)
	end if
//
    if operation == "-s" then
		usr = "root"
		if not arg2 then psw = user_input("root password:> ",1) else psw = arg2
		return _go_time(usr,psw)
	end if
//
    return colorGold+"</b>psudo: invalid input"+char(10)+"-- aborting..."
end function
command.ls = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "-h" or arg1 == "help" then return "List Files | List Folders | File Details"+char(10)+
	"Usage: ls [opt: -l|-a|-s|-r] [opt: /path] -- list files in path"+char(10)+
	"Opt: [-l] -- list all file details for given path"+char(10)+
	"Opt: [-a] -- list all files, alphabetically, for given path"+char(10)+
	"-- by default files and folders are listed from first created"+char(10)+
	"---- to last created "+char(10)+
	"Opt: [-s] -- list all files by size (not yet implemented)"+char(10)+
	"Opt: [-r] -- list all files and return raw, uncolorized output"+char(10)+
	"Note: option flags may be combined in any order"+char(10)+
	"-- eg: <b>ls -lars"
	if DEBUG then print "debug: in ls"
	subFiles = null
	folderPath = globals.currentPath
	if DEBUG then print("ls: "+folderPath)
	raw_output = false
	showHide = 1
	showDetails = 0
	a_order = 0
	s_order = 0
	if arg1 then 
		if arg1.indexOf("-") == 0 then // we have flags
			if arg2 then folderPath = arg2
			//if arg1.indexOf("a") != null then showHide = 1
			if arg1.indexOf("l") != null then showDetails = 1
			if arg1.indexOf("a") != null then a_order = 1
			if arg1.indexOf("s") != null then s_order = 1
			if arg1.indexOf("r") != null then raw_output = true
		else 
			folderPath = arg1
		end if
	end if 
	folder = globals.get_file(folderPath)
	if not folder then return "ls: No such file or directory"
	if DEBUG then print("folder: "+folder.path+" is a: "+typeof(folder))
	//if not folder.has_permission("r") then return "ls: permission denied"
	if folder.is_folder then 
		subFiles = folder.get_folders + folder.get_files
		if DEBUG then print "debug: pre alpha sort"
		if a_order then 
			f_buf = []
			s_buf = []
			for sub in subFiles 
				f_buf.push(sub.name)
			end for
			f_buf.sort
			for f in f_buf 
				for sub in subFiles
					if sub.name == f then s_buf.push(sub)
				end for 
			end for 
			subFiles = s_buf
		end if
		if DEBUG then print "debug: pre size sort"+char(10)+
		"-- subFiles: "+subFiles
	else 
		subFiles = [folder]
	end if
	output = ""
	for subFile in subFiles
		line_color = colorWhite+"</b>"
		nameFile = subFile.name
		permission = subFile.permissions
		owner = subFile.owner
		size = subFile.size
		group = subFile.group
		is_bin = subFile.is_binary
		if is_bin then line_color = colorCyan + "</b>"
		if subFile.is_folder then line_color = colorLightBlue + "</b>"
		if NIGHTLY == true and subFile.is_symlink then nameFile = colorGold+"</b>"+nameFile
		if raw_output then line_color = ""
		//if showHide or nameFile.indexOf(".") != 0 then
		if showDetails then
			output = output + char(10) + line_color + permission + " " + owner + " " + group + " "+ size + " bin["+is_bin+"] " + nameFile
		else
			output = output + char(10) + line_color + nameFile
		end if
		//end if
	end for

	output = output.trim
	output = output.split(char(10))
	//i = 0
	// for line in output
	// 	if line.values[0] == "d" then 
	// 		output[i] = colorLightBlue+"</b>"+line
	// 	else
	// 		output[i] = colorWhite+"</b>"+line
	// 		if line.indexOf("bin[1]") != 0 then output[i] = colorCyan+"</b>"+line
	// 	end if
	// 	i = i + 1
	// end for
	return format_columns(output.join(char(10)).trim)
	//return output
end function
command.cd = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "Usage: cd [path] -- change current working directory to path"+char(10)+"Usage: cd .. -- go back to parent directory."+char(10)+"Usage: cd -- return to home directory."+char(10)+"Returns: 0 on success or string on failure."
	if arg1 == "" then arg1 = 0
	if not globals.get_file(globals.currentPath) then globals.currentPath = home_dir
	cd = localmachine.File(globals.currentPath)
	if not arg1 then
		globals.currentPath = globals.homePath
		return 0
	end if
	if not cd then
		globals.currentPath = "/"
		return "cd: path error. Setting path to<b> / </b>"+char(10)+"...please try again."
	end if
	if arg1 == ".." then
		if cd.name != "/" then
			globals.currentPath = cd.parent.path
		end if
		return 0
	end if
	new_path = globals.get_file(arg1)
	if new_path then
		if new_path.is_folder then globals.currentPath = new_path.path else return "cd: "+new_path.path+" is not a directory."
	else
		return "cd: "+arg1+" not found."
	end if
	return 0
end function
command.rm = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == 0 or arg1 == "-h" or arg1 == "help" then return "<b><u>Remove File || RM || Delete</b></u> "+char(10)+"Usage: rm [opt:-r] [path|file_object] [opt:shell|computer]"+char(10)+"Usage: rm [path|file_object] - deletes a file"+char(10)+"Usage: rm -r [path|file_object] - deletes a folder (and all contents)"+char(10)+"Usage: rm [opt:-r] [/absolute/path] [shell_object|computer_object]"+char(10)+"-- uses supplied shell or computer to delete file or folder at path"+char(10)+char(10)+"N.B. The system.log delete entry will be from the originating IP"+char(10)+"-- NOT the ip of the remote shell or computer"+char(10)+"-- be sure to clean the log when remote deleting"
	path_to_delete = null
	recursive = false
	remote = false
	shell_to_use = globals.shell 
	file = null
	usage = "rm: usage:<b> rm [opt:-r] [path|file_object] [opt:shell|computer]</b>"
	print "<u>"+colorRed+"- - - - - "
	if arg1 == "-r" then 
		recursive = true 
		arg1 = arg2 
		arg2 = arg3 
	end if	
	if not arg1 then return usage
	if typeof(arg1) == "string" then 
		path_to_delete = arg1 
		file = globals.get_file(path_to_delete)
	end if
	if typeof(arg1) == "file" then 
		file = arg1
		path_to_delete = file.path 
	end if
	if typeof(arg1) == "shell" or typeof(arg1) == "computer" then return usage
	if not path_to_delete then return usage 
	if arg2 and typeof(arg2) == "shell" then 
		shell_to_use = arg2 
		remote = true 
		file = shell_to_use.host_computer.File(path_to_delete)
		if not file then return "rm: file not found on remote shell." else print "rm: found file on remote shell..."
	end if
	if arg2 and typeof(arg2) == "computer" then file = arg2.File(path_to_delete) 
	if file then
		if not file.has_permission("w") then return "rm: permission denied"
		print "rm: "+colorWhite+"deleting: </b><u>"+file.path
		if file.is_folder then
			if recursive == true then return file.delete else return "rm: use<b> rm -r [path|file_object] </b>to remove a folder."
		end if
		return file.delete
	end if
	return "rm: file not found."
end function
command.mv = function(arg1, arg2=0, arg3=0, arg4=0)
	if arg1 == "-h" or arg1 == "help" then return "MOVE || MV || rename || I like to move it move it"+char(10)+
	"Usage: mv [source_path|file_object] [destination_path|file_object]"+char(10)+
	"-- move file or folder to new path"+char(10)+
	"-- optionally rename the file"+char(10)+
	"-- if destination is folder uses original filename, else renames"+char(10)+
	"-- overwrites destination file if it exists and is not a folder"+char(10)+
	"-- if file objects are supplied then uses the object's path"+char(10)+
	"Usage: mv [source_path|file_object] [@] -- move file to current path using original file name"+char(10)+
	"-- e.g:<b> mv bob /burger -- moves bob to / dir and renames to burger"+char(10)+
	"---- if /burger is a directory; moves bob into burger as /burger/bob"+char(10)+
	"NOTE: this command moves files between folders on the machine local to the file object"+char(10)+
	"-- please use <b>scpm</b> or BUFFER <b>scp</b> to transfer files between machines"+char(10)

	if not arg1 or not arg2 then return "mv: not enough input"
	if typeof(arg1) != "string" and typeof(arg1) != "file" then return "mv: invalid parameters;"+char(10)+
	"-- expects strings or file objects"
	if typeof(arg2) != "string" and typeof(arg2) != "file" then return "mv: invalid parameters;"+char(10)+
	"-- expects strings or file objects"
	print "<u>"+colorLightBlue+"= = = = ="
	if typeof(arg1) == "file" then 
		if p_validate(arg1,"size") then file = arg1 else return "mv: error: input file object does not exist"
	else 
		file = globals.get_file(arg1)
	end if
	if not file then return("mv: can't find " + arg1)
	destination = null
	final_name = null
	// check for file object
	if typeof(arg2) == "file" then 
		if p_validate(arg2,"size") then dest = arg2 else return "mv: error: output file object does not exist"+char(10)+
		"-- please purge this object, recreate the file, or supply a string instead"
	else 
		dest = globals.get_file(arg2)
	end if
	if not dest then
		if typeof(arg2) == "string" then 
			split = arg2.split("/")
			final_name = split.pop
		else 
			return "mv: invalid parameters"
		end if
		if DEBUG then print("split: "+split)
		if split.len and split[0] == "" then dest = globals.get_file(split.join("/")) else dest = globals.get_file(split.join("/"))
		if DEBUG then print("dest: ["+dest+"]")
		if not dest then
			if arg2[0] == "/" then destination = "/" else destination = currentPath
		else
			destination = dest.path
		end if
	else
		if dest.is_folder then
			destination = dest.path
			final_name = file.name
			if dest.path == file.path then destination = dest.parent.path
		else
			destination = dest.parent.path
			final_name = dest.name
		end if
	end if
	if final_name == "@" then final_name = file.name
	if destination == "/" then print "mv: "+file.path+" -> "+destination+final_name+"..." else print "mv: <u>"+colorWhite+file.path+" -> "+destination+"/"+final_name+"..."
  return file.move( destination, final_name )
end function
command.cp = function(arg1, arg2=0, arg3=0, arg4=0)
  if arg1 == 0 or arg2 == 0 or arg1 == "-h" or arg1 == "help" then return "COPY || copy files || CP"+char(10)+
  "Usage: cp [/old_path] [/new_path] -- copy file or folder to new_path "+char(10)+
  "Usage: cp [/old_path] [@] -- copy old path to current path and use original file name"+char(10)+
  "Usage: cp [/old/path] [/newpath/newname] -- make a copy of a file with a new name/path"+char(10)+
  "Usage Example:"+char(10)+
  "-- cp /root/file.txt @ "+char(10)+
  "---- copies file.txt to the current directory with name: file.txt"+char(10)+
  "Usage Example:"+char(10)+
  "-- poke /root/haha |  | poke /root/heehee |  | cp /root/haha /root/heehee"+char(10)+
  "---- creates files haha and heehee then copies haha over heehee, overwriting heehee"+char(10)+
  "Usage Example:"+char(10)+
  "-- poke haha |  | grep -p syst / | cp haha"+char(10)+
  "---- create file haha, grep for (system.log) and return file_path, overwrite /var/system.log with haha"
  print "<u>"+colorGreen+"= = = = ="
  file = globals.get_file(arg1)
  if not file then return("cp: can't find " + arg1)
  destination = null
  final_name = null
  dest = globals.get_file(arg2)
  if not dest then
    split = arg2.split("/")
    final_name = split.pop
		if DEBUG then print("split: "+split)
    if split.len and split[0] == "" then dest = globals.get_file(split.join("/")) else dest = globals.get_file(split.join("/"))
		if DEBUG then print("dest: ["+dest+"]")
		if not dest then
      if arg2[0] == "/" then destination = "/" else destination = currentPath
    else
      destination = dest.path
    end if
  else
    if dest.is_folder then
      destination = dest.path
      final_name = file.name
    else
      destination = dest.parent.path
      final_name = dest.name
    end if
  end if
	if final_name == "@" then final_name = file.name
	if destination == "/" then print "cp: "+file.path+" => "+destination+final_name+"..." else print "cp: <u>"+colorWhite+file.path+" => "+destination+"/"+final_name+"..."
	print colorGold+"- - - - - - - - - - - - - - - - - - - - - - -"
  return file.copy( destination, final_name )
end function
command.usr = function(arg1, arg2, arg3=0, arg4=0)
	if not arg1 or arg1 == "-h" or arg1 == "help" then return "USR || ADD USER || CHOWN"+char(10)+
	"Usage: usr [opt: -r] [new_owner] [path] "+char(10)+
	"-- [-r] flag makes the command recursive on all files and folders below [path]"+char(10)+
	"Usage: usr [-a|add] [opt:user] [opt:password] -- add a user to the system"+char(10)+
	"-- omitting user and or password will result in a prompt for these values"+char(10)+
	"Usage: usr [-d|del] [username] [opt:bool 1|0] -- delete a user from the system"+char(10)+
	"-- 0 == do not delete the home folder"+char(10)+
	"-- 1 == delete the home folder"+char(10)+
	"-- any other value results in a prompt"+char(10)+
	"Usage: usr [path] -- return owner of file at path"+char(10)+
	"-- Do not a name user add or del, for #reasons."+char(10)+
		"-- It is good practice to run:"+char(10)+
		" |><b> usr -r root / | grp -r root / | rm /etc/passwd | lock </b>"+char(10)+
		"-- or <b> kore -s</b> for optimal security"
	is_recursive = false 
	if arg1 == "add" then
		if not arg2 then arg2 = user_input("new_user:> ")
		if not arg3 then arg3 = user_input(arg2+" password:> ")
		if arg2 == "" then return "usr: aborting..."
		print "usr: attempting to create user:<b> "+arg2
		uc = localmachine.create_user(arg2, arg3)
		if uc == 1 then return "-- user created" else return uc 
	end if
	if arg1 == "del" then
		d_user = null
		if not arg2 then d_user = user_input("del_user:> ") else d_user = arg2
		del_home = null
		if arg3 == "0" then del_home = false 
		if arg3 == "1" then del_home = true 
		if del_home == null then 
			del_home = user_input("Delete /home/"+d_user+"? [Y/n] "+char(10)+"||: ",0,1)
			if del_home == "n" then del_home = false else del_home = true
		end if
		ud = localmachine.delete_user(d_user, del_home)
		if ud == 1 then return "usr: deleted user: "+d_user else return ud
	end if
	if arg1 == "-r" or arg1 == "-R" then 
		arg1 = 1
	end if
	if typeof(arg1) == "string" then // check owner of string: /file/path
		if not arg2 then
			check_u = globals.get_file(arg1)
			if typeof(check_u) == "file" then return check_u.owner 
		end if
	end if
	if arg1 == 1 then // recursive
		if not arg3 then return "usr: invalid arguments. please supply a path."
		t_f = globals.get_file(arg3)
		if t_f then return t_f.set_owner(arg2, 1) else return "usr: "+arg3+" not found."
	else // not recursive
		if not arg2 then return "usr: "+arg1+" not found <b>or</b> path not supplied."
		t_f = localmachine.File(arg2)
		if t_f then return t_f.set_owner(arg1, 0) else return "usr: "+arg2+" not found."
	end if
	return 0
end function
command.grp = function(arg1, arg2, arg3=0, arg4=0)
	if not arg1 or arg1 == "-h" or arg1 == "help" then return "<u>GROUP || ADD GROUP || CHGRP</u>"+char(10)+"Usage: grp [optional: -r -- recursive] [new_group] [path] "+char(10)+"Usage: grp [add|del] [group] [user] -- add or remove group to|from user."+char(10)+"Usage: grp -u [user] -- returns groups associated with user"+char(10)+"Usage: grp -f [path] -- returns group associated with file at path"+char(10)+"-- Do not name group add or del for #reasons."+char(10)+"-- It is good practice to run:"+char(10)+"|><b> usr -r root / | grp -r root / | rm /etc/passwd | lock </b>"+char(10)+"for optimal security."
	is_recursive = false
	if arg1 == "-f" then 
		if not arg2 or arg2 == "" then return "Usage: grp -f [path]"
		f_t = globals.get_file(arg2)
		if not f_t then return "grp: "+arg2+" not found."
		return f_t.group
	end if 
	if arg1 == "-u" then 
		if not arg2 or arg2 == "" then return "Usage: grp -u [user]"
		return globals.localmachine.groups(arg2)
	end if 
	if arg1 == "add" then
		if not arg2 or not arg3 then return "Usage: grp add [group] [user]"
		return localmachine.create_group(arg3, arg2)
	end if
	if arg1 == "del" then
		if not arg2 or not arg3 then return "Usage: grp del [group] [user]"
		return localmachine.delete_group(arg3, arg2)
	end if
	if arg1 == "-r" or arg1 == "-R" then is_recursive = true
	if is_recursive then
		if not arg3 then return "grp: invalid arguments. Usage: grp -r [group] [path]."
		t_f = localmachine.File(arg3)
		if t_f then return t_f.set_group(arg2, 1) else return "grp: "+arg3+" not found."
	else
		if not arg2 then return "grp: invalid arguments. Usage: grp [group] [path]"
		t_f = localmachine.File(arg2)
		if t_f then return t_f.set_group(arg1, 0) else return "grp: "+arg2+" not found."
	end if
	return 0
end function
command.perms = function(arg1, arg2, arg3=0, arg4=0)
	if DEBUG then print("__debug: in perms")
	if (arg1 == "-h" or arg1 == "help") and arg2 == "extra" then return "Q: Perms lock all (aka the <b>lock</b> command): what does it do?"+char(10)+"A: the following:"+char(10)+"perms -R o-rwx /"+char(10)+"perms -R g-rwx /"+char(10)+"perms -R u-rwx /"+char(10)+"if on home computer, does the following to avoid lockout:"+char(10)+"perms g+x /bin/sudo"+char(10)+"perms g+x /bin/psudo"+char(10)+"perms g+x /bin/ssh"+char(10)+"perms g+x /usr/bin/Terminal.exe"+char(10)+"perms g+x /usr/bin/Chat.exe"+char(10)+"perms g+x /usr/bin/Mail.exe"+char(10)+"To bypass this and lock down anyway use:<b> perms lock down </b> (use with caution)"+char(10)+"n.b mail and chat are on this list because bugs happen when they are fully locked."
	perms_usage = "<u>CHMOD || PERMISSIONS || PERMS || SECURITY</u>"+char(10)+
		colorWhite+"Usage: perms [opt:-r] [userstring{+|-}permission] [path]"+char(10)+
		"-- opt: -r -- run recursively on all files and folders under [path]"+char(10)+
		"-- userstring -- o = other, g = group, u = user/owner"+char(10)+
		"-- toggle -- [+] = add permission, [-] = remove permission"+char(10)+
		"-- permission -- r = read, w = write, x = execute"+char(10)+
		"E.G:<b> perms -r o-rwx / </b> -- remove rwx permissions from 'others' for all files"+char(10)+
		"E.G:<b> perms -r g+x /bin</b> -- add group execute permissions to all files in /bin"+char(10)+char(10)+
		"<color=white>Aliases:"+char(10)+
		"Usage: perms lock all -- remove all permissions from all files (alias:<b> lock</b>)"+char(10)+
		"-- includes anti-brick technology: checks for home pc and relaxes certain permissions:"+char(10)+
		"---- checks for user_email_address: if found, determines we are at home"+char(10)+
		"---- if at home add g+x to: sudo, ssh, Terminal.exe, Chat.exe, Mail.exe"+char(10)+
		"Usage: perms lock down -- force locking down, bypassing anti-brick technology"+char(10)+		
		"Usage: perms unlock all -- add o+rwx to all files"+char(10)+
		"<b>Shortcut:</b> lock -- alias for <b>perms lock all</b>"+char(10)+
		"-- it is good practice to run:"+char(10)+
		"|><b> usr -r root / | grp -r root / | rm /etc/passwd | lock </b>"+char(10)+
		"--for optimal security."+char(10)+
		"-- you may type:<b> kore -s</b> to have this action performed for you"
		"Extra: perms [-h|help] extra -- view extra help information about this command."
	if arg1 == "-h" or arg1 == "help" or arg1 == 0 or arg2 == 0 then return perms_usage
	if arg1 == "unlock" then return command.perms("-R", "o+rwx", "/")
	if arg1 == "lock" then
		if not localmachine.File("/").has_permission("w") then return "perms: lockdown failed: permission denied"
		command.perms("-R", "o-rwx", "/")
		command.perms("-R", "g-rwx", "/")
		command.perms("-R", "u-rwx", "/")
		//home = user_mail_address//user_input("r u home? [y/N] "+char(10)+"||: ",0,1)
		home = null 
		
		processes = localmachine.show_procs.split(char(10))
		for p in processes
			if p == "USER PID CPU MEM COMMAND" then continue
			process = p.split(" ")
			process_ID = process[1]
			process_CMD = process[4]
			if process_CMD == "Xorg" then  home = true
		end for

		if home != null and arg2 != "down" then//home == "y" or home == "Y" then
			print(colorBlack+"<mark=red><size=75%><color=yellow>Auto-detected: u r home</mark> -- locking file permissions")
			command.perms("g+x","/bin/sudo")
			command.perms("g+x","/bin/psudo")
			command.perms("g+x","/bin/ssh")
			command.perms("g+x","/usr/bin/Terminal.exe")
			command.perms("g+x","/usr/bin/Chat.exe")
			command.perms("g+x","/usr/bin/Mail.exe")
			print("<b><size=75%>perms: setting critical binaries to <b>g+x</b>...")
			print("<size=75%>perms: rerun with <b>perms lock all</b> to force full lockdown")
		end if
		if arg2 == "partial" then command.perms("-R","g+x", "/")
		return "perms: lockdown complete"
	end if
	perms = arg1
	pathFile = arg2
	isRecursive = 0
	if arg1 == "-R" or arg1 == "-r" then
		perms = arg2
		if arg3 and typeof(arg3) == "string" or typeof(arg3) == "file" then pathFile = arg3 else return "perms: invalid path"
		isRecursive = 1
	end if
	if typeof(pathFile) == "string" then file = globals.get_file(pathFile)
	if typeof(pathFile) == "file" then file = pathFile 
	if not file then return("perms: can't find " + pathFile)
	output = file.chmod(perms, isRecursive)
	if output then print(output)
	return 0
end function
command.mkdir = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "/" or arg1 == 0 or arg1 == "-h" or arg1 == "help" then	return "Usage: mkdir [/path/new_folder] -- create a new folder in path. path must exist."
	if globals.get_file(arg1) then return "mkdir: "+arg1+" already exists."
	newpath = arg1.split("/")
	new_dir = ""
	if newpath[0] == "" then
		newpath.pull
		new_dir = "/"
	else
		new_dir = currentPath
		if new_dir != "/" then new_dir = new_dir + "/"
	end if
	new_name = newpath.pop
	new_dir = new_dir+newpath.join("/")
	if new_dir == "" then new_dir = "/"
	new_dir = globals.get_file(new_dir)
	if not new_dir then return "mkdir: unable to create "+arg1+": parent folder not found."
	print colorGold+"<b>mkdir: creating <b>"+new_name+" in:</b> "+new_dir.path
	return localmachine.create_folder( new_dir.path , new_name )
	return 0
end function
command.cat = function(arg1, arg2=0, arg3=0, arg4=0)
	if not arg1 or arg1 == "help" or arg1 == "-h" then return "File Contents || cat || what's in that file"+char(10)+
	"Usage: cat ["+colorWhite+"path_to_text_file"+CT+"] -- returns contents of text file or null if read denied"+char(10)+
	"Usage: cat ["+colorLightBlue+"file_object"+CT+"] -- <b>returns</b> contents of piped file object"+char(10)+
	"-- e.g: grep -f passwd | cat "+char(10)+
	"Usage: cat ["+colorOrange+"-n|--noparse"+CT+"] [path|object] -- <b>prints</b> contents of text with with richtext tags escaped "+char(10)+
	"-- ie: it uses the <noparse><noparse> richtext tag"
	file = null
	kittehns = ["=^._.^= S","^-^","^ ^","~(^._.)","(^._.^)s","(^..^)S","(^-.-^)","Z(=^.^=)"]
	kittehns.shuffle
	kitteh = kittehns.pop
    no_parse = false
    if arg1 == "-n" or arg1 == "--noparse" then 
        no_parse = true 
        arg1 = arg2
        arg2 = arg3 
        arg3 = arg4
    end if
	print "<u>"+colorGold+"- - - - - - - - - c a t - - - - - - - -"+char(10)+
			    colorGold+"                 "+kitteh+"              "
	if typeof(arg1) == "file" then
		file = arg1
	else
		if typeof(arg1) == "string" then
			if arg1 == "" or arg1 == " " then return "cat: file not found."
			if arg1.indexOf(char(10)) != null then return "cat: invalid input"
			file = globals.get_file(arg1)
			if not file then return ("cat: "+arg1+" not found")
		else
			return "cat: expected path or file_object, got "+arg1
		end if
	end if
	if file.is_binary then return ("Cannot open binary file: "+arg1)
	if no_parse then print file.get_content.noparse else return file.get_content
	return 0
end function
import_code("/root/src/dtools.5pk")
if DEBUG then 
	if command.hasIndex("grep") then print "debug: dtools loaded"
end if 
command.run = function(arg1, arg2, arg3=0, arg4=0)
	if DEBUG then print("debug: arg1: "+arg1+ " :end arg1")
	if not arg1 or arg1 == "help" or arg1 == "-h" then return "run [file|path_to_file] [opt:parameters|shell] [opt:shell|parameters -- launch a script binary at path (gui's not supported)"+char(10)+"-- piped file objects are launched from the objects path"+char(10)+"-- max 14 nested launches before stack call error."+char(10)+"-- providing a shell object will launch a binary using that shell object"+char(10)+"-- you must pipe launch params if more than one word"+char(10)+"-- use echo and easy clip for best results (@a,@b,@c)"+char(10)+"---- eg: echo do 1 -f pwn.bat | clipa | clipb @B 1 | run /home/guest/rkit/5hell @b @a"+char(10)+"---- eg: echo rshell 1.1.1.1 | clipa | brutus | run /root/rkit/5hell @a"+char(10)+"Note: run supports pshells with the launch function however p_objects are not currently in game"
	if typeof(arg1) != "string" and typeof(arg1) != "file" then return "run: arg1 should be file object or path to file" 
	parameters = ""
	if arg2 and typeof(arg2) == "shell" then
		if arg3 and typeof(arg3) == "string" then parameters = arg3 else parameters = ""
		if typeof(arg1) == "string" then 
			globals.stack_pool("up")
			cc = arg2.launch(arg1, parameters)
			globals.stack_pool("down")
			return cc
		end if
		if typeof(arg1) == "file" then 
			globals.stack_pool("up")
			cc = arg2.launch(arg1.path, parameters)
			globals.stack_pool("down")
			return cc
		end if
		return "run: arg1 should be file or path to file"
	end if
	if arg3 and typeof(arg3) == "shell" then 
		run_path = null
		if typeof(arg1) == "string" then run_path = arg1
		if typeof(arg1) == "file" then run_path = arg1.path
		if typeof(run_path) != "string" then return "run: arg1 should be file object or path to file"
		if typeof(arg2) == "string" then parameters = arg2
		if typeof(arg2) == "file" then return "run: arg2 should be string (params) or shell object"
		globals.stack_pool("up")
		cc = arg3.launch(run_path, parameters)
		globals.stack_pool("down")
		return cc
	end if
	file = arg1
	if typeof(file) != "file" then file = globals.get_file(arg1)
	if not file then return "run: "+arg1+" not found."
	//globals.stack_pool = globals.stack_pool - 1
	parameters = ""
	if arg2 and typeof(arg2) == "string" then parameters = arg2
	if arg3 and typeof(arg3) == "string" then parameters = parameters + " " + arg3 
	if arg4 and typeof(arg4) == "string" then parameters = parameters + " " + arg4 
	//if arg5 and typeof(arg5) == "string" then parameters = parameters + " " + arg5 
	if DEBUG then print("run: "+file.path+", "+parameters)
	globals.stack_pool("up")
	cc = shell.launch(file.path, parameters)
	globals.stack_pool("down")
	return cc
end function
command.scribus = function(arg1=0, arg2=0, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "Scribus Terminal Text Editor by Plu70"+char(10)+"scribus [path_to_file] -- open terminal text editor on file at path"+char(10)+"Advanced: scribus @clipa|@clipb|@clipc -- This edits the clipboard directly."+char(10)+"Advanced: scribus @cc -- edit the command buffer."+char(10)+"Advanced: scribus [file_object] -- text only, open contents of piped object."+char(10)+"Advanced: scribus @do -- edit the do buffer (to write / edit <b>do</b> scripts without launching them)"+char(10)+"-- see <b>do -h</b> for more info"+char(10)+"Note: you may press <b>@h</b> on a new line to get additional command info within the editor."
	p = arg1
	if not p then
		print(":> "+colorCyan+"/relative/path/to/file"+CT+" - open a text file in the editor")
		print(":><b> @clipa | @clipb | @clipc </b>- edit clipboards in the editor"+char(10)+":><b> @do </b>- edit do command buffer (without running do)"+char(10)+":> @cc edit command buffer"+char(10)+"press <return> to abort.")
	end if
	if p == 0 then p = user_input("Scribus:> ")
	if p == "" then return "aborting..."
	if p == "@cc" then
		print("Editing the command buffer...")
		globals.command_buffer = globals.scribus(globals.command_buffer).split(char(10))
		return 0
	end if
	if typeof(p) == "file" then return globals.scribus(p)
	if p == "@clipa" then return command.clipa(globals.scribus(globals.clip_board_alpha))
	if p == "@clipc" then return command.clipc(globals.scribus(globals.clip_board_gamma))
	if p == "@clipb" then return command.clipb(globals.scribus(globals.clip_board_beta))
	if p == "@do" then
		if not globals.clip_board_delta then globals.clip_board_delta = []
		globals.clip_board_delta = globals.scribus(globals.clip_board_delta)
		print("do: clipped: "+char(10)+colorBlack+"*"+CT+char(10)+globals.clip_board_delta)
		return globals.clip_board_delta
	end if
	if typeof(p) == "string" then
		f = localmachine.File(p)
		if not f then f = localmachine.File(currentPath+"/"+p)
		if not f then f = localmachine.File(currentPath+p)
		if not f then return "scribus: "+p+" not found. "
		//w = user_input(f.path+" found. Open it? [Y/n] ||:",0,1)
		//if w.lower == "n" then return "aborting..."
		return globals.scribus(f)
		//return 1
	end if
	return 0
end function
command.games = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "-h" or arg1 == "help" then return "games: battleship and blackjack and drugwars!"
	import_code("/root/src/games.5pk")
	return 0
end function
command.mail = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return colorGreen+"<u></color>"+colorGold+"Mail || metaMail || herme5 || hermes || mail client"+char(10)+
	"herme5 mail client: its the mail (wip) -- its good enough but you may want to write your own;"+char(10)+
	"-- name your function<b> command.mail </b> to overwrite this one."+char(10)+
	"-- see 5hell.src, template.5pk.src for instructions."+char(10)+
	"Note: You may overwrite any command this way."+char(10)+char(10)+
	colorGold+"- - - - - - - - - - - - - - - - - - - - - - - - - - - -"+char(10)+
	"Usage: mail -- opens the herme5 mail menu"+char(10)+
	"Extra: when prompted for a password you may enter:</b> -brutus"+char(10)+
	"-- this will invoke <b>brutus</b> and attempt to crack the email password."+char(10)+
	"-- the password will be saved to the custom object as:"+char(10)+
	"-- key == password and value == public_ip:local_ip"+char(10)+
	"---- this will change once i work out a better storage system bc this is not ideal"+char(10)+
	"Extra: when viewing your inbox you may type <b>spool</b> to dump all mail to a file (up to 160kb)"
        herme5 = function()
            mail = {}
            mail.meta = null  // metaMail object
            if globals.inbox then mail.meta = globals.inbox
            mail.data = null
            if globals.inbox then mail.data = mail.meta.fetch
            mail.user = null
            if globals.inbox then mail.user = globals.mail_user
            mail.pass = null
            if globals.inbox then mail.pass = true
          
            mail.pwn = function(arg)
              dsize = globals.dict_a.len
              mode = user_input("[<b>0</b>] Onboard Dictionary -- [1] /root/tables/tp ")
              if mode == "0" or mode == "" then
                reverse_it = user_input("[0] start at dict_a[0]  --  [1] start at dict_a[-1] "+char(10)+"(type anything else to abort) ||:",0,1 )
                if reverse_it == "1" or reverse_it == "0" then
                  reverse_it = reverse_it.to_int
                else
                  return 0
                end if
                show_count = user_input("Show the count? ["+dsize+"] [y/N] ||: ",0,1)
                show_pass = user_input("Show passwords? [y/N] ||: ",0,1)
                if show_pass.lower == "y" then show_pass = true else show_pass = false
                if show_count.lower == "y" then show_count = true else show_count = false
                print(colorGold+"Accessing onboard dictionary..."+CT+char(10)+"<align=center><<>></align>")
                ds = dsize - 1
                for p in range( 0, ds )
                  dsize = dsize - 1
                  if reverse_it then pa = globals.dict_a[0 - p] else pa = globals.dict_a[p]
                  if show_count then print(colorGold+colorWhite+"["+CT+dsize+colorWhite+"]"+CT+CT)
                  if show_pass then print(colorGold+colorWhite+"["+CT+pa+colorWhite+"]"+CT+CT)
                  try = mail_login(arg, pa)
                  if typeof(try) == "MetaMail" then
                    print("brutus: <b>password found</b>: "+colorWhite+pa+CT)
					print command.cob("set",pa,arg)
                    return try
                  end if
                end for
              else
                if mode == "1" then
                  tp = localmachine.File("/root/tables/tp")
                  if not tp then return 0
                  print(colorGold+"Accessing /root/tables/tp..."+CT+char(10)+"<align=center><<>></align>")
                  tp_f = tp.get_files
                  i=0
                  for f in tp_f
                    i = i + 1
                    print(i+"/"+(tp_f.len))
                    chunc = f.get_content.split(char(10))
                    for p in chunc
                      try = mail_login( arg, p )
                      if typeof(try) == "MetaMail" then
                        print("brutus: <b>password found</b>: "+colorWhite+p+CT)
						print("brutus: accessing cob: saving password as key, email as value")
						print command.cob( "set", p, arg)
                        return try
                      end if
                    end for
                  end for
                end if
              end if
              return 0
            end function
          
            mail.Login = function()
              if globals.inbox then
                mail.meta = globals.inbox
                return mail.user+" is already logged in."
              end if
              mail.user = user_input("email:> ")
              if mail.user == "" or mail.user == " " then mail.user = user_mail_address
              if not mail.user then return "Invalid mail address."
              print("Enter <b>-brutus</b> to crack password with brutus.")
              mail.pass = user_input(mail.user+" pass:> ", 1)
              if mail.pass == "" or mail.pass == " " then return "Invalid login credentials."
              if mail.pass == "-brutus" then
                mail.meta = mail.pwn(mail.user)
              else
                mail.meta = mail_login(mail.user, mail.pass)
              end if
          
              if typeof(mail.meta) == "MetaMail" then
                globals.inbox = mail.meta
                globals.mail_user = mail.user
                return "Login complete."
              end if
              return "Invalid login credentials."
            end function
            mail.get_id = function(arg)
              ds = mail.data[arg].split(char(10))
              //print(ds)
              i = ds[2].split(" ")
              i = i[1]
              return i
            end function
            mail.Fetch = function()
              if typeof(mail.meta) != "MetaMail" then return "Invalid login credentials."
              mail.data = mail.meta.fetch
              return "Fetching mail for: "+mail.user+"..."+char(10)
            end function
            mail.Read = function()
              if typeof(mail.meta) != "MetaMail" then return "Invalid login credentials."
              print(mail.Fetch)
              print(mail.data_stream(mail.data))
              r = user_input("Enter an index to read or type <b>spool</b> to dump to a file :> ").to_int
              print(colorGold+"- - - - - - - - - - - - - - - - - - - - - - - - - - "+CT)
			  if mail.data.len < 1 then return "herme5: mailbox is empty"
			  spool_buf = []
			  spooling = false
			  if r == "spool" then 
				spooling = true
			  	r = mail.data.len - 1
			  end if
			  while r >= 0
				if r >= 0 and r < mail.data.len then
					read_this = mail.meta.read(mail.get_id(r))
					if spooling then print "<size=80%>herme5: spooling: ["+colorWhite+r+CT+"]" else print(read_this)
					//if spooling then spool_buf.push(mail.data[(r)]+char(10)+read_this+char(10))
					if spooling then spool_buf.push(read_this+char(10))
					if read_this.split(char(10))[2] == "Subject: *" then
						print(colorLightBlue+"<u><mark=#DF8600>= = = = = = = = = = = = = = = = = = = = = = = = = = = = =</mark></u>"+CT)
						print(command.code("-b", read_this[read_this.indexOf("Subject: *")+11:]))
					end if
				end if
				if spooling then r = r - 1 else r = -1
			  end while
			  if spooling then 
			  	st = time
			  	spool_file_path = user_input( colorGold+"herme5: please enter a path for the spool file: "+char(10)+"[/path, <<b>enter</b>=home_dir/spool.txt, </b>q</b>=quit]:> " )
				if spool_file_path.lower == "q" or spool_file_path.lower == "quit" then return "aborting..."
				if spool_file_path == "" or spool_file_path == " " then spool_file_path = homePath+"/spool.txt"
				spool_file = globals.get_file(spool_file_path)
				if typeof(spool_file) != "file" then print "herme5: could not locate spool file."+char(10)+"herme5: creating: "+spool_file_path else print "herme5: spool file found; overwriting"
				if typeof(spool_file) == "file" and spool_file.is_binary then return "herme5: cannot spool to binary file"
				print colorWhite+"<size=80%>Saving data to spool file: <b>"+spool_file_path
				if DEBUG then print "debug: spool_buf is: "+spool_buf+" and is a "+typeof(spool_buf)
				spool_file = command.poke("-f",spool_file_path, current_date+char(10)+char(10)+spool_buf.join(char(10))+char(10)+current_date)
				if typeof(spool_file) != "file" then return "herme5: error: check write permissions"
				globals.BUFFER.push(spool_file)
				wait(.1) 
				ttt = time - st
				print colorGold+"herme5: "+CT+"spool_file object sent to "+colorOrange+"BUFFER"+CT+char(10)+colorGold+"</b>herme5: task completed in <b>"+ttt+"</b> seconds."
			  end if
              return "returning..."
            end function
            mail.Write = function()
              if typeof(mail.meta) != "MetaMail" then return "Invalid login credentials."
              addr = user_input("address:> ")
              subj = user_input("subj:> ")
              mbuf = []
              send = ""
              body = globals.scribus(mbuf)
              munin = user_input(colorLightBlue+"Encode with <mark=black>M</mark>unin<mark=black>C</mark>ipher before sending? [Y/n] ||: "+CT,0,1)
              if munin.lower != "n" then
                send = command.code("-a",body)
                subj = "*"
              else
                send = body
                print(colorGreen+"<u>= = = = = = = = = = = = = = = = = = = = = = = = = = = = =</u>"+CT)
              end if
			  if DEBUG then print "debug: addr: "+addr+char(10)+"-- subj: "+subj+char(10)+"-- send: "+send
              return mail.meta.send( addr, subj, send )
            end function
            mail.Delete = function(r=0)
              if typeof(mail.meta) != "MetaMail" then return "Invalid login credentials."
              print(mail.Fetch)
              print(mail.data_stream(mail.data))
              if not r then r = user_input("delete [*=all,<enter>=quit]:> ").to_int
			  if r and r == "*" then
				for m in range(0,mail.data.len - 1)
					mail.meta.delete( mail.get_id(m) )
			  	end for 
				print colorOrange+"All emails deleted!"
				return mail.Fetch
			  end if
              if typeof(r) == "number" and mail.data.hasIndex(r) then
                id = mail.get_id(r)
                if id then print("Deleting (crt+c to cancel): "+id+"...")
                wait(.5)
                print("in 3...")
                wait(1)
                print("2...")
                wait(1)
                print(mail.meta.delete( id ))
                return mail.Fetch
              else
                return "aborting..."
              end if
              return 0
            end function
            mail.Widget = function()
              if typeof(mail.meta) != "MetaMail" then return "Invalid login credentials."
              if HERMES == true then
                globals.HERMES = false
                wState = "off"
              else
                globals.HERMES = true
                wState = "on"
                globals.this_mail = user_input("Configuring widget..."+char(10)+"pin_mail_# (default: 0 for newest):> ").to_int
                mail.data = mail.meta.fetch
                if typeof(globals.this_mail) == "number" and globals.this_mail >= 0 and globals.this_mail < mail.data.len then
                  print(colorGold+"Pinned: "+colorWhite+globals.this_mail+colorGold+"."+CT+char(10)+colorGold+"Herme5 mail widget configured."+CT)
                else
                  print(colorGold+"Defaulting to: "+colorWhite+"0"+colorGold+"."+CT+char(10)+colorGold+"Herme5 mail widget configured."+CT)
                  globals.this_mail = 0
                end if
              end if
              return "Herme5 mail widget toggled "+wState+"."
            end function
            mail.Exit = function()
              return "herme5: exiting..."
            end function
            mail.data_stream = function(alist)
              d = ""
              i = 0
              for el in alist
                d = d + "[" +colorWhite+ i +CT+ "] " + el + char(10)
                i = i + 1
              end for
              return d
            end function
            mail.menu = function()
              mailing = true
              menu_options = ["Exit", "Login", "Fetch", "Read", "Write", "Widget", "Delete"]
              while mailing
                print(colorGold+"- - - - - - - Herme5 v 0.4.4 by Plu70 - - - - - - - - "+CT)
                print(mail.data_stream(menu_options))
                opt = user_input("(q=quit)||: ",0,1).to_int
                print(colorGold+"- - - - - - - - - - - - - - - - - - - - - - - - - - "+CT)
                if opt == "q" then return 0
                if opt < 0 or opt > menu_options.len-1 or typeof(opt) != "number" then continue
                mm = @mail[menu_options[opt]]
                print(mm)
                mailing = opt
              end while
              return mailing
            end function
            return mail.menu
          end function
          // end Herme5
          //herme5          
	return herme5
end function
command.malp = function(arg1, arg2, arg3=0, arg4=0)
	if @arg1 == "-h" or @arg1 == "help" then return "malp: Memory Alpha - buffer, object and database management menu. "+char(10)+
	"Usage: "+colorGold+"</b>malp"+CT+colorWhite+"</b> -- Access all"+colorOrange+"</b> BUFFER "+CT+"objects from here."+char(10)+
	"Usage: "+colorGold+"</b>malp"+CT+colorWhite+"</b> ["+colorGold+"</b>piped_object"+CT+"] -- adds ANY piped object to the "+colorOrange+"</b> BUFFER "+CT+"."+char(10)+
	colorWhite+"</b>-- May be of any type: string, list, map, shell, file, computer, etc, et al."+char(10)+
	"Usage: "+colorGold+"</b>malp"+CT+colorWhite+"</b> ["+colorOrange+"</b>-b"+CT+"] [opt: piped_object] -- open the"+colorOrange+"</b> BUFFER "+CT+"immediately on opening malp"+char(10)+
	"-- if an object is supplied, it's entry will be opened in the BUFFER"+char(10)+
	"Functions: "+char(10)+
	"[0] -- display portmap, if available"+char(10)+
	"[1] -- display loaded exploits and requirements if known"+char(10)+
	"[2] -- display raw scan output from met scan"+char(10)+
	"-- performs scan if not already scanned"+char(10)+
	"[3] -- dump memory; runs the memdump command"+char(10)+
	"-- this will dump session info such as portmap, exploits-"+char(10)+
	"-- and others to a file named memdump[random number].mx"+char(10)+
	"-- feel free to request additional info dumped by this command"+char(10)+
	"[4] -- access felix file explorer or run tree (locally or on buffered filesystem)"+char(10)+
	colorOrange+"[5] -- the main BUFFER where objects are stored"+char(10)+
	"-- contains contextual object handlers"+char(10)+
	"[6] -- Air menu for cracking wifi"+char(10)+
	"[7|q] -- exit"+char(10)+
	"[8] -- show running processes"+char(10)+
	"[9] -- kill processes"+char(10)+
	"[0] exit"+char(10)+
	"[/] -- open Cer Bios"+char(10)+
	"[-] -- open reverse shell interface"+char(10)+
	"[.] -- linkdb database entry"
	if DEBUG then print("@arg1: "+typeof(@arg1))
	open_buffer = false
	open_entry = false
	if @arg1 then
		if typeof(@arg1) == "string" then 
			if arg1 == "-b" then 
				open_buffer = true 
				arg1 = arg2 
				arg2 = arg3 
				arg3 = arg4 
			end if
		end if
		//if typeof(@arg1) == "function" then
		if @arg1 then 
			//if DEBUG then print("function detected...")
			globals.BUFFER.push(@arg1)
			open_entry = true
		//else
			//if arg1 then globals.BUFFER.push(arg1)
		end if
	end if
	if DEBUG then print("starting malp with:"+char(10)+"--: ob: "+open_buffer+char(10)+"-- oe: "+open_entry)
	//if open_buffer then globals.memory_alpha(true) else globals.memory_alpha(false)
	return globals.memory_alpha(open_buffer,open_entry)
end function
command.fwr = function(arg1, arg2, arg3=0, arg4=0) // requires metaxploit.so
	if GLASSPOOL then print(colorOrange+"fwr: ignores glasspool."+CT)
	if arg1 == "help" or arg1 == "-h" then return "Usage: fwr [ip] -- returns firewall rules for ip. returns local rules if no ip given."
	if not localmachine.is_network_active then return "fwr: no network connection"
	router = get_router
	if typeof(router) != "router" then return "fwr: router not found"
	if arg1 and is_valid_ip(arg1) then
		router = get_router(arg1) 
		if DEBUG then print "debug: router is a: "+typeof(router)
		if typeof(router) != "router" then return "fwr: router not found"
	end if
	if DEBUG then print "debug: router is a: "+typeof(router)
	return router.firewall_rules
end function
import_code("/root/src/kore.5pk")
if DEBUG then 
	if command.hasIndex("kore") then print "debug: kore loaded"
end if 
command.memdump = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "memdump: dump MEMORY, XPLOITS, PORT_MAP, clipboards,  to current_path+/memdump.mx"+char(10)+"n.b. ignores glasspool. main purpose is generating reports for clients."
	return globals.dump_memory
end function
command.enum = function(arg1, arg2=0, arg3=0, arg4=0)
	if not arg1 or arg1 == "help" or arg1 == "-h" then return "<b><u>enumeration || ENUM || enum buffer"+char(10)+
	"Use this to put things in a list."+char(10)+
	"Usage: enum [opt|/path|file_object|array|#]"+char(10)+
	"Usage: enum [list|string] -- enumerates a list or a newline separated string"+char(10)+
	"-- if the string is a single word it will be interpreted as a path"+char(10)+
	"-- multiple words on a single line (piped) will be interpreted as a single entry"+char(10)+
	"Usage: enum [path|file_object]"+char(10)+
	"-- enumerate file contents as a list of strings"+char(10)+
	"-- useful for 5hell scripting (see the '<b>do</b>' command)."+char(10)+
	"-- e.g: enum file.txt | enum 1"+char(10)+
	"---- enumerate file.txt then return index [1] from the list"+char(10)+
	"Usage: enum -l  -- return the length of enum buffer."+char(10)+
	"Usage: enum -s  -- show the enum buffer and return the length"+char(10)+
	"Usage: enum -d  -- enumerate the onboard dictionary"+char(10)+
	"Usage: enum [#] -- return the element at index # in the enum buffer"+char(10)+
	"UsagE: enum -r [index] -- remove the element at index"+char(10)+
	"Usage: enum -i [index] [element] -- insert element at index "+char(10)+
	"-- shifts everything below it down"+char(10)+
	"Usage: enum -a [element] -- append element to end of enum buffer"+char(10)+
	"-- unlike enum [string] you may use enum -a [string] to append a single word to the enum buffer"+char(10)+
	"Usage: enum -e -- return the enum buffer as a list"+char(10)+
	"Usage: enum -b  -- concatonate the BUFFER and globals.enumerated (the enum buffer)"+char(10)+
	"Usage: enum -p -- purge the enum buffer"+char(10)+
	"Advanced: poke files.txt | lock |  | ls | append files.txt | cat files.txt | clipb | enum"+char(10)+
	"-- Or: ls | enum -- pipe ls output to the enum buffer"+char(10)+
	"Advanced: lanpro | enum -- scan network and enumerate all LAN addresses found. "+char(10)+
	"Advanced: enum -e -- return the enumerated buffer as a list object."+char(10)+
	"Note: map support is coming soon(tm)"
	if arg1 == null then return 0
	if not arg1 or arg1 == "0" then
		if globals.enumerated.len then return globals.enumerated[0] else return 0
	end if
	if arg1 == "-r" then 
		if not arg2 then return "enum: -r expects an index"
		if typeof(arg2.to_int) != "number" then return "enum: invalid index"
		if globals.enumerated.hasIndex(arg2.to_int) then 
			globals.enumerated.remove(arg2.to_int)
			return "enum: entry at index "+arg2+" removed"
		else 
			return "enum: invalid index"
		end if
	end if
	if arg1 == "-b" then 
		if globals.enumerated.len < 1 then return "enum: enumerated buffer is empty"
		print "enum: <b>appending enumerated buffer to main BUFFER</b>"
		globals.BUFFER = globals.BUFFER + globals.enumerated
		return 0
	end if 
	if arg1 == "-p" then 
		globals.enumerated = []
		return "enum: "+colorOrange+" enum buffer purged"
	end if
	if arg1 == "-i" then 
		if not arg3 then return "enum: -i [index] [element]"
		buf_bak = globals.enumerated
		if typeof(arg2) != "string" then return "enum: -i expects string index"
		if typeof(arg3) != "string" and typeof(arg3) != "list" then return "enum: -i [index] [string|list]"
		dx = arg2.to_int
		sbb = null 
		if typeof(arg3) == "list" then sbb = arg3 
		if typeof(arg3) == "string" then sbb = arg3.split(char(10))
		if typeof(dx) != "number" or dx >= buf_bak.len or dx < 0 then return "enum: invalid index"
		sli_1 = buf_bak[0:dx]
		sli_2 = buf_bak[dx:]
		new_buf = sli_1 + sbb + sli_2
		return "enum: element inserted at index "+dx
	end if
	if arg1 == "-a" then 
		if not arg2 then return "enum: append failed: missing input"
		sb = ""
		if typeof(arg2) == "list" then sb = arg2
		if typeof(arg2) == "string" then sb = arg2.split(char(10))
		if sb == "" then return "enum: append failed: invalid type: expects string or list"
		globals.enumerated = globals.enumerated + sb
		return "enum: list appended"
	end if
	if arg1 == "-d" then
		globals.enumerated = globals.dict_a[0:]
		print("enum: <b>onboard dictionary enumerated</b>. Num entries:")
		return globals.enumerated.len
	end if
	if arg1 == "-l" then return str(globals.enumerated.len)
	if arg1 == "-s" then
		if not globals.enumerated.len then return 0
		ie = 0
		for ge in globals.enumerated
			print("["+ie+"] " + ge)
			ie = ie + 1
		end for
		return globals.enumerated.len
	end if
	if arg1 == "-e" then
		return globals.enumerated
	end if
	if typeof(arg1) == "list" then 
		globals.enumerated = arg1
		return "enum: list enumerated"
	end if
	if typeof(arg1) == "map" or typeof(arg1) == "custom_object" or typeof(arg1) == "shell" or typeof(arg1) == "computer" or typeof(arg1) == "file" then
	globals.enumerated = []
		for a in arg1
			globals.enumerated.push(a)
		end for
		return "enum: map <b>enumerated.</b>"
	end if
	if typeof(arg1) == "number" then arg1 = str(arg1)
	if typeof(arg1) == "string" and typeof(arg1.to_int) == "number" then
	 	if globals.enumerated.hasIndex(arg1.to_int) then return globals.enumerated[arg1.to_int] else return "enum: error: invalid index"
	end if
	if typeof(arg1) == "string" then
		if arg1.split(char(10)).len > 1 or arg1.split(" ") > 1 then // more than one line or more than one word, otherwise it's a path
			globals.enumerated = arg1.split(char(10))
			for el in globals.enumerated
				if el == "" then
					globals.enumerated.remove(globals.enumerated.indexOf(el))
					continue
				end if
				globals.enumerated[globals.enumerated.indexOf(el)] = el.replace(char(32),"").trim
			end for
			return "enum: entry <b>enumerated.</b>"
		end if
		file = null
		file = globals.get_file(arg1)
		if not file then return "enum: error: "+arg1+" not found."
		arg1 = file
	end if
	if typeof(arg1) == "file" then
		print("enum: purging...")
		globals.enumerated = []
		if arg1.is_binary then return "enum: can't open binary file" else stuff_buf = arg1.get_content
		if stuff_buf then globals.enumerated = stuff_buf.split(char(10)) else return "enum: error: file empty or read protected."
		return "enum: "+arg1+" <b>enumerated.</b>"
	end if
	return "enum: error: unknown type"
end function
command.rclean = function(arg1, arg2=0, arg3=0, arg4=0)
	if DEBUG then print("in rclean: got: "+typeof(@arg1))
	if arg1 == "help" or arg1 == "-h" then return "Remote Clean || log scrubber || system.log cleaner"+char(10)+
	"Copy a file over the system.log to corrupt it"+char(10)+
	"Usage: rclean [opt: int ] -- select an object from buffer to atttempt a remote log wipe."+char(10)+
	"Usage: rclean [file|shell|computer] -- remote wipe piped object"+char(10)+
	"-- e.g. clipb @B 1 | rclean -- where BUFFER[1] was a file|shell|computer"+char(10)+
	"-- rclean with no params will display a menu "+char(10)+
	"-- rclean is intended for remote scrubbing using BUFFER objects."+char(10)+
	"-- However you may use silentclean or rclean for local log scrubbing"+char(10)+
	"-- if rclean detects a file named <b>silentclean</b> it will use that file to scrub the log"+char(10)+
	"-- for this reason it is a good idea to include an empty file named silentclean in the rkit"+char(10)+
	"Usage: rclean -d [#|shell|file|computer] -- run rclean as above and delete rkit and/or 5hell, if present"+char(10)+
	"Usage: rclean -n [#|shell|file|computer] -- run rclean as above and delete the contents of /boot, if present"
	if arg1 and arg1 == "-d" then 
		arg1 = arg2
		arg2 = "-d"
	end if 
	if arg1 and arg1 == "-n" then 
		arg1 = arg2 
		arg2 = "-n"
	end if

	if arg1 and (typeof(arg1) == "shell" or typeof(arg1) == "ftpshell" or typeof(arg1) == "computer" or typeof(arg1) == "file") then return globals.rclean(arg1,arg2)
	if arg1 and typeof(arg1.to_int) == "number" then return globals.rclean(command.clipb("@B",arg1),arg2)
	return globals.rclean(command.clipb("@B","-m"),arg2)
end function
command.ipfit = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "Usage: ipfit -- menu to specify a way to generate ips. (wip)"+char(10)+"Recommendation: pipe the output to a file or to the clipboard."+char(10)+"e.g<b> ipfit | clipb </b>, or<b> ipfit | poke iplist </b>"
	print("Configuring: ")
	print("<b>How do you want to specify ip's? </b>"+char(10)+"[0] - enter manually"+char(10)+"[1] - read from file "+char(10)+"[2] - random")
	print("[3] - specify range"+char(10)+"[4] - from clipb")
	choice = user_input("||: ",0,1).to_int
	ips = []
	if choice == 0 then
		ips = globals.scribus(ips)
		return ips
	end if
	if choice == 1 then
		ips = command.cat(user_input("path_to_file:> "))
		return ips
	end if
	if choice == 2 then
		ips = command.rnip(user_input("# ips to create: "))
		return ips
	end if
	if choice == 3 then
		print("Soon (tm)")
		return "Soon (tm)"
	end if
	if choice == 4 then
		return command.clipb
	end if
	return 0
end function
command.code = function(arg1, arg2, arg3=0, arg4=0)
	if DEBUG then print("input type: "+typeof(@arg1))
	if typeof(@arg1) == "function" then
		print("Function() detected...")
		return globals.decompiler(@arg1)
	end if
	if @arg1 == null or @arg1 == "-h" or @arg1 == "help" then return "<u>character code || cipher || encryption || || decryption || decompiler"+char(10)+
	"<b>CODE</b> encode and decode utility"+char(10)+
	"Supports standard Caesar cipher and 5hell's MuninCipher for encryption."+char(10)+
	"May also return ascii character codes, decompile objects, and execute functions."+char(10)+
	"Usage: code [char] -- returns ascii code for char"+char(10)+
	"Usage: code -c [int] -- returns ascii char(int)"+char(10)+
	"Usage: code [any_function|any_object] -- sends object to decompiler to view object map."+char(10)+
	"-- will evaluate piped functions."+char(10)+
	"Advanced: code [-d|-e] [word] -- decode|encode a word using standard caesar cypher"+char(10)+
	"Advanced: code [-a|-b] [opt:input] -- encode|decode using <b>MuninCipher(tm)</b>"+char(10)+
	"-- prompts for input if not supplied"+char(10)+
	"-- enter text to encrypt|decrypt on a single line up to 40,000 chars"+char(10)+
	"-- if input is more than one word use without params for prompt"+char(10)+
	"-- or use piping or an input file (see -f options)"+char(10)+
	"Advanced: code [-f|-fa|-fb] [/file/path|file_object] -- encode|decode contents of file"+char(10)+
	"-- option [-f] [path] -- prompts for enc/dec"+char(10)+
	"-- option [-fa|-af] [path] -- encode contents of path with MuninCipher"+char(10)+
	"-- option [-fb|-bf] [path] -- decode contents of path with MuninCipher"+char(10)+
	"<b>N.B.</b> MuninCipher is tamper resistant! Attempting to copy/paste the cipher text can/will corrupt it!"
	Encode = function(instruction, password)
    caesar = function(type, pass)
				if pass == "" then return char(32)
        nr = pass.len%9
				if nr == 0 then nr = 25
        crypt = function(char, nr, type)
            if type == "enc" then return char+nr
            if type == "dec" then return char-nr
        end function
        out = []
        for i in range(0, pass.len-1)
            c = pass[i].code
            if c >= 48 and c <= 57 then
                c = crypt(c, nr, type)
                if c < 48 then c = c+10
                if c > 57 then c = c-10
            else if c >= 65 and c <= 90 then
                c = crypt(c, nr, type)
                if c < 65 then c = c+26
                if c > 90 then c = c-26
            else if c >= 97 and c <= 122 then
                c = crypt(c, nr, type)
                if c < 97 then c = c+26
                if c > 122 then c = c-26
            end if
            out.push(char(c))
        end for
        return out.join("")
    end function
    output = caesar(instruction, password)  // instruction should be either "enc" for encode or "dec" for decode
    return output
	end function
	if @arg1 == 0 then return str(char(32).code)
	if @arg1 == "0" then return str("0".code)
	if typeof(@arg1) == "number" then
		print("<mark=red><size=75%>Converting integer...</mark></size>")
		arg1 = str(arg1)
	end if
	if @arg1 == "-a" or @arg1 == "-b" then
		enc_line = arg2
		if arg2 and typeof(arg2) != "string" then return "code: -a|-b expects string input, got"+typeof(arg2)
		if not arg2 then enc_line = user_input("MuninCipher:> ")
		if enc_line.len > 40000 and @arg1 == "-a" then return "MC: max 40k characters for encode"
		cipher_input = []
		cipher_output = []
		enc_dec = "enc"
		if @arg1 == "-b" then enc_dec = "dec"
		cipher_this = ""
		if enc_dec == "enc" then
			cipher_input = enc_line.split(char(32))
		else
			cipher_input.push(arg2)
		end if
		print(colorLightBlue+"<mark=black>M</mark>unin<mark=black>C</mark>iphering: "+cipher_input.join(" "))
		/////////////////////////////////////
		if enc_dec == "dec" then
			//input_split = Encode("enc", cipher_input[0])
			input_split = cipher_input[0].split(char(40001))
			//if input_split.len <= 1 then return "code: invalid format for MC decode"
			ci_sli_dex = cipher_input[0].split(char(40001))[1]
			ci_sli_txt = cipher_input[0].split(char(40001))[0]
			cipher_size = ci_sli_dex.values
			cipher_size = cipher_size.pop
			cipher_size = cipher_size.code
			ci_sli_txt = ci_sli_txt.values
			spaces = []
			last_space = 0
			for dex in ci_sli_dex
				spaces.push(dex.code+last_space+1)
				last_space = spaces[-1]
			end for
			buf = []
			//print("debug:<b>indexed</b>"+char(10)+"debug:spacing")
			spaces.pop
			for ci in range(0, cipher_size)
				//print("debug: ci = "+ci)
				if spaces.len and spaces[0] == ci+1 then
					buf.push(char(32))
					spaces.pull
				else
					if ci_sli_txt.len then buf.push(ci_sli_txt.pull)
				end if
			end for
			buf = buf.join("")
			//print(buf)
			cipher_input = buf.split(char(32))
		end if

		//////////////////////////////////////
		for password in cipher_input
		  cipher_this = password
		  for l in range(0,cipher_this.len)
		    //print(cipher_this)
		    cipher_this = Encode( enc_dec, cipher_this )
		  end for
		  cipher_output.push(cipher_this)
		end for
		//print("debug: output: "+cipher_output)
		//////////////////////////////////////
		if enc_dec == "enc" then
			spacedex = ""
			for co in cipher_output
				spacedex = spacedex + char(co.len)
			end for
			leng = cipher_output.join(" ").len
			cipher_output.push(char(40001))
			cipher_output.push(spacedex)
			cipher_output.push(char(leng))
			cipher_output.push(char(40001))
			cipher_output = cipher_output.join("")

			//cipher_output = Encode("dec", cipher_output)
		end if
		/////////////////////////////////////
		print(colorLightBlue+"<u><mark=black>= = = = = = = = = = = = = = = = = = = = = = = = = = = = =</mark></u>"+CT)
		if enc_dec == "dec" then return cipher_output.join(" ")
		return cipher_output
	end if
	if @arg1 == "-c" and arg2 then return char(arg2.to_int)
	if @arg1 == "-d" then
		if not arg2 then return "nothing to decode"
		return Encode("dec", arg2)
	end if
	if @arg1 == "-e" then
		if not arg2 then return "nothing to encode"
		return Encode("enc", arg2)
	end if
	if @arg1 == "-f" or @arg1 == "-fa" or @arg1 == "-af" or @arg1 == "-bf" or @arg1 == "-fb" then
		act = 0
		if @arg1 == "-f" then act = (-1)
		if @arg1 == "-fa" or @arg1 == "-af" then act = 1
		cipher_file = null
		cipher_text = ""
		if not arg2 then return "code: -f expects a file_path or file_object"
		if typeof(arg2) == "file" then
			if not arg2.is_binary then cipher_file = arg2 else return "code: cannot open binary file"
			if cipher_file.has_permission("r") then cipher_text = cipher_file.get_content.trim else return "code: read error. check permissions"
		end if
		if typeof(arg2) == "string" then
			cipher_text = command.cat(arg2)
		end if
		if act < 0 then act = user_input("[0] decode [<b>1</b>] encode ||: ",0,1).to_int
		if act == 0 then act = "-b" else act = "-a"
		return command.code(act, cipher_text)
	end if
	if DEBUG then print("Checking types...")
	buf = []
	if typeof(@arg1) == "string" then
		print("<mark=yellow><size=75%>Processing string...</mark></size>")
		if arg1 == "\n" then return str(char(10).code)
		if arg1 == 0 or arg1 == " " then return str(" ".code)
		arg1 = arg1.values
		for letter in arg1
			buf.push(letter.code)
		end for
		if DEBUG then print "debug: code: string buf: "+buf
		return buf.join(", ")
	end if
	//if typeof(@@arg1) == "function" then return globals.decompiler(@@arg1)
	if typeof(@arg1) == "shell" or typeof(@arg1) == "ftpshell" or typeof(@arg1) == "file" or typeof(@arg1) == "computer" or typeof(@arg1) == "map" or typeof(@arg1) == "custom_object" or typeof(@arg1) == "list" then return globals.decompiler(@arg1)
	if typeof(@arg1) == "pshell" or typeof(@arg1) == "pcomputer" or typeof(@arg1) == "pfile" or typeof(@arg1) == "prouter" then return globals.decompiler(@arg1)
	if @arg1.hasIndex("__isa") then return globals.decompiler(@arg1)
	//if typeof(@arg1) == "list" or "map" then return globals.decompiler(@arg1)	
	check = new @arg1 
	if typeof(@check) == "map" then return globals.decompiler(@arg1)
	return "code: unkown type"
end function
command.md5 = function(arg1, arg2, arg3=0, arg4=0)
	if not arg1 or arg1 == "help" or arg1 == "-h" then return "MD5SUM || md5 sum || password hash decipher || encode"+char(10)+"Usage: md5 [string] -- returns the md5sum of a string"+char(10)+"Usage: md5 -d [32_char_hash] -- checks hash against onboard dictionary then attempts decipher"+char(10)+"-- defaults to crypto.so if cerebrum is not loaded"+char(10)+"-- one of three main ways to decipher password hash combo's"+char(10)+"-- see also: <b>gopher</b>, <b>hashim</b>, <b>brutus</b>"
	if arg1 == "-d" then
		if not arg2 or typeof(arg2) != "string" or arg2.len != 32 then
			return "[-d] expects 32 character hash string"
		else
			for d in dict_a
				if md5(d) == arg2 then
					print("md5: found: ["+colorWhite+" "+d+CT+" : "+colorGold+arg2+CT+" ]")
					return d
				end if
			end for
			print "gopher: hash not in dictionary"+char(10)+"-- defaulting to crypto.so"
			if crypto then
				rslt = crypto.decipher(arg2)
				if rslt then return rslt
			else 
				print "md5: cryto.so library is not loaded"
			end if
			return "md5: hash not found"
		end if
	end if
	if typeof(arg1) == "string" then return md5(arg1) else return "md5: string required"
end function
command.pipe = function(arg1, arg2, arg3=0, arg4=0)
	return "pipe usage: place | between sets of commands to pipe output of command on left of | to command on right."+char(10)+"Max string size is 1 million characters."+char(10)+"Examples: "+char(10)+"lanpro | enum"+char(10)+"ls -la /root | clipb | enum | poke file.txt | lock |  | clipb | append file.txt"+char(10)+"chain commands and use two empty spaces between the | to <b>drop</b> piped output while continuing the chain."+char(10)+"-- eg: command1 |  | command2 -- output from command1 is NOT passed to command 2"+char(10)+"-- remember: it is two spaces between the bars."
end function
command.do = function(arg1, arg2=0, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then
		if arg2 == "extra" then
			return "<u><mark=red>=============</u></mark>"+char(10)+
			"Setup (copy after the |> and paste into 5hell): "+char(10)+
			"|> clipa 0 | rnip 11 | enum | enum -s | do"+char(10)+
			"Paste this Script : "+char(10)+
			"clipa | enum | probe"+char(10)+
			"calc @a + 1 | clipa"+char(10)+
			"Result:"+char(10)+
			"set clipa to 0, produce 11 random ips, enumerate those ips, do 11 loops of: probe enum[clipa], clipa++"+char(10)+
			"-- this runs probe on 11 random ips stored in the enum(eration) buffer using calc and the clipboard to iterate through the list."+char(10)+
			"<u><mark=red>=============</u></mark>"+char(10)+
			"Setup (copy after the |> and paste into 5hell)"+char(10)+
			"|> clipa 1 | ls -a /lib | enum | enum -s | do"+char(10)+
			"Paste this Script : "+char(10)+
			"clipa | enum | db -l"+char(10)+
			"calc @a + 1 | clipa"+char(10)+
			"Result:"+char(10)+
			"set clipa to 1, enumerate files in /lib, do [num_files+1] loops, start at 1 and run db (databaser) on each file, the error at the end is because ls returns with an extra blank line which gets enumerated at position [0] resulting in the loop being 1 over."+char(10)+
			"<u><mark=red>=============</u></mark>"+char(10)+
			"(all commands are valid but note interactive commands will still require interaction)"
		else
			return colorGold+"<u>DO || SCRIPTING || AUTOMATION || NOT BASH || BATCH COMMANDS || DORC || BASHRC"+char(10)+
			colorWhite+"</b>The scheduling or automation service for 5hell. You write a set of"+char(10)+
			colorWhite+"</b>commands for 5hell to <b>do</b>. Commands may be entered in-line on the"+char(10)+
			colorWhite+"</b>command line, entered into a text editor buffer, or read from a text file."+char(10)+
			colorWhite+"</b>see also: do help extra -- for some example do scripts"+char(10)+
			colorGold+"</b>-- see also: <b>help prompt</b>, <b>dig -h</b>, <b>scribus -h</b>"+char(10)+
			colorWhite+"</b>Do may be launched in a number of ways, depending on your goals:"+char(10)+char(10)+
			colorCyan+"Usage: do [int] [command] [arg1] [arg2]-- perform [command] [int] times"+char(10)+
			colorLightBlue+"</b>-- passes arg1 and arg2 to the command"+char(10)+
			colorLightBlue+"</b>-- use text blocks to pass complex arguments and/or complex commands"+char(10)+
			colorGold+"</b>-- eg: |><b> do 3 "" rnip 1 | probe | db -r | zap "" "+char(10)+
			colorGold+"</b>-- eg: |><b> do 1 poke test.txt "" this is a bunch of text "" "+char(10)+
			colorLightBlue+"</b>---- note: in practice the above line can be done without the <b>do 1</b>"+char(10)+
			colorLightBlue+"</b>---- it's just an example of how you would supply complex parameters to <b>do</b>"+char(10)+
			colorLightBlue+"- - - - - - - - - - - "+char(10)+
			colorCyan+"Usage: do -- without arguments will prompt for iterations then open the editor"+char(10)+
			colorCyan+"Usage: do [#] -- supplying iteration without a command opens the editor immediately"+char(10)+
			colorLightBlue+"</b>-- enter commands into the editor and enter @ on a newline to begin execution"+char(10)+
			colorLightBlue+"</b>-- the commands in the editor remain until changed and therefore may be rerun/reused"+char(10)+
			colorLightBlue+"</b>-- you may use <b>scribus @do</b> to edit the <b>do</b> buffer without firing the script"+char(10)+char(10)+
			colorCyan+"Usage: do [int] -f [/path] -- perform commands in [/path] [int] times"+char(10)+
			colorLightBlue+"</b>-- the preferred method of firing a 'batch' of commands"+char(10)+
			colorLightBlue+"</b>-- many examples may use a .bat extension but the .bat extension is not enforced at all"+char(10)+
			colorLightBlue+"</b>-- it is just a convention, you may name them whatever you wish except:"+char(10)+
			colorLightBlue+"</b>---- dig.bat must be named dig.bat in order for <b>dig</b> to use it (see dig -h)"+char(10)+
			colorGold+"</b>-- nested calls to the do command within these files are valid and encouraged"+char(10)+
			colorGold+"</b>---- dig.bat: cerebrum | brutus | run /home/guest/rkit/5hell "" do 1 -f file2.bat "" "+char(10)+
			colorGold+"</b>---- file2.bat: rshell @home | sc -d | exit rshell_placed"+char(10)+
			colorLightBlue+"</b>-- by placing these two files in your rkit folder and running <b>dig [ip]</b> you are able to:"+char(10)+
			colorLightBlue+"</b>---- automate: infiltrating and placing a root rshell on the target"+char(10)+
			colorLightBlue+"</b>----- removing your rkit"+char(10)+
			colorLightBlue+"</b>----- and cleaning the log"+char(10)+
			colorCyan+"Alias: "+colorWhite+"do 1 -f [path]"+CT+" has been aliased to"+colorWhite+" bat [path]"+CT+" in 5hell.src"+char(10)+char(10)+
			colorCyan+"You may launch 5hell from the game's command line with a 'do' instruction:"+char(10)+
			colorLightBlue+"</b>-- instead of launching 5hell simply by typing '5hell' you may launch with:"+char(10)+
			colorGold+"</b>----# 5hell do [#] [opt:-f] [command|path]"+char(10)+
			colorLightBlue+"</b>-- and 5hell will launch and immediately begin running the given commands"+char(10)+
			colorLightBlue+"</b>-- 5hell will then drop to the exit prompt;"+char(10)+
			colorLightBlue+"</b>---- press 'y' if you wish to exit, press enter or any other key to continue running"+char(10)+
			colorGold+"This allows 5hell to launch 5hell with instructions to launch 5hell with instructions to..."+char(10)+
			colorLightBlue+"</b>-- keep in mind there is a game limit of 15 <u>nested</u> uses of shell.launch"+char(10)+
			colorLightBlue+"</b>-- but no limit to the number of uses of shell.launch; meaning <b>do 1000 dig -s</b> is completely valid"+char(10)+
			colorGold+"Advanced: Resource Configuration"+char(10)+
			colorCyan+"You may place a file named "+colorWhite+"do.rc</color> in your "+colorWhite+"rkit</color> and/or "+colorWhite+"Config folder"+char(10)+
			colorLightBlue+"</b>-- the contents of the file should look like a standard <b>do</b> script and will be executed on launch"+char(10)+
			colorLightBlue+"</b>-- unlike launching with <b>5hell do 1 -f do.rc</b>, this method will not exit on completion"+char(10)+
			colorLightBlue+"</b>-- do.rc in <b>Config</b> will take priority over do.rc in <b>rkit</b>. This allows a 'home' and 'away' do.rc"+char(10)+
			char(10)+
			colorCyan+"Early Termination:"+char(10)+
			colorLightBlue+"</b>If the final return value of a line in a do script is: <b>@STOP</b>, then:"+char(10)+
			colorLightBlue+"</b>-- that iteration will cease, and the next iteration will begin"+char(10)+
			"----: equivalent to a <b>continue</b>"+char(10)+
			colorLightBlue+"</b>If the final return value of a line in a do script is: <b>@RETURN</b>, then:"+char(10)+
			"-- the do script will terminate; no further iterations will run"+char(10)+
			"----: equivalent to a <b>break</b>"+char(10)+
			colorGreen+"See Also: macro -h, help conventions, help alias"
		end if
	end if
	iter = 0
	cmd = []
	if arg1 then
		if typeof(arg1) == "number" then iter = arg1 else iter = arg1.to_int
	else
		iter = user_input("Number of iterations to run command:"+char(10)+":> ").to_int
	end if
	if not iter or typeof(iter) != "number" then return "do: invalid iteration."
	if arg2 and arg2 != "" then
		if arg2 == "-f" then
			cmd.push(arg2)
		else
			if arg3 then arg2 = arg2 + " " + arg3
			if arg4 then arg2 = arg2 + " " + arg4
			cmd.push(arg2)
		end if
	else
		print("Configure command list: ")
		print("* piped commands go on a single line separated by | ")
		print("* non-piped commands go on a new line ")
		print("* @ on newline to save and execute")
		print("* @@ on newline to abort and quit")
		cmd_hold = command.scribus("@do")
		if cmd_hold then cmd = cmd_hold.split(char(10)) else return "aborting..."
		//print(cmd.join(char(10)))
	end if
	if cmd[0] == "-f" then
		if arg3 then
			cf = globals.get_file(arg3)
			if not cf then return "do: file: "+arg3+" not found"
			if cf.is_binary then return "do: cannot open binary file"
			if not cf.has_permission("r") then return "do: can't read "+arg3+": permission denied"
			cmd = cf.get_content.split(char(10))
		else
			return "do: input error: -f expects a file path"
		end if
	end if
	time_s = time
	if DEBUG then print(cmd)
	if cmd.len then
		for i in range(1,iter)
			//print(colorBlack+"*"+CT)
			for c in cmd
				// experimental
				if c == globals.SAFEWORD then break // ick
				c = c + " | return"
				r = command.shell(c)
				if r == "@STOP" then break
				if r == "@RETURN" then return
			end for
		end for
	else
		return "<b>aborting...</b>"
	end if
	return colorCyan+"<size=50%>do: batch complete in [</size><size=75%>"+colorOrange+(time-time_s)+colorCyan+"</size><size=50%>] seconds"+CT
end function
command.cc = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return ": carbon copy: command buffer."+char(10)+"Usage: cc -- select command from history."+char(10)+"Usage: cc [#] -- where # corresponds to the command you wish to run from the command buffer."+char(10)+"-- will <b>return</b> the output of the commands as if they were run normally."+char(10)+"-- you may use cc inside of pipe chains."+char(10)+"---- e.g: cc 22 | echo | cc 10 | poke file.txt"
	i = 0
	schtick = "| return"
	if not arg1 then 
		for ccom in globals.command_buffer
			print("["+colorWhite+i+CT+"] "+char(187)+" "+ccom)
			i = i + 1
		end for
	end if
	do = null
	if arg1 then do = arg1.to_int
	if not do then do = user_input("cc:> ",0,0).to_int
	if typeof(do) == "number" and do >= 0 and do < globals.command_buffer.len then
		carbon = globals.command_buffer[do]
		carbon = carbon +" "+ schtick
		//carbon = carbon.split(" ")
		return command.shell( carbon )
	else
		return "cc: invalid index"	
	end if
	return 0
end function
command.time = function(arg1, arg2=0, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "Usage: time -- returns current game time."+char(10)+"Usage: time [-d|date] -- returns current game time and date."+char(10)+"Usage: time [-t] -- returns time in seconds since script launch."
	if arg1 == "-t" then return time
	if arg1 == "-d" or arg1 == "date" then return current_date
	return current_date.split(" ")[2]
end function
command.pause = function(arg1=0, arg2=0, arg3=0, arg4=0)
	if not arg1 or arg1 == "0" or arg1 == "help" or arg1 == "-h" then return "Pause || Wait || Hang || Sleep"+char(10)+
	// note, this function expects time as a string, the user should form the string as a float. eg: pause .01 -- where .01 is a string
	"Usage: pause [seconds(float)] -- pauses script execution"+char(10)+
	"-- Minumum time: .01 seconds"+char(10)+
	"-- Maximum time: 300 seconds"+char(10)+
	"-- useful for putting a delay in 'do' scripts."+char(10)+
	"-- useful for putting a delay in a chain of commands"+char(10)+
	"-- this command uses the general function: wait(time)"+char(10)+
	"Usage: pause [-v] [delay] -- as above but prints a notification at each pause"+char(10)+
	"Usage: pause [-m] -- pause until manually unpaused (by pressing enter)"

	time_to_wait = "1" // default wait 1 second 
	manual_unpause = false // if false the chain of commands continues after the pause, if true then press a key to continue
	verbose = false // if false; works silently. if true; prints a line on each pause
	if arg1 == "-m" then 
		manual_unpause = true 
		arg1 = ".01"
	end if
	if arg1 == "-v" then 
		verbose = true 
		arg1 = arg2 
	end if
	if DEBUG then print "debug: in pause: arg 1 is: "+arg1+" and manual pause is: "+manual_unpause
	if typeof(arg1.val) == "number" then time_to_wait = arg1.val else return "pause: invalid interval: expects positive float [.01 : 300]"+char(10)+"n.b. - negative values will not reverse time"
	if manual_unpause then return user_input(colorWhite+"pause</b>: script execution paused"+char(10)+"-- press <"+colorGreen+"enter"+CT+"> to continue --")
	if time_to_wait <= 300 and time_to_wait >= .01 then
		if DEBUG then print "debug: ttw is"+time_to_wait
	else
		time_to_wait = 1
		print "pause: invalid wait time: changing time_to_wait to 1 second"
	end if
	if verbose then print colorWhite+"<u>pause</b>: script execution paused for <b>"+time_to_wait+"</b> seconds..."
	wait(time_to_wait)
	if verbose then return colorWhite+"pause:"+CT+" resuming script execution"
	return 0
end function
command.bios = function(arg1=0, arg2=0, arg3=0, arg4=0)
if arg1 == "help" or arg1 == "-h" then return "OBJECT | MEMORY | BIOS | CERBIOS"+char(10)+
"Usage: bios -- system info"+char(10)+
"Advanced:copy the following to 5hell's command line:"+char(10)+
"<b>mkdir /virt | poke /virt/hdd.io dev_sda:SIZE </b>"+char(10)+
"-- replace SIZE with the maximum size of your hdd in bytes. "+char(10)+
"-- this lets bios report the remaining hdd space"+char(10)+
"Usage: bios -a -- return the currently loaded <color=#FFD000>aptclientlib object"+char(10)+
"Usage: bios -m -- return the currently linked <color=#13E6CA>metaLib object"+char(10)+
"Usage: bios -x -- return the currently loaded <color=#FF0800>metaxploitLib object"+char(10)+
"Usage: bios -c -- return the currently loaded <color=#8C00FF>crypto object"+char(10)+
"Usage: bios -n -- return the currently linked <color=#0011FF>netsession object"+char(10)+
"Usage: bios -p -- return the currently loaded <color=#69E488>port_map object as a string"+char(10)+
"Usage: bios -H -- return the currently linked <color=#E4EE58>herme5 meta.mail object"+char(10)+
"-- returns null if not logged in to a mail account"+char(10)+
"Usage: bios -s -- return the currently loaded <color=#8B8568>meta_scan information</color> as a string"+char(10)+
"Usage: bios -P -- return the currently loaded <color=#00FF40>port_map object as a map"+char(10)+
"Usage: bios -X -- return the currently loaded <color=#065F0D>XPLOITS as a list"+char(10)+
"Usage: bios -M -- return the current <color=#FF00C8>MEMORY object or null"+char(10)+
"Usage: bios -B -- return the global <color=#E68A13>BUFFER as a list"+char(10)+
"Usage: bios -r [opt: ip] -- return the <b>local<b> <color=#71858D>router object</color> [opt:ip]"+char(10)+
"Usage: bios -i [path] -- runs <b>include_lib</b> on path and returns result"+char(10)+
"-- init.so, net.so, kernel_module.so cannot be imported as they lack an API"+char(10)+
"-- prompts for path if path not supplied"+char(10)+
"---- e.g.|> bios -i /lib/blockchain.so | malp "+char(10)+
"---- returns the blockchainLib object and pipes it to malp (to the BUFFER)"+char(10)+
"---- note: cannot include_lib net.so, init.so, kernel_module.so"+char(10)+
"------ only libs with API's may use include_lib"+char(10)+
"------ use meta link to load those with the metaxploitLib"+char(10)+
"Usage: bios --stack -- return the global stack_pool value (as a string numeral)"
if arg1 == "--stack" then return str(globals.stack_pool)
if arg1 == "-a" then return globals.apt_get 
if arg1 == "-x" then return globals.metaxploit 
if arg1 == "-c" then return globals.crypto 
if arg1 == "-n" then return globals.net_session
if arg1 == "-p" then return globals.display_portmap(1)
if arg1 == "-P" then return globals.PORT_MAP
if arg1 == "-H" then return globals.inbox
if arg1 == "-m" then return globals.metaLib
if arg1 == "-s" then return globals.meta_scan
if arg1 == "-X" then return globals.XPLOITS 
if arg1 == "-M" then return globals.MEMORY
if arg1 == "-B" then return globals.BUFFER
if arg1 == "-r" then 
	if arg2 then
		if is_valid_ip(arg2) then return get_router(arg2)
		return "bios: get_router: invalid ip"
	else 
		return get_router
	end if
end if
if arg1 == "-i" then 
	if not arg2 then 
		arg2 = user_input("Enter path to file.so :> ")
	end if
	tf = globals.get_file(arg2)
	if not tf then return "bios: "+colorRed+"</b>target file not found!"
	inc = include_lib(arg2)
	if not inc then return "bios: "+colorRed+"</b>include_lib failed:"+char(10)+"-- target file does not have an API"+char(10)+colorGreen+"kore: helper:</b> perhaps try<b> meta link -l [libname] </b>instead"+char(10)+"-- if you meant metax.load("+arg2+")" else return inc
end if

bios_info = []
bios_info.push("<mark=red><u>=======================================================================</u></mark>")
bios_info.push("<u><mark=red>=</mark><color=red>__(WIP)________________cer_bios_v_0.6_by_Plu70________________(WIP)__</color><mark=red>=</mark></u>")
bios_info.push("* "+current_date+" "+globals.localmachine.local_ip+" @ "+globals.localmachine.public_ip+" up: "+time)
procs = globals.localmachine.show_procs.split(char(10))
//print(procs)
root_procs = 0
user_procs = 0
guest_procs = 0
mem_used = 0
cpu_used = 0
for p in procs
	spl = p.split(" ")
	pro_usr = spl[0]
	pro_idn = spl[1]
	pro_cpu = spl[2].remove("%")
	pro_mem = spl[3].remove("%")
	pro_nam = spl[4]
	if pro_cpu != "CPU" then cpu_used = cpu_used + pro_cpu.val
	if pro_mem != "MEM" then mem_used = mem_used + pro_mem.val
	if pro_usr == "root" then
		root_procs = root_procs + 1
	else
		if pro_usr == "guest" then
			guest_procs = guest_procs + 1
		else
			if pro_usr != "USER" then user_procs = user_procs + 1
		end if
	end if
end for
root = localmachine.File("/")
hdd_io = localmachine.File("/virt/hdd.io")
h_size = "<color=red>dev_sda error</color>"
if hdd_io then
	h_c = hdd_io.get_content.split(char(10))
	h_s = h_c[0].split(":")
	h_n = 0
	if h_s.len > 1 then h_n = h_s[1].val
	if h_n then h_size = h_n - root.size.val else h_size = "<color=red>dev_sda error</color>"
end if
if globals.stack_pool >= 15 then stack_print = "depleted; restart required" else stack_print = globals.stack_pool
bios_info.push("<mark=red><size=85%>|</size></mark>")
bios_info.push("<size=85%>Macula Registry: [stack_pool:"+colorRed+stack_print+CT+"] </size>")
bios_info.push("<size=85%>root_procs [<b>"+root_procs+"</b>] user_procs [<b>"+user_procs+"</b>]  guest_procs [<b>"+guest_procs+"</b>] t:<b> "+(procs.len-1)+"</b></size>")
bios_info.push("<size=85%>cpu_usage: ["+cpu_used+"%] mem_usage: ["+mem_used+"%] temp: <color=red>therm_io not found</color></size>")
bios_info.push("<size=85%>[cpu:<mark=green>|"+"|"*(cpu_used/4)+"</mark>"+"_"*((100-cpu_used)/4)+"]   [ram:<mark=green>"+"|"*(mem_used/4+1)+"</mark>"+"_"*((100-mem_used)/4)+"]</size>")
bios_info.push("<size=85%>[hdd_used: <b>"+root.size+" </b>bytes]  [hdd_free: "+h_size+" bytes]</size>")
allfiles = command.tree("-r","/")
folds = 0
bins = 0
txts = 0
tot = 0
for f in allfiles
	if f.is_folder then 
		folds = folds + 1
	else if f.is_binary then 
		bins = bins + 1
	else
		txts = txts + 1
	end if
end for
tot = folds + bins + txts
bios_info.push("<size=85%>num_folders ["+folds+"] num_binaries ["+bins+"] num_ascii ["+txts+"] tot: ["+tot+"]</size>")
ess = "-wifi disabled-"
if localmachine.active_net_card == "WIFI" then
	//sig = floor(rnd*99)+1
	//sig = sig - 0
	sig = 0
	nets = localmachine.wifi_networks("wlan0") // list
	ess = get_router.essid_name
	_get_wifi = function(networks)
		for net in networks 
			n = net.split(" ")
			if DEBUG then print "debug: n is: "+n+" and n[1] is: "+n[2]
			if ess == n[2] then
				sig = n[1].replace("%","")
				sig = sig.to_int
				if DEBUG then print "debug: sig strength is: "+sig+"%"
				return sig 
			end if
		end for
		return 0
	end function
	sig = _get_wifi(nets)
	sig_not = 100 - sig
	bios_info.push("<size=85%>[wifi_signal:<mark=green>|"+"|"*(sig/2)+"</mark>"+"_"*(sig_not/2)+"]</size>")
end if
dl = localmachine.network_devices.split(char(10))
bios_info.push("<size=85%>["+dl.join("] [")+localmachine.active_net_card+"] ["+ess+"]")
ports = localmachine.get_ports
pl = []
for p in ports
	pl.push(p.port_number)
end for
bios_info.push("<size=85%>ports: ["+pl.join("] [")+"] </size>")
bios_info.push("<mark=red><size=50%>|</size></mark>")
if DEBUG then print "debug: bios searching for database..."
database = command.tree("/","database.csv",1,"N")
data_lines = "--"
data_size = "-not_found-"
if database then
	if DEBUG then print "-- found database.csv: "+database.path
	data_size = command.file("-c",database)
	if database.has_permission("r") then data_lines = command.file("-l",database) else data_lines = "-check_perms-"
	if data_size.to_int > "150000".to_int then data_size = colorOrange+"Warning: "+data_size+CT
end if
bios_info.push("<size=85%>[database_size:"+data_size+"]  [database_lines:"+data_lines+"]</size>")
bios_info.push("<size=85%>[BUFFER: "+globals.BUFFER.len+" objects]</size>" )
bios_info.push("<size=85%>[Custom_Object: "+get_custom_object.len+" indexes]")
bios_info.push("<size=85%>[tagged4scp: "+globals.tagged_for_scp+"]</size>")
bios_info.push("[tbuf:<size=60%>"+globals.T_BUF.join(" ")+"</size>]</size>")
//bios_info.push("[clipa:<size=60%>"+@globals.clip_board_alpha+"</size>]"+char(10)+"[clipb:<size=60%>"+@globals.clip_board_beta+"</size>]"+char(10)+"[clipc:<size=60%>"+@globals.clip_board_gamma+"</size>]"+char(10)+"[enum:<size=60%>"+globals.enumerated.len+"</size>]")
if typeof(@globals.clip_board_alpha) == "string" then
	bios_info.push("[clipa:<size=60%>"+@globals.clip_board_alpha.replace(char(10),", ")+"</size>]")
else
	bios_info.push("[clipa:<size=60%>"+@globals.clip_board_alpha+"</size>]")
end if
if typeof(@globals.clip_board_beta) == "string" then
	bios_info.push("[clipb:<size=60%>"+@globals.clip_board_beta.replace(char(10),", ")+"</size>]")
else
	bios_info.push("[clipb:<size=60%>"+@globals.clip_board_beta+"</size>]")
end if
if typeof(@globals.clip_board_gamma) == "string" then
	bios_info.push("[clipc:<size=60%>"+@globals.clip_board_gamma.replace(char(10),", ")+"</size>]")
else
	bios_info.push("[clipc:<size=60%>"+@globals.clip_board_gamma+"</size>]")
end if
mscan = "-none-"
if globals.meta_scan then mscan = "ready"
bios_info.push("<size=85%>[portmap:"+globals.PORT_MAP.len+"] [xploits: "+globals.NUM_SPLOITS+"] [metascan: ]</size>")
bios_info.push("<size=85%>[dict_a:"+colorGold+globals.dict_a.len+CT+"]  [dict_size: "+dict_a.join(", ").len+"]</size>")
bios_info.push("<mark=red><size=50%>|</size></mark>")
score = 10
pwf = command.tree("/etc","passwd",1,"N")
if pwf then 
	pwf = pwf.permissions 
	score = score - 1
else 
	pwf = "--null--"
end if
bff = command.tree("/","Bank.txt",1,"N")
if bff then
	bff = bff.parent.path 
	score = score - 1
else 
	bff = "--null--"
end if
mtf = command.tree("/","Mail.txt",1,"N")
if mtf then 
	mtf = mtf.parent.path 
	score = score - 1
else 
	mtf = "--null--"
end if
mcf = command.tree("/","Map.conf",1,"N")
if mcf then 
	mcf = mcf.parent.path 
	score = score - 1
else 
	mcf = "--null--"
end if
bcf = command.tree("/","Browser.txt",1,"N")
if bcf then 
	bcf = bcf.parent.path 
	score = score - 1
else 
	bcf = "--null--"
end if
clf = command.tree("/","ConfigLan.conf",1,"N")
if clf then 
	clf = clf.parent.path 
	score = score - 1
else 
	clf = "--null--"
end if
unsec_files = 0
unsec_dirs = 0
for file in allfiles
	fp = file.permissions.values 
	if fp[-1] != "-" or fp[-2] != "-" or fp[-3] != "-" then 
		if file.is_folder then unsec_dirs = unsec_dirs + 1 else unsec_files = unsec_files + 1
	end if	
end for
if unsec_files then score = score - 1
if unsec_dirs then score = score - 1
log = localmachine.File("/var/system.log")
log_size = 0
log_is_binary = 0
log_permissions = "-log-missing-"
if log then
	log_size = log.size
	log_is_binary = log.is_binary
	log_permissions = log.permissions
end if
log_ps = log_permissions.values
if log_ps[-2] != "-" or log_ps[-3] != "-" then score = score - 1
if score == 10 then 
	score = colorGreen+str(score) 
	else if score < 2 then 
		score = colorRed+str(score)
	else 
		score = colorOrange+str(score)
end if
bios_info.push("<size=85%>Security Audit Score: "+score+"/10</size>")
bios_info.push("<size=60%>[unsecured_files:"+unsec_files+"]  [unsecured_directories: "+unsec_dirs+" ]</size>")
bios_info.push("<size=60%>[/etc/passwd:"+pwf+"] [Mail.txt:"+mtf+"] [Bank.txt:"+bff+"]</size>")
bios_info.push("<size=60%>[Map.conf:"+mcf+"] [Browser.txt:"+bcf+"] [ConfigLan.conf:"+clf+"]</size>")
//bios_info.push("<size=60%>[services:                   ]</size>")
bios_info.push("<mark=red><size=50%>|</size></mark>")


bios_info.push("<size=85%>[/var/system.log: "+log_size+" bytes || is_binary: "+log_is_binary+" || perms: "+log_permissions+" ]")
bios_info.push("<mark=red><size=50%>|</size></mark>")
bios_info.push("*<size=50%> (obvious stub needs obvious improvement)</size>")
bios_info.push("*<size=50%> see <b>bios -h</b> for additional usage info.")
bios_info.push("<mark=red><u>=======================================================================</u></mark>")

return bios_info.join(char(10))
end function
command.cname = function(arg1,arg2,arg3,arg4)
	if arg1 == "help" or arg1 == "-h" then return "Usage: cname -- returns the name of the currently active computer_object"
	return localmachine.get_name
end function
command.whoami = function(arg1,arg2,arg3,arg4)
	if arg1 == "help" or arg1 == "-h" then return "WHOAMI || current user || active user || new user, who dis?"+char(10)+
	"Usage: whoami -- returns the active_user"+char(10)+
	"-- if GLASSPOOL is active; returns best guess at active user"
	if GLASSPOOL then return checkUser(localmachine) else return active_user
end function
command.credits = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "credits"
	logo = []
	logo.push("  |-----\ "+CT+colorWhite+"   |      |   /--------   |          |         ")
	logo.push("  |     | "+CT+colorWhite+"   |      |   |           |          |         ")
	logo.push("  |       "+CT+colorWhite+"   |      |   |           |          |         ")
	logo.push("  |____   "+CT+colorWhite+"   | _____|   |--------   |          |         ")
	logo.push("       |  "+CT+colorWhite+"   |      |   |           |          |         ")
	logo.push("       |  "+CT+colorWhite+"   |      |   |           |          |         ")
	logo.push(" |     |  "+CT+colorWhite+"   |      |   |           |          |         ")
	logo.push(" \ ____|  "+CT+colorWhite+"   |      |   \--------    \_______   \_______ "+char(8482))
	for l in logo
		print(colorRed+l+CT)
	end for
	print("by Plu70 aka jhook, aka ra'al")
	print("special thanks to: KuRouZu")
	print("MuninCipher by:"+colorWhite+" Plu70, CypherRaven"+CT)
	print("CheckUser function by: "+colorWhite+"Corvus"+CT)
	print("Blackjack card art by: "+colorWhite+"3nigma"+CT)
	print("Pwgen by : "+colorWhite+" UsesPython, additions by Plu70 "+CT)
	print("Additional code contributions by: Clover, redit0, muhahahahe")
	print("Github Readme by: Hikaru918")
	print("5hell Discord by: Redit0")
	print("5hell.src optimizations by: Clover")
	print("beta testing by: "+colorWhite+"CypherRaven, Deckard, KotyKD, Silent, Wulf, Amanda, Sabranan ")
	print("Inspiration from: "+char(10)+colorWhite+"AweTux, Kirin, Rasputin, CypherRaven, 3nigma, muhahahahe, Sl3ekr, Lady, KotyKD, Corvus, Amanda, DHZA, Silent, Deckard, Andreno, Minidevil96, tyy, Sabranan, MrMember, Clover, Rocketorbit, Trashed, Bit, OmegaKawaii, Hikaru918, Xagic, Omega, Redit0, Eclipse00, Jessa, Forteyn, Nyx "+char(10)+"and many others!")
	return 0
end function
command.quit = function(state=1, arg2=0, arg3=0, arg4=0) // NOT reboot command, rather ends script
	if state == "help" or state == "-h" then return "<u>QUIT || EXIT || RETURN</u>"+char(10)+"Usage: quit [opt:state] -- exits the program."+char(10)+"-- if no optional state then prompts before exit"+char(10)+"-- if state supplied then skips confirmation and exits with state"+char(10)+"Usage:<b> exit [opt:state]</b> -- also exits the program with optional state"+char(10)+"Usage: return -- used to return from glasspool. Will exit 5hell if glasspool is inactive."
	did = false
	if params and params[0] == "do" then did = true
	if not state or did then 
		if not state then 
			if user_input("Exit "+colorRed+"5hell"+char(8482)+CT+"? [y/N]"+char(10)+"||: ",0,1).lower != "y" then return "aborting shutdown..."
		end if
	end if
	exit(state)
end function
command.help = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "helping..."
	if arg1 == "shell" then return (colorRed+instance.name+CT+" v "+ver+" by Plu70"+char(10)+"(type<b> shell </b> for more info.)")
	if arg1 == "guide" then
		print(colorGold+"<u>= = = = = = = = = = = = = =</u>"+CT)
		print("Quick start guide: (5hell command line: |> )")
		print(colorGold+"probe [ip]"+CT+" -- perform a whois and portscan on target ip. Sets target IP in 5phinx/sphinx.")
		print(colorGold+"sphinx"+CT+" -- bring up pentest tool with target already set."+char(10)+
		"-- Press [0] to view portmap, [4] to change target ip, [5] to set target port.")
		print("Use arrow keys to access other 5phinx menus.")
		print("in sphinx "+colorGold+"press [=]"+CT+" -- connect metalib and get net_session (or load local lib)")
		print("in sphinx "+colorGold+"press [3]"+CT+" -- if target lib is unknown (scan/add to dbase)")
		print("in sphinx "+colorGold+"press [a] or [2]"+CT+" -- single attack or attack with all. results are stored in the BUFFER.")
		print("access "+colorGold+"malp"+CT+" -- memory alpha, (left arrow from sphinx or malp from |> )")
		print("in malp "+colorGold+"press [5]"+CT+" for BUFFER objects.")
		print("the BUFFER in <b>malp</b> is where you will interact with most objects.")
		print("use "+colorGold+" scpm "+CT+"command from |> or select a shell in BUFFER and press [7] scp to upload rkit ")
		print("do this<u> before </u>activating glasspool for best results.")
		print("use "+colorGold+"felix"+CT+" -- file explorer to send files/folders to BUFFER")
		print("all other commands are utility. explore them!")
		print(colorGold+"glasspool is shell/computer mirroring. some commands may change when this is active. "+CT+char(10)+
		"N.B. when active you are on the other side of the mirror looking back.")
		print(colorGold+"*--*"+CT)
		print("<b>/root/rkit</b> is the default location of the rootkit which should consist of:"+char(10)+
		"<b>   5hell, crypto.so, metaxploit.so, database.csv </b>"+char(10)+"Additionally it may contain: "+char(10)+
		"   dig.bat, ScanLan.exe, and other tools/libs you find useful.")
		print("In most cases you may type<b> kore -r</b> to have the rkit built for you."+char(10)+
			"kore will look for 5hell in /bin, and meta and crypto in /lib."+char(10)+
				"Add these files manually if kore is unable to do so.")
		print("For scripting see:<b> do -h</b>"+char(10)+
		"For dictionary attacks see:<b> cerebrum -h, brutus -h, gopher -h, hashim -h</b>")
		print("For networking see:<b> air -h, iwlist -h, ifconfig -h, ssh -h, kraken -h</b>")
		print("For security see:<b> perms -h, usr -h, grp -h, sniff -h, silentclean -h, bios -h")
		print("For dev tools see:<b> scribus -h, makfit -h, clipb -h, make -h, chop -h, dfit -h </b>")
		print(colorGold+"*--*"+CT)
		return 0
	end if

	help_conventions = "<b>CONVENTIONS</b>"+char(10)+"While a great deal of 5hell is discordant, there are some conventions:"+char(10)+char(10)+
	"You may toggle the full prompt and minimal promt by typing: "+char(10)+
	"<b>prompt</b> at the command line"+char(10)+
	"- - - - - - - - - - "+char(10)+
	colorWhite+"Input: arguments and quote blocks and piping oh my!"+char(10)+
	"-- 5hell uses a 4 argument system. This means all commands take at most 4 arguments"+char(10)+
	"-- this might sound limiting but it isn't at all in practice. Each of the 4 arguments may be overloaded."+char(10)+
	"Some input methods are:"+char(10)+
	colorLightBlue+"----* simply typing input: |> ping 1.1.1.1"+char(10)+
	"------ up to four typed arguments"+char(10)+
	"------ remember that |> is the prompt, you don't type that part"+char(10)+
	colorLightBlue+"----* using single quotes to wrap text: |> echo "" this is a text block "" "+char(10)+
	"------ would return: this is a text block"+char(10)+
	"------ note that: |> echo ""this is a text block"" "+char(10)+
	"------ would return: """"this is a text "+char(10)+
	"------ this allows you to overload each argument with more than one ""word"""+char(10)+
	"------ easy clip and piping and objects(mostly) are preserved inside of text blocks"+char(10)+
	colorLightBlue+"----* use <color=yellow>do</b></color> to run a batch of commands from a file or from memory using an editor"+char(10)+
	"------ |> do -- without arguments do will prompt for number of iterations then open the editor"+char(10)+
	"------ |> do 1 -- would bring up an editor commands typed here will be executed in order"+char(10)+
	"------ |> do 1 ping 1.1.1.1 -- would result in pinging 1.1.1.1 once"+char(10)+
	"------ |> do 5 "" rnip 1 | dig "" -- would run dig on a random ip 5 times"+char(10)+
	"------ |> do 1 -f /foo.bar -- execute the batch of commands in the file foo.bar"+char(10)+
	"-------- you may launch 5hell from the game's command line with <b>do</b> parameters"+char(10)+
	"-------- the format is the same as if typing commands on the command line"+char(10)+
	"-------- newlines in the script are considered to be new command line entries"+char(10)+
	"-------- you may use piping, easy clip, and even calls for <b>do</b> to execute further scripts"+char(10)+
	"-------- you may use text blocks for complex commands in place of files or the editor"+char(10)+
	"--eg:  |> do 3 "" rnip 1 | dig |  | cob get metx | meta -i | db -m | zap "" | poke test.txt "" this is a bunch of text going into a file """+char(10)+
	colorGold+"** it is possible to almost completely automate every aspect of 5hell via <u>do</u> and <u>dig</u>"+char(10)+
	"------ for ease of use <b><color=white>do 1 -f</b></color> has been aliased to <color=white><b>bat</b></color> in 5hell.src:"+char(10)+
	"-------- |> <b>bat /foo.bar</b> is equivalent to |> <b>do 1 -f foo.bar</b>"+char(10)+
	"------ please see <u><b><color=yellow>do -h</b> and <b>dig -h</b></u></color> for more information on automation"+char(10)+
	colorLightBlue+"----* piping input: |> grep -f ^syst | file -p | cp /etc/passwd"+char(10)+
	"------ would result in copying /etc/passwd over top of system.log (if permissions allowed it)"+char(10)+
	"------ piping allows you to transfer the output of one command to the innput another command"+char(10)+
	"------ in the above example the output of grep [args...] is the input of file -p [input]"+char(10)+
	"------ and the output of file -p [args] is the input of cp /etc/passwd [input]"+char(10)+
	"------ please see <b>pipe -h</b> for more"+char(10)+
	"------ if malp is the backbone of 5hell, pipes are the circulatory system of 5hell"+char(10)+char(10)+
	colorWhite+"Prompts: "+CT+"|> , :> , ||: "+char(10)+
	"<color=#FFFFFF>|>  --  this is the standard Command Line Interface prompt"+char(10)+
	"-- by default there will be information printed before this"+char(10)+
	"-- toggle to a minimalist prompt with: <b>prompt</b>"+char(10)+
	"-- fires CLI commands"+char(10)+
	colorLightBlue+"|> "+CT+"  --  by default, the GLASSPOOL prompt turns the |> blue"+char(10)+
	"-- this means commands execute on the remote object controlled by glasspool"+char(10)+
	"-- see glaspool -h for more"+char(10)+
	colorWhite+":>  "+CT+" --  this is a liminal prompt, it expects a string or empty return"+char(10)+
	"-- this is used to gather user input within a command"+char(10)+
	colorWhite+"||: "+CT+" --  this is an 'any key' prompt"+char(10)+
	"-- it takes a single keypress"+char(10)+
	"-- this is used in 'button' driven menus"+char(10)+char(10)+
	colorWhite+"Decision Pompts: "+CT+"[ N/Y/X ] [n/y/x]"+char(10)+
	"-- Multiple choice prompts have a default"+char(10)+
	"-- the default is always Capitolized and sometimes highlighted"+char(10)+
	"-- the default is chosen if <enter> is pressed without input"+char(10)+
	"-- unless otherwise noted, default is chosen if input doesn't match a choice"+char(10)+
	"E.G: |> psudo"+char(10)+
	"Open shell? [c/y/N]"+char(10)+
	"||:"+char(10)+
	"-- in this example, the choices are [c], [y], and [N]"+char(10)+
	"---- [c] -- enter credentials"+char(10)+
	"---- [y] -- open shell"+char(10)+
	"---- [n] or anything else -- no; return/abort"+char(10)+
	"------ this is because N is the default"+char(10)+char(10)+
	colorWhite+"Prompt: advanced:"+char(10)+
	"-- by default the prompt will display the public and local ip of the active shell"+char(10)+
	"---- or computer if using glasspool on a computer object"+char(10)+
	"-- by default the prompt will display computer name and working directory"+char(10)+
	"-- by default the prompt indicates user privileges (root,user,guest) with:"+char(10)+
	"---- under the ip information there will be a:"+char(10)+
	"------ a<color=red> red line for root</color>, <color=green>green line for user </color>, </color>and <color=white>white line for guest"+char(10)+
	"---- please note that user permissions are determined by access level"+char(10)+
	"---- in some cases, this might not be the actual user"+char(10)+
	"-- you may customize the prompt to your liking in 5hell.src"+char(10)

	help_tools = "<u><b>Main tools:"+char(10)+
	colorCyan+"probe "+colorWhite+"-- whois and portmap a target"+char(10)+
	colorCyan+"db "+colorWhite+"-- scan target and <b>database results</b>"+char(10)+
	colorCyan+"meta "+colorWhite+"-- metaLib and metaxploitLib fine control"+char(10)+
	colorCyan+"zap "+colorWhite+"-- select and fire exploits one at a time (does not database)"+char(10)+
	colorCyan+"roil "+colorWhite+"-- fire all exploits at once (does not database)"+char(10)+
	colorCyan+"malp "+colorWhite+"-- Memory Alpha: BUFFER management"+char(10)+
	"-- exploit results and other objects go here"+char(10)+
	"-- this is arguably the backbone of 5hell"+char(10)+
	colorCyan+"scpm "+colorWhite+"-- menu and/or cli driven scp"+char(10)+
	colorCyan+"kraken "+colorWhite+"-- proxy management"+char(10)+
	colorCyan+"scribus "+colorWhite+"-- simple text editor"+char(10)+
	colorCyan+"cerebrum "+colorWhite+"-- add 325k+ passwords to custom_object.dictionary"+char(10)+
	colorCyan+"brutus "+colorWhite+"-- use custom_object.dictionary to get root on any (unmodified) npc machine"+char(10)+
	colorCyan+"See: [command] [-h|help] for more help on these and other commands"+char(10)

	help_buffer = colorOrange+"The BUFFER"+char(10)+
	colorOrange+"</b>The BUFFER stores objects. Anything may be stored in the BUFFER."+char(10)+
	colorOrange+"You access the BUFFER with the <b>malp</b> command >> option [5]"+char(10)+
	colorOrange+"</b>When an exploit is run, the result is stored in the BUFFER. You"+char(10)+
	colorOrange+"</b>may interact with these objects in a number of ways by selecting them"+char(10)+
	colorOrange+"</b>from the list and using their context menu (if the object has one)."+char(10)+
	colorOrange+"</b>One way to fetch an object from the BUFFER for use elswhere is to use the clipboard:"+char(10)+
	colorOrange+"</b>|> "+colorGreen+"clipb @B [index|-m]</color>"+colorOrange+"</b>-- where index == BUFFER[index]"+char(10)+
	colorOrange+"</b>-- then pipe the value to another function"+char(10)+
	colorOrange+"</b>Easy Clip! As of version 3.9.6 any command may take <b>@B [index|-m] as one or more parameters!"+char(10)+
	colorOrange+"</b>-- if -m is passed instead of an index, a menu is displayed"+char(10)+
	colorOrange+"</b>|> roil | scpm /root/rkit @B -m"+char(10)+
	colorOrange+"You may pipe anything into the buffer with |><b> [command_returning_input] | malp</b>"+char(10)+char(10)+
	colorGreen+"Easy Clip! You may reference the clipboards with the @ symbol:"+char(10)+
	colorGreen+"***  clipa, clipb, and clipc are all clipboard spaces  ***"+char(10)+
	colorGreen+"</b>You may use @a, @b, and @c to reference their values"+char(10)+
	colorGreen+"</b>e.g. echo hello world | clipa |  | poke hello.txt @a"+char(10)+
	colorGreen+"*** tbuf, home, do ***"+char(10)+
	colorGreen+"</b>e.g. <b>gopher @tbuf</b>, e.g. <b>rshell @home</b>, e.g <b>scribus @do"+char(10)+char(10)+
	colorCyan+"</b>The CUSTOM_OBJECT is a way for scripts to share information between"+char(10)+
	colorCyan+"</b>nested launches. This means you can launch 5hell with 5hell and pass objects back and forth."+char(10)+
	colorCyan+"</b>You interact with the custom_object via the various <b>cob</b> commands"+char(10)+
	colorCyan+"</b>Namely: cob get and cob set."+char(10)+
	colorCyan+"For ease of use: <color=white>cob get</color> and <color=white>cob set</color> have been aliased to:"+char(10)+
	colorCyan+"</b>-- <color=white>get</color> and <color=white>set</color> in 5hell.src"+char(10)+
	colorCyan+"</b>-- |> <b>cob set bob burger </b>is equivalent to |><b> set bob burger"+char(10)+
	colorCyan+"</b>-- |> <b>cob get bob</b> is quivalent to |><b> get bob"+char(10)+
	colorCyan+"</b>An example would be "+colorGold+"cerebrum</color> which loads the dictionary to the custom object."+char(10)+
	colorCyan+"</b>-- When generated, the dictionary is loaded to the custom object under the key: <b>dictionary</b>."
	colorCyan+"</b>-- Once loaded, you may <b>run</b> 5hell through nested launches and the dictionary will persist."+char(10)+
	colorCyan+"</b>-- This also allows you to import/export metaLib's and metaxploitLib's between machines!"+char(10)
	colorCyan+"</b>-- Easy Clip! You may reference a value in the custom object by it's key with: <b>@o [key]</b>"+char(10)+
	colorGold+"</b>--eg:<b> set foo "" look out for that tree, "" | echo @o foo george </b>// look out for that tree, george"+char(10)+
	colorCyan+"</b>-- Please see cob -h for more informaiton"

	help_logs = colorWhite+"The dreaded "+colorRed+"System.log"+char(10)+
	"Actions that generate an entry in system.log: "+char(10)+
	"-- establishing a net_session on a server (not a router)"+char(10)+
	"-- connecting via Browser.exe to a server"+char(10)+
	colorWhite+"---- connection established on port ##"+char(10)+
	"-- obtaining a shell (server/router)"+char(10)+
	colorWhite+"---- shell obtained on port ##"+char(10)+
	"-- deleting a file"+char(10)+
	colorWhite+"---- file deleted [ip]"+char(10)+
	"-- routing a connection with:"+char(10)+
	"-- connect_service or file_explorer"+char(10)+
	colorWhite+"---- connection routed [ip]"+char(10)+
	"-- shell disconnect"+char(10)+
	"-- i.e. exiting from start_terminal"+char(10)+
	colorWhite+"---- connection closed [ip]"+char(10)+char(10)+
	colorRed+"Active Traces"+CT+" will start when <b>shell.start_terminal</b> is used"+char(10)+
	"on an npc machine with an active admin of sufficient knowledge and give-a-damn."+char(10)+
	"Generally, if there is a root: dsession active, using start_terminal will trigger"+char(10)+
	"an active trace. Active traces are stopped by disconnecting (exiting) that terminal instance."+char(10)+char(10)+
	"When using 5hell you should NOT ever open a terminal (on a target) unless you are doing an Academic or"+char(10)+
	"Police record mission. OR if you absolutely need to open the browser to edit firewall or port rules"+char(10)+
	"on a target. Otherwise, use <b>glasspool</b> and <b>run</b> to leverage shell object manipulation instead."+char(10)+char(10)+
	"However! You <u>should</u> start_terminal on your end point attack proxy. In fact, do it twice:"+char(10)+
	"-- use <b>prox</b> to tunnel to your end point proxy then launch 5hell and type <b>psudo</b> and then select [y]"+char(10)+
	"-- this will start_terminal on top of your start_terminal, effectively looping your connection on that machine"+char(10)+
	"-- this will ensure your end point proxy's ip is left in logs, not your origin ip"+char(10)+
	"-- without this, you risk exposing ip's behind the proxy"+char(10)+
	"-- note: this means you'll have to 'exit' twice from that proxy to return home"+char(10)+
	colorRed+"Passive Traces"+CT+" can/will start when certain actions have been left unaddressed:"+char(10)+
	"- Deleting a file and not removing the log entry"+char(10)+
	"- Leaving a connection closed log without a corresponding connection established log"+char(10)+
	"- Leaving a shell connected log at all"+char(10)+
	"- I think connection routed logs trigger traces, too. Not sure though."+char(10)+char(10)+
	colorMagenta+"We all leave logs, sometimes. To clean them up, here are a few methods:"+char(10)+
	colorLightBlue+"Silentclean "+CT+"-- local log corruption using a text file"+char(10)+
	"-- creates a file used to corrupt logs"+char(10)+
	"-- has nuke option (see: silentclean -h)"+char(10)+
	colorCyan+"Rclean "+CT+"-- remote (or local) log corruption using objects"+char(10)+
	"-- uses a file already on system to corrupt logs"+char(10)+
	"-- accepts and works on piped objects (see: rclean -h)"+char(10)+
	colorGold+"MV "+char(10)+"-- yep, just the <b>mv</b> command"+char(10)+
	"-- poke haha | mv haha /var/system.log"+char(10)+
	colorOrange+"Wiping the log with one of these methods using a reverse shell is best"+char(10)+
	"but not necessary. You may run silentclean, exit 5hell, exit the terminal, and you will not leave a disconnect log."+char(10)+
	"-- be aware that taking any log-creating action after running sc, except exiting, may regenerate the log."+char(10)

	help_alias = "<u><b>aliases || do script || shortcuts || macros || or is it Macro's ? || User Defined Behavior"+char(10)+
	"5hell can be very simple to use, or very, very complicated, depending on your goals."+char(10)+
	"It isn't necessary to learn 100% of 5hell. Nor is it necessary to suffer through some of it's"+char(10)+
	"more complex chains of commands. You can define your own behavior in a number of ways:"+char(10)+char(10)+
	colorLightBlue+"Aliases: "+char(10)+
	colorWhite+" You may define aliases in the aliases section of 5hell.src"+char(10)+
	colorWhite+"the default ones supplied are all prompt replacements. There are also 'easy clip' defenitions"+char(10)+
	colorWhite+"that replace arguments in the user input with, for instance, the contents of a clipboard or"+char(10)+
	colorWhite+"your @home server ip. These hard coded aliases may be more complicated than a simple"+char(10)+
	colorWhite+"word or string replacement. You may, for instance, have a simple two word alias fire"+char(10)+
	colorWhite+"a whole series of commands. This might be considered a macro at that point, but also"+char(10)+
	colorWhite+"might not quite qualify."+char(10)+char(10)+
	"Here is a list of the currently defined default aliases in 5hell.src:"+char(10)+
	colorLightBlue+"Alias           | Definition"+char(10)+
	colorCyan+"bat [path]      |</b> do 1 -f [path]"+char(10)+
	colorCyan+"set [key] [val] |</b> cob set [key] [val]"+char(10)+
	colorCyan+"get [key]       |</b> cob get [key]"+char(10)+
	colorCyan+"lock            |</b> perms lock all"+char(10)+
	colorCyan+"exit            |</b> quit"+char(10)+
	colorCyan+"sc [opt]        |</b> silentclean [opt]"+char(10)+
	colorCyan+"gp [#]          |</b> glasspool [#]"+char(10)+
	colorCyan+"prompt          |</b> -this will toggle the full_prompt on/off-"+char(10)+char(10)+
	colorWhite+"Easy Clip       |</b> Replacement"+char(10)+
	colorGold+"@a              |</b> clipa -- globals.clip_board_alpha"+char(10)+
	colorGold+"@b              |</b> clipb -- globals.clip_board_beta"+char(10)+
	colorGold+"@c              |</b> clipc -- globals.clip_board_gamma"+char(10)+
	colorGold+"@tbuf           |</b> transmission buffer -- globals.T_BUF"+char(10)+
	"-- this is                |</b> where hashes go when the tree command finds them"+char(10)+
	colorGold+"@home           |</b> HOME_SERVER ip address defined in 5hell.src"+char(10)+char(10)+
	colorGold+"@B [index|-m]   |</b> directly reference a value in the"+colorOrange+" BUFFER "+CT+"by [index] or menu: [-m]"+char(10)+
	colorGold+"@o [key]        |</b> directly reference a value in the custom object by key"+char(10)+
	"Please note: several commands have their own references for editing the clipboards"+char(10)+
	"-- these commands will use @clipa, @clipb, @clipc instead of @a, @b, @c"+char(10)+
	"Further, the clipa, clipb, and clipc will use @B to reference the BUFFER:"+char(10)+
	"-- e.g: |> <b>clipa @B 1</b> -- copy the object at index 1 in the BUFFER to clipa"+char(10)+
	"---- that object may then be used by other commands that accept piped objects as input"+char(10)+
	"-- as of 3.9.6 any command may use @B [index] as any parameter(s)"+char(10)+
	"-- there are other ways to pipe objects around besides the clipboards, explore to learn more."+char(10)+
	char(10)+
	colorOlive+"Marco's and Automation: "+char(10)+
	colorWhite+" </b>You may define custom macro's with the "+colorOrange+"</b>macro</color> command. A macro is a "+char(10)+
	colorWhite+"</b>runtime-defined set of instructions executed by a single command. Think of it as an alias that performs"+char(10)+
	colorWhite+"</b>commands for you. Additionally, you may execute batch commands either from a file or from memory. There are"+char(10)+
	colorWhite+"</b>a few differences between a <u>macro</u> and a <u>do script</u>."+char(10)+
	colorWhite+"</b>Please see:  "+colorLightBlue+"</b>do -h, macro -h, and help automation for more information on this topic."+char(10)

	help_automation = "<u><b>automation || macro || do script || batch file"+char(10)+
	colorCyan+"How to fully automate <color=red>5</color><color=white>hell</color>:"+char(10)+
	colorWhite+"</b> As mentioned in <b>help alias</b>, you may define custom macro's, or sets of commands"+char(10)+
	colorWhite+"</b>that <color=red>5hell</color> will execute automatically. The two commands involved are:"+char(10)+
	colorOrange+"--: </b>macro</color> and "+colorOrange+"</b>do"+char(10)+
	colorWhite+"</b>The two commands function similarly in that they execute the defined commands as "+char(10)+
	colorWhite+"</b>if they were typed by you. The list of commands, or 'script,' is formed the same "+char(10)+
	colorWhite+"</b>way for both commands. Therefore both commands may execute the same scripts. That is, "+char(10)+
	colorWhite+"</b>do may execute a macro, and macro may execute a do script. This way, don't have to "+char(10)+
	colorWhite+"</b>remember two different formats for these similar commands."+char(10)+
	colorWhite+"</b>The specific behavior of each is as follows:"+char(10)+
	colorOrange+"DO: "+char(10)+
	colorCyan+"<b> Do is essentially a 'do while' loop that executes at least once. You specify the number "+char(10)+
	colorCyan+"</b>of loops with the first argument: <b>do [some integer]</b> "+char(10)+
	colorCyan+"</b>The <b>primary</b> way to use do is like a macro that you want repeated on a loop."+char(10)+
	colorCyan+"</b>If there are no more arguments after the number, an editor will open (scribus) where you may"+char(10)+
	colorCyan+"</b>type out the commands you want executed line by line. Lines may be complex lines, that is, "+char(10)+
	colorCyan+"</b>the lines may include piping. The output of a line will <b>not</b> be passed to the following "+char(10)+
	colorCyan+"</b>line. This way, you may type out commands without using the <b>|  |</b> trick. Once "+char(10)+
	colorCyan+"</b>you type <b>@</b> on a new line, the script will begin executing. Use <b>@@</b> on a new line"+char(10)+
	colorCyan+"</b>to abort execution. Additionally, you may use<b> scribus @do</b> to edit the buffer without executing."+char(10)+
	colorCyan+"</b>You may then fire it later with<b> do [#]</b> and then <b>@</b>."+char(10)+
	colorLightBlue+"An example do script, either written in the editor or read from a file* (*explained in the third usage): "+char(10)+
	colorGold+"</b>ifconfig -p | probe"+char(10)+
	colorGold+"</b>brutus | clipb"+char(10)+
	colorGold+"</b>grep -p 5hell | clipc"+char(10)+
	colorGold+"</b>run @c "" do 1 rshell @home "" @b"+char(10)+
	colorGold+"</b>rclean @b/b>"+char(10)+
	colorLightBlue+"</b>This would result in a network probe, an escalation, a root rshell placement, and "+char(10)+
	colorLightBlue+"</b>finally a log scrub. This is useful to run each time you attack a new target and "+char(10)+
	colorCyan+"</b>is also included as the default <b>dig.bat</b>."+char(10)+
	char(10)+
	colorCyan+"</b>The <b>Second</b> way to use do is to define the commands on a single line, wrapped by floating quotes. "+char(10)+
	colorLightBlue+"</bThis would look like:<b> do 5 "" rnip 1 | ping 1.1.1.1 """+char(10)+
	colorLightBlue+"</bThis results in pinging 1.1.1.1 five times. More complex commands may be further chained by piping. "+char(10)+
	colorLightBlue+"</b>Be sure to wrap the commands you wish to <b>do</b> in quotes* that do not touch anything "+char(10)+
	colorLightBlue+"</b>(ie, floating) as shown above."+char(10)+
	colorLightBlue+"<b>* If the command string is only two words, quotes are not needed. eg: do 1 ping 1.1.1.1"+char(10)+
	char(10)+
	colorCyan+"The <b>Third</b> way to use do is to read defined commands from a file."+char(10)+
	colorLightBlue+"</b>The commands in the (text) file are written exactly as they are when using the editor to list commands."+char(10)+
	colorLightBlue+"</b>These commands are executed with:<b> do [#] -f [pathToFile]"+char(10)+
	colorLightBlue+"</b>For your convenience, the alias "+colorGold+"</b>bat [path]</color> will be relaced by <b>do 1 -f [path]"+char(10)+
	colorLightBlue+"</b>This is most useful when launching 5hell with a set of instructions. If you launch 5hell from the command "+char(10)+
	colorLightBlue+"</b>line with: <b>5hell do 1 -f [path] </b>5hell will automatically execute the commands in the file and then exit."+char(10)+
	colorLightBlue+"</b>If you do not wish 5hell to exit after completion, use a file named <b>do.rc</b> in your home_dir/Config or"+char(10)+
	colorLightBlue+"</b>in rkit (executes only if ~/Config/do.rc does not exist). Note that <b>do</b> does not return a value other than"+char(10)+
	colorLightBlue+"</b>it's completion time. Macro's, however, do return the final value. Additionally, the <b>dig</b> command makes"+char(10)+
	colorLightBlue+"</b>use of the <b>do</b> engine when executing <b>dig.bat</b> (which itself, may reference other do scripts). "+char(10)+
	colorLightBlue+"</b>This allows 5hell to be fully automated throughout an arbitrary number of attacks. Cool stuff, right!?"+char(10)+
	char(10)+
	colorGold+"Macro:"+char(10)+
	colorWhite+"</b>A macro is similar to a do script, except it is intended to be written 'on the fly.' In other words, you type "+char(10)+
	colorWhite+"</b>the macro definition on the command line, without the editor, in most cases. If you do wish to use the editor, "+char(10)+
	colorWhite+"</b>simply use: <b>scribus @clipa/b/c | macro [macro_name]"+char(10)+
	colorWhite+"</b>Marco's are stored in the custom object and are executed when called by name: <b>macro [name]"+char(10)+
	colorWhite+"</b>A macro <b>will</b> return it's final value and will not print execution time. There is no built in option "+char(10)+
	colorWhite+"</b>to read a macro from a file, but <b>cat [file] | macro [name]</b> may be used to achieve this."+char(10)+
	colorWhite+"</b>An example macro definition:"+char(10)+
	colorWhite+"macro prop "" cp 5hell /bin | cp /bin/5hell rkit | kraken /bin/5hell | kraken rkit/5hell """+char(10)+
	colorWhite+"</b>Again, it looks exactly the same as an inline do script, because it is! However, this script is stored "+char(10)+
	colorWhite+"</b>in the custom object, </b>meaning it may be retrieved with <b>get [name]</b> and piped somewhere,"+char(10)+
	colorWhite+"</b>such as to a file. You may absolutely fire a macro with <b>do</b>. Simply type: <b>do [#] @o [macroName]</b>"+char(10)+
	colorWhite+"</b>and do will happily execute the macro. Likewise, as mentioned earlier, piping the </b>contents of a "+char(10)+
	colorWhite+"</b>do script to macro will define the macro as that do script."+char(10)+
	char(10)+
	"This all may seem complicated, but it is actually rather simple: "+char(10)+
	"--define a list of commands as if you were typing them, fire the batch of commands."+char(10)+
	"For more information, please see: <b>do -h, macro -h, dig -h</b>, help alias, and help conventions."+char(10)+
	"Also, visit the 5hell discord for example scripts!"


	if arg1 == "-s" or arg1 == "show" or arg1 == "search" then
		c_buf = []
		h_buf = []
		for cmd in command.indexes.sort
			if cmd == "shell" or cmd == "help" or cmd == "__isa" or cmd == "classID" then continue
			h = @command[cmd]
			c_buf.push(colorWhite+cmd+CT)
			c_buf.push(h("help"))
		end for
		c_buf.push(colorWhite+"shell"+char(10)+"Usage: shell -- outputs instance_name, num_commands and dictionary_size.")
		c_buf = c_buf+[help_buffer,help_conventions,help_logs,help_tools,help_alias]

		if arg2 then
			invoke_regex = false
			special_chars = ["*","^","$","#"]
			for special in special_chars
				if arg2.indexOf(special) >= 0 then invoke_regex = true
			end for
			for c in c_buf
				found = false
				if not invoke_regex then 
					if c.indexOf(arg2) >= 0 then 
						//h_buf.push(c.replace(arg2,colorRed+arg2+CT)+char(10)+colorGold+"<u>---</u>"+CT+char(10))
						found = true
						//if DEBUG then print("attempting regex: "+arg2+ " | " + c)
					end if
				else
					for w in c.split(" ")
						if globals.re.match(arg2.values, w.values) then 
							//h_buf.push( c.replace(arg2, colorRed+arg2+CT) +char(10)+ colorBlack+"<u>---</u>"+ CT +char(10) )
							//if DEBUG then print(h_buf[-1])
							c = c.replace(w,colorRed+w+CT)
							found = true
						end if
					end for
				end if
				if found then h_buf.push( c.replace(arg2, colorRed+arg2+CT) +char(10)+ colorGold+"<u>---</u>"+ CT +char(10) )
				if DEBUG then print(h_buf[-1])
			end for
			return colorGold+"<u>= = = = = = Help Search = = = = = =</u>"+char(10)+colorLightBlue+"Found: </b>"+h_buf.len+"<b> results."+CT+char(10)+h_buf.join(char(10))
		end if
		return c_buf.join(char(10))
	end if
	if arg1 == "home" then
		return "  Convention: <b>@home</b> -- indicates a server you, the end user, have set up for 5hell"+char(10)+
		"services. Servers should be of type <b>SSH</b> and/or <b>RSHELL</b> and it is recommended to run:"+char(10)+
		"<b> pwgen | pwgen hash</b>"+char(10)+
		"on ssh servers running the <b>hashim daemon</b>. The @home server is used by:"+char(10)+
		"<b> cerebrum, brutus, linkdb, transmit, and rshell/rsi</b>"+char(10)+
		"For example: <b>rshell @home notAvirus</b> would create an rshell with ip set as your @home server."+char(10)+
		"That server would be running the rshell_server used by the rsi command. An @home server may also run:"+char(10)+
		"<b> hashim, outmon, or other custom services</b>. Please contact Plu70 if you have questions about setting"+char(10)+
		"up these resources."+char(10)+
		"Please edit the appropriate line in 5hell.src to setup @home by providing an ip address, port, password,"+char(10)+
		"and directory for the pass file. It is important that you secure 5hell with login authentication,"+char(10)+
		"either stock or your own, to prevent exposure of this information! "
	end if
	
	if arg1 == "alias" then return help_alias
	if arg1 == "-c" or arg1 == "conventions" or arg1 == "-p" or arg1 == "prompt" then return help_conventions
	if arg1 == "-t" or arg1 == "tools" then return help_tools
	if arg1 == "-b" or arg1 == "buffer" then return help_buffer
	if arg1 == "-l" or arg1 == "logs" then return help_logs
	if arg1 == "-a" or arg1 == "automation" then return help_automation

	index = command.indexes
	if index.indexOf("__isa") != null then index.remove( index.indexOf("__isa"))
	if index.indexOf("classID") != null then index.remove( index.indexOf("classID"))
	if arg1 != "-i" then
		index = index.sort
	end if

	num_commands = index.len
	// for dex in index 
	// 	index[index.indexOf(dex)] = dex+char(8203)
	// end for
	columns = 7 // # commands per line
	if globals.DEBUG then print("commands: "+num_commands+" columns: "+columns)
	rows = ceil(num_commands / columns)
	if globals.DEBUG then print("rows: "+rows)
	buf = []
	count = 0
	for i in range(0,rows)
		buf.push("<color=#FFFFFFFF><b>"+index[count:count+columns].join(" "))
		count = count + columns
	end for
	print(colorGold+"- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"+CT)
	//print(format_columns(buf.join(char(10))).replace("sphinx", "<color=#FF0000FF><b>sphinx"+char(8482)+CT ) ) 
	print(format_columns(buf.join(char(10))).replace("sphinx", "<color=#FF0000FF>sphinx</color>" ) )
	print
	print(":><b> help</b> -- print this page: lists commands alphabetically")
	print(":><b> help guide</b> -- for a quick getting started guide")
	//print(":> help [-c|conventions] -- information about 5hell prompt conventions")
	print(":> help [-p|prompt|-c|conventions] -- information about 5hell prompt conventions")
	print(":> help [-t|tools] -- a short list of the main tools")
	print(":> help [-a|automation] -- print information about automating tasks")
	print(":> help [-A|alias] -- a list of the current default aliases in 5hell.src")
	print(colorOrange+":> help [-b|buffer] -- buffer, clipboard, and custom_object info")
	print(":> help [-l|logs] -- information regarding system.log")
	print(":> help [-s|show|search] -- for a full descriptive list of commands")
	print(colorCyan+":> help [-s|show|search] [word|string|regex] -- search all help info for pattern"+char(10)+"-- see grep -h for regex tokens")
	print(":> help [-i] -- list commands by command map index")
	print(":> help [home] -- information about the @home system")
	print(":> lock -- shortcut for perms lock all")
	print(":> prompt -- toggle full_prompt on and off")
	print(colorCyan+":> [command] [-h|help] -- for more information on a specific command."+char(10))
	return 0
end function
