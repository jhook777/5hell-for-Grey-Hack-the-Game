// 5hell v 4.0.0 by Plu70
// released v 4.0.0
// imports .5pk files from /root/src
// globals
ver = "4.2.4.E_falling_skies"
//print ver
if not globals.hasIndex("DEBUG") then globals.DEBUG = false // set to true by launching 5hell with --debug as any parameter
if globals.hasIndex("params") and globals.params.indexOf("--debug") >= 0 then 
	globals.DEBUG = true
	globals.params.remove(globals.params.indexOf("--debug"))
end if
size_of_5hell = "156.666"
globals.SILENT = 0 // 0 == normal, 2 == silent, 1 == clear_screen
if DEBUG then print("<size=75%>loading globals...</size>") else print("<align=center><mark=red><color=black>#</color></mark></align>")
//
EXPERIMENTAL = true 
strFunc = "" + @user_input
if strFunc.indexOf("addToHistory") == null then EXPERIMENTAL = false
if EXPERIMENTAL == true then print "<size=75%>5hell: running in experimental mode..."
//
// INITIALIZE GLOBALS SOON(tm)
//if not get_custom_object.hasIndex("glob") then get_custom_object.glob = {}
//
// these three stubs are set below by super_import
globals.metaxploit = null 
globals.crypto = null 
globals.apt_get = null
//
//
// register macros
if DEBUG then print("<size=75%>registering macros...")
if not get_custom_object.hasIndex("macros") then get_custom_object.macros = {}
//
//
globals.localip = function()
	return localmachine.local_ip
end function
globals.pubip = function()
	return localmachine.public_ip
end function
// 
globals.BIGBRAIN = false
//globals.HASH_TABLE = {} // we'll revisit this idea later
globals.GLASSPOOL = 0
globals.metaLib = null
globals.debugLib = null
globals.net_session = null
globals.backup_meta = null
globals.tagged_for_scp = ""
globals.neurobox_user = ""
globals.neurobox_pass = ""
globals.clip_board_delta = "" // for do
globals.debug_username = ""
globals.debug_password = "" // neurobox debug credentials
//
globals.command_buffer = []
globals.enumerated = []
globals.shell = get_shell
globals.localmachine = shell.host_computer
globals.currentPath = current_path
globals.homePath = home_dir
globals.instance = globals.localmachine.File(program_path)
globals.T_BUF = [(localip+"@"+pubip)] // transmission buffer
globals.BUFFER = [get_shell]
//
globals.spoolpath = 0 // 0 false, string true
globals.SAFEWORD = "stop_code" // use @STOP (or this value) in a do script and/or in an if statement within a do script to 'break' the do loop
globals.HERMES = false
globals.inbox = null
//
globals.grepped_file = null
globals.airing = false
globals.mail_user = null
globals.last_mail = null
globals.this_mail = 0
//
globals.XPLOITS = []
globals.MEMORY = null
globals.meta_scan = []
//
globals.routerLib = null
globals.portInfo = null
globals.tarLan = null
globals.last_whois = ""
globals.PORT_MAP = {}
globals.targetIP = null
globals.targetPort = "router"

//
if DEBUG then print("<size=75%>loading dictionary...</size>")
// this function puts the dictionary in the custom object for use between nested launches without breaking legacy dictionary calls
globals.dict_a = function(import=0)  
	cobble = get_custom_object
	if typeof(import) == "list" then cobble.dictionary = import // set a new dicitonary from input: list
	if not cobble.hasIndex("dictionary") then cobble.dictionary = ["a"] else globals.BIGBRAIN = true // set default dictionary if it doesn't exist
	return cobble.dictionary // return the dictionary in all cases as a list
end function
//// UPDATING THE DICTIONARY IS HANDLED BY COMMAND.CEREBRUM //////
if DEBUG then ds = dict_a.len
if DEBUG then print("<size=75%>dictionary loaded...("+(ds/1000)+"kb)</size>")


//
// import 5phinx -- this contains critical shared functions and the backbone of the hacking suite
// Do not remove the comment in the next line, it is necessary for Greybel support
import_code("/root/src/5phinx.5pk") // override=5phinx.5pk
//
// set globals.metaxploit, globals.crypto, globals.apt_get 
globals.super_import // located in 5phinx.5pk; include_lib latest of: metaxloit, crypto, aptclient
//
// import kore.5pk -- kore's domain
// Do not remove the comment in the next line, it is necessary for Greybel support
import_code("/root/src/kore.5pk") // override=kore.5pk
//
// import dtools.5pk -- dev/dictionary tools
// Do not remove the comment in the next line, it is necessary for Greybel support
import_code("/root/src/dtools.5pk") // override=dtools.5pk
//
// import contrib.5pk -- this contains shared functions and commands contributed by the community
// Do not remove the comment in the next line, it is necessary for Greybel support
import_code("/root/src/contrib.5pk") // override=contrib.5pk
//
// import net.5pk -- networks tools
// Do not remove the comment in the next line, it is necessary for Greybel support
import_code("/root/src/net.5pk") // override=net.5pk
//
globals.dmanager = new DaemonManager
dmanager.Init
//
// end globals
if DEBUG then print("<size=75%>loaded get_file...")                       
if DEBUG then print("<size=75%>loading 5hell.5pk...("+size_of_5hell+"kb)")                   /////LOADING 5HELL////////////
if DEBUG then print("<size=75%>loading clip commander...(666 licks to the center)")     
// consolidate all clipX's into one clipboard command
// newclip, to combine all clips
// begin clip commander
// expand by adding a CLIP map index and creating a corresponding command.[yourclip] = function(...) call below _clipboard (use existing ones as templates)
CLIP = {"a":"","b":"","c":""}
_clipboard = function( index, arg1, arg2 )
    // index checking is done at command.clip[x] calls
    cw = colorWhite
    clip = {}
    clip.msg = colorCyan+"</b>clip"+colorWhite+index+CT+"</color>"
    clip.hlp = "clipboard || clipa || clipb || clipc || clippy dippy"+char(10)+
    "There are, by default, three clipboard spaces: clipa, clipb, clipc. It is"+char(10)+
    "possible to expand beyond this limit by adding entries to the CLIP map in 5hell.5pk."+char(10)+
	"The clipboards may store any data type or game object. "+char(10)+
	char(10)+
	"EZ_CLIP allows use of aliases:"+char(10)+
    "--: "+cw+"@a"+CT+" for clip"+cw+"a"+CT+", "+cw+"@b"+CT+" for clip"+cw+"b"+CT+", and "+cw+"@c"+CT+" for clip"+cw+"c"+char(10)+
    "---- when you want to reference the clipboard in an argument."+char(10)+
	"For example: "+char(10)+
    colorGrey+"|> "+cw+"clipa foobar"+char(10)+
    colorGrey+"|> "+cw+"echo @a"+char(10)+
    colorGrey+"<b>foobar"+char(10)+
	char(10)+
	"The clipboard spaces start out as an empty string, by default.  "+char(10)+
	"You may edit text in the clipoard directly with:"+char(10)+
	colorGrey+"|> "+colorWhite+"scribus "+colorMagenta+"@"+colorLightBlue+"clip"+colorWhite+"[a|b|c]"+char(10)+
	"--eg: scribus "+colorWhite+"@clipa"+CT+" | poke magnum.opus | lock"+char(10)+
	"--<b>note</b>: scribus @clipa edits the clipboard's text"+char(10)+
	"--<b>note</b>: scribus @a will not edit clipa but rather:"+char(10)+
	"---- if clipa is a list of strings: will open the editor on the array and return an array"+char(10)+
	"---- if clipa is a string: will attempt to edit a file whose name matches the first word in the string "+char(10)+
	"---- if clipa is a text file: will edit the file"+char(10)+
	char(10)+
	colorGreen+ "Viewing help for "+clip.msg+char(10)+
    colorCyan+"</b>Usage: "+clip.msg+" -- returns the contents of "+clip.msg+char(10)+
    "-- stored functions are returned as a reference"+char(10)+
    colorGold+"</b>Usage: "+clip.msg+" [<b>any_value</b>] -- set "+clip.msg+" to any value"+char(10)+
    "-- piped objects are stored and returned as objects"+char(10)+
    "-- piped functions are stored and returned as function references"+char(10)+
    "-- piped strings, including piped (string: integers), are stored and returned as strings"+char(10)+
    "-- piped integers are stored and returned as integers"+char(10)+
    "--nb: you may cast a string to an int with:"+char(10)+
    "----:<b> clipa [+=|-=] 0"+char(10)+
    "---eg: <b>clipa 12 || clipa += 0"+char(10)+
    colorCyan+"</b>Usage: "+clip.msg+" [<b>-z</b>] -- set "+clip.msg+" to "+cw+"int: zero"+char(10)+
    "-- passing <b>0</b> as an argument sets "+clip.msg+" to <b>string: 0"+char(10)+
	"-- piping in an <b>int: 0</b> results in no_argument behavior: it returns "+clip.msg+char(10)+
    colorCyan+"</b>Usage: "+clip.msg+" [<b>-n</b>] -- set "+clip.msg+" to "+colorMagenta+"</b>null"+char(10)+
    "-- this is useful in sme cases"+char(10)+
	"-- note: the default starting state is an empty string"+char(10)+
	"---- it no longer defaults to null"+char(10)+
    colorCyan+"</b>Usage: "+clip.msg+" [<b>++|--</b>] -- increment | decrement "+clip.msg+" by 1"+char(10)+
    "-- old way:<b> clipa 0 || calc @a [+|-] 1 | clipa"+char(10)+
    "-- new way:<b> clipa 0 || clipa [++|--]"+char(10)+
    colorCyan+"</b>Usage: "+clip.msg+" [<b>+=|-=</b>] [int] -- increment | decrement "+clip.msg+" by int"+char(10)+
    "-- only ints or (string: ints) may by [inc|dec]remented"+char(10)+
	"Advanced options:"+char(10)+
    colorCyan+"</b>Usage: "+clip.msg+" [<b>@cc</b>] -- set "+clip.msg+" to the command buffer"+char(10)+
	colorCyan+"</b>Usage: "+clip.msg+" [<b>@tbuf</b>] -- set "+clip.msg+" to the transmission buffer"+char(10)+
	"--eg:<b> tree || gopher @tbuf"+char(10)+
    colorCyan+"</b>Usage: "+clip.msg+" [<b>@B</b>] [<b>-m|#</b>] -- set "+clip.msg+" to "+colorOrange+"BUFFER[#]"+char(10)+
    "-- passing <b>-m</b> instead of an index will prompt for selection with the BUFFER menu"+char(10)+
	"NOTE: @tbuf, and @B are now available to <b>all</b> commands via ez_clip"+char(10)+
	"--eg:<b> clipa @B 1 || clipb "" /home/guest/rkit/5hell "" || run @b @a"+char(10)+
	"--eg:<b> run /home/guest/rkit/5hell @B -m"+char(10)+
	"NOTE: it is important to distinguish between "+char(10)+
	"-- "+cw+"@b"+CT+" -- clipb reference, and"+char(10)+
	"-- "+colorOrange+"@B"+CT+" -- BUFFER reference"+char(10)+
	"eg: <b>clipb foobar || echo @b </b>vs<b> zap || gp @B 1"+char(10)+
	"-- see help alias for a full list of ez_clip aliases"+char(10)+
    "Note: all (successful) uses of "+clip.msg+" will return the value of "+clip.msg+char(10)+char(10)+
    "See Also: cob -h, help alias, help buffer"
	if @arg1 == "help" or @arg1 == "-h" then return clip.hlp
    clip.clp = @arg1
	if DEBUG then print "debug: clipboard: "+char(10)+"--<b> arg1: "+@arg1+", arg2: "+@arg2
    if typeof(@arg2) == "string" then arg2 = arg2.to_int
    if @arg1 == "++" or @arg1 == "--" then arg2 = 1
    clip.add = function()
		if DEBUG then print "--- clipping: "+@clip.clp
        if @arg1 then 
            globals.CLIP[outer.index] = @clip.clp
            print clip.msg+": clipped: "+typeof(@CLIP[outer.index])
        end if
        return @CLIP[outer.index]
    end function
    clip.n = function()
        clip.clp = null 
    end function
    clip.z = function()
        clip.clp = 0
    end function
    clip.up = function()
        if typeof(@outer.arg2) != "number" then; print clip.msg+": += expects integer";return;end if
        add = @CLIP[outer.index]
        if typeof(@add) == "string" then add = add.to_int 
        if typeof(@add) != "number" then; print clip.msg+": cannot increment "+typeof(@add);outer.arg1 = 0;return;end if
        clip.clp = add + outer.arg2
		clip.clp = str(clip.clp)
    end function
    clip.dn = function()
        if typeof(@outer.arg2) != "number" then; print clip.msg+": += expects integer";return;end if
        sub = @CLIP[outer.index]
        if typeof(@sub) == "string" then sub = sub.to_int 
        if typeof(@sub) != "number" then; print clip.msg+": cannot decrement "+typeof(@sub);outer.arg1 = 0;return;end if
        clip.clp = sub - outer.arg2
		clip.clp = str(clip.clp)
    end function
    // legacy compat:
	clip.tbf = function()
		globals.T_BUF.pull 
		clip.clp = globals.T_BUF
		globals.T_BUF = [(localip+"@"+pubip)]
    end function
    clip.cc = function()
        clip.clp = globals.command_buffer.join(char(10))
    end function
	clip.bf = function()
		if globals.BUFFER.len < 1 then print clip.msg+"malp: BUFFER is empty."
		i = 0
		for b in globals.BUFFER
			print("["+colorWhite+i+CT+"] - <b>"+checkUser(@b)+":"+typeof(@b)+"</b>")
			i = i + 1
		end for
        indx = @outer.arg2
        if typeof(@indx) == "string" then 
            if indx == "-m" then indx = user_input("clip:> ").to_int else indx = indx.to_int
        end if
        if typeof(@indx) == "number" and indx >= 0 and indx < BUFFER.len then clip.clp = @globals.BUFFER[indx] else clip.clp = clip.msg+": @B: invalid buffer selection."
    end function    
    // end_legacy_compat
    clip.rtrn = function()
        clip.clp = 0
    end function
    _=function();end function
	// start switch
	if typeof(@arg1) == "function" then return clip.add
    switch(@arg1)
        case("-n", @clip.n)
        case("-z", @clip.z)
        case("++", @clip.up)
		case("--", @clip.dn)
		case("+=", @clip.up)
		case("-=", @clip.dn)
        case("@tbuf", @clip.tbf)
        case("@cc", @clip.cc)
        case("@B", @clip.bf)
        case(0, @clip.rtrn)
        if DEBUG then print "clip: switch: firing"
    default(@_)
    return clip.add
end function
command.clipa = function(arg1,arg2,arg3,arg4)
    return @_clipboard("a",@arg1,@arg2)
end function
command.clipb = function(arg1,arg2,arg3,arg4)
    return @_clipboard("b",@arg1,@arg2)
end function
command.clipc = function(arg1,arg2,arg3,arg4)
    return @_clipboard("c",@arg1,@arg2)
end function
// end clip commander
if DEBUG then print("<size=75%>loaded clip commander...")  
command.passwd = function(arg1, arg2, arg3=0, arg4=0)
  if arg1 == "help" or arg1 == "-h" then return "<u>Password || Change Password || passwd"+char(10)+"Usage: passwd [opt: user] [opt: password] -- change password for user"+char(10)+"- will prompt for missing options"
	user = null
	pass = null
	if arg1 then user = arg1
	if arg2 then pass = arg2
	if not user then user = user_input("passwd: change password for which user? :> ")
  if not pass then pass = user_input("passwd: select a new password for: "+user+":> ",1,0)
	if pass == "" or pass == " " then return "aborting..."
  try = localmachine.change_password( user, pass)
  if try == 1 then return "passwd: "+colorWhite+"password for "+user+" updated to: "+char(10)+pass
  return try
end function
command.echo = function(arg1, arg2=0, arg3=0, arg4=0)
	if @arg1 == "help" or @arg1 == "-h" then return "ECHO || echo || Echo || echO"+char(10)+
	"Usage: echo [up] [to] [four] [params] -- returns concatonated params to the terminal"+char(10)+char(10)+
	"General usage is to echo text back to the terminal during batch script/macro execution."+char(10)+
	"However, it may also be used to feed input to another command or concatonate outputs"+char(10)+
	"of multiple commands. You may use floating quotes (single quotes not touching another"+char(10)+
	"character) to wrap complex input parameters. Examples:"+char(10)+
	"|> echo bob burger  --  output: bob burger"+char(10)+
	"|> echo "" Eat at Joe's Diner. "" <color=red>Because</color> "" it's the best. "" "+char(10)+
	"-- output: Eat at Joe's diner. <color=red>Because</color> it's the best."+char(10)+
	"|> echo three four | echo one two -- output: one two three four"+char(10)+
	"Here's a fairly useless example, lol:"+char(10)+
	"|> cat file.txt | echo | poke file2.txt | cat | echo | poke file3.txt"+char(10)+char(10)+
	"Simple enough. You may use richtext in the echo to spruce it up."+char(10)+
	"Resizing text and adding color allows the echo to stand out when text"+char(10)+
	"is flying by during a complex <b>dig</b>, for example."
	ec = @arg1+" "
	if @arg2 then @ec = @ec + @arg2+" "
	if @arg3 then @ec = @ec + @arg3+" "
	if @arg4 then @ec = @ec + @arg4
	return ec.trim
end function
command.clear = function(arg1, arg2, arg3=0, arg4=0)
	if @arg1 == "help" or @arg1 == "-h" then return "Clear Screen || Terminal Wipe || clearscreen"+char(10)+"Usage: clear -- clears the terminal of all text"
	print("",1)
	return 0
end function
command.ps = function(arg1, arg2, arg3=0, arg4=0)
	ps_usage = "Show Processes || PS || show procs || not actually top or htop"+char(10)+
	"<b>Usage: ps [opt:-r] [opt:shell|computer] -- show processess running on the active host_computer"+char(10)+
	"-- when glasspool is active:"+char(10)+
	"-- the active shell/computer is the active host_computer"+char(10)+
	"-- optional [-r] parameter returns raw, uncolorized output"+char(10)+
	"--eg: ps -r"+char(10)+
	"<b>Usage: ps [opt:-r] [shell|computer] -- show processes running on the piped object"+char(10)+
	"-- optional [-r] parameter returns raw, uncolorized output"+char(10)+
	"--eg: rsi 1 7 | ps"
	if @arg1 == "-h" or @arg1 == "help" then return ps_usage
	output = null
	raw = false
	verbose = false 
	if arg3 == "--verbose" then verbose = true
	locals.hold_comp = globals.localmachine
	if arg1 == "-r" then
		raw = true 
		arg1 = arg2 
		arg2 = arg3
		arg3 = arg4 
	end if
	if arg1 and (typeof(arg1) == "shell" or typeof(arg1) == "computer") then 
		if typeof(arg1) == "shell" then locals.hold_comp = arg1.host_computer
		if typeof(arg1) == "computer" then locals.hold_comp = arg1 
	end if
	if verbose then print("<size=75%>Showing processes...")
	if raw == true then return format_columns(locals.hold_comp.show_procs)
	p_buf = hold_comp.show_procs.split(char(10))
	i = 0
	if DEBUG then print "debug: "+p_buf
	for line in p_buf 
		if i == 0 then 
			line = colorWhite+"</b>"+line+"</color>".replace("USER","<color=#F5F5F5></b>USER</color>")
			p_buf[i] = line
			i = i + 1
			continue 
		end if
		line = colorCyan+"</b>"+line
		line = line.replace("dsession",colorRed+"</b>dsession").replace("Xorg",colorLightBlue+"</b>Xorg").replace("kernel_task",colorLightBlue+"</b>kernel_task").replace("ps",colorRed+"</b>ps").replace("5hell",colorRed+"5"+colorWhite+"hell")//.replace("root",colorOrange+"<b>root</color>").replace("guest",colorWhite+"<b>guest</color>")
		p_buf[i] = line
		i = i + 1
	end for
	output = format_columns(p_buf.join(char(10)))
	return output
end function
command.kill = function(arg1, arg2, arg3=0, arg4=0)
	if @arg1 == 0  or @arg1 == "-h" or arg1 == "help" then return "kill || end process || terminate script"+char(10)+char(10)+
	colorWhite+"Usage: kill [ALL|PID] [opt: shell|computer] -- terminate PID"+char(10)+
	"-- PID should be process number or ALL"+char(10)+
	"-- see the <b>ps</b> command for process ID's"+char(10)+
	"--<b> kill ALL </b>will attempt to close all programs."+char(10)+
	"n.b. if<b> kill ALL </b>kills the terminal that launched the program,"+char(10)+
	"---- it might not complete its task."+char(10)+char(10)+
	colorWhite+"Usage: kill [process_name] [opt: shell|computer] --"+char(10)+
	"-- kill processes by process name instead of PID"+char(10)+
	"-- NOTE: kills ALL processes of that name"+char(10)+char(10)+
	colorWhite+"Advanced: kill [ALL|process_name:exclude1:exclude2:...] [opt:computer|shell]"+char(10)+char(10)+
	"-- seperate process names or ID's to exclude from the kill process with the '<b>:</b>' character"+char(10)+
	"-- the first process name (or the ALL keyword) will be the kill target"+char(10)+
	"-- all process names or ID's following the first <b>:</b> will be excluded"+char(10)+
	"-- UNLESS the kill target is a process ID"+char(10)+
	"--eg: <b>kill ALL:1023:5hell [shell_obj]</b> -- kill everything on the [shell] except 5hell and 1023"+char(10)+
	"--eg: <b>kill 1023:5hell [computer_obj</b> -- kill 1023 on the [computer]; no exceptions"+char(10)+
	"---- ie: passing a PID ignores exceptions"+char(10)+
	"--rg: <b>kill 5hell:1023</b> -- kill all instances of 5hell on the active computer except 1023"+char(10)+char(10)+
	"Note: piping a shell or computer object runs kill on the object instead of locally"+char(10)+
	"Note: running kill while glasspool is active runs kill on the active object"+char(10)+
	"-- unless a shell or computer is piped"
	target_machine = globals.localmachine
	if typeof(arg2) == "shell" then target_machine = arg2.host_computer
	if typeof(arg2) == "computer" then target_machine = arg2
	//
	PID = ""
	exclude = []
	if typeof(arg1) == "string" then 
		if typeof(arg1.to_int) == "number" then 
			PID = arg1.to_int 
		else 
			exclude = arg1.split(":")
			PID = exclude.pull
			//if typeof(PID.to_int) == "number" then PID = PID.to_int
		end if
	end if
	if exclude.len < 1 then exclude = [""]
	if typeof(PID) != "number" and typeof(PID) != "string" or PID == "" or PID == 0 then return "kill: invalid input"+char(10)+"Usage: kill [pid|process_name] [opt:shell|computer]"
	//
	if typeof(PID) == "string" then
		processes = target_machine.show_procs.split(char(10))
		killed = false
		for p in processes
			if p == "USER PID CPU MEM COMMAND" then continue
			process = p.split(" ")
			process_ID = process[1]
			process_CMD = process[4]
			stor = globals.localmachine
			globals.localmachine = target_machine
			if PID == "ALL"  or PID == process_CMD or PID == process_ID then 
				if exclude.indexOf(process_CMD) == null and exclude.indexOf(process_ID) == null then print command.kill(process_ID)
				killed = true 
			end if
			globals.localmachine = stor
		end for
		if killed == false and PID != "ALL" then return "kill: process <u>" + PID + "</u> not found" else return 0
	end if
	//
	if DEBUG then print "debug: kill: PID: "+typeof(PID)+":"+PID
	output = target_machine.close_program(PID)
	if output == true then return("kill: terminating process: " + PID + "...");
	if output then return(output)
	return "kill: process <u>" + PID + "</u> not found"
end function
command.pwd = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "Usage: pwd -- print working directory"+char(10)+"-- returns the current path as a string"
	return currentPath
end function
command.psudo = function(operation, arg2, arg3, arg4)
    if operation == "help" or operation == "-h" then return "PSUDO || sudo || get shell || get_shell || start terminal"+char(10)+
	colorCyan+"<u>Start_terminal options:"+char(10)+"--"+char(10)+
    "Usage: "+colorGold+"</b>psudo"+CT+" -- display the psudo menu"+char(10)+"--"+char(10)+
    "Usage: "+colorGold+"</b>psudo"+CT+" ["+colorWhite+"shell_object"+CT+"] -- execute <b>start_terminal</b> on the shell_object"+char(10)+
    "-- unlike <b>run</b>, this command will <b>end</b> the script"+char(10)+"--"+char(10)+
    "Usage: "+colorGold+"</b>psudo"+CT+" ["+colorWhite+"-l"+CT+"] -- execute start_terminal on the currently active shell object"+char(10)+
	"-- unlike <b>run</b>, this command will <b>end</b> the script"+char(10)+"--"+char(10)+
	"--nb: start_terminal results in an active trace if an administrator (root dsession) is active"+char(10)+
	"---- scrub logs and disconnect as soon as your work is done to avoid a strike"+char(10)+char(10)+
	colorCyan+"<u>Get_shell options:"+char(10)+"--"+char(10)+
    "Usage: "+colorGold+"</b>psudo"+CT+" ["+colorWhite+"-u"+CT+"] [opt:"+colorWhite+"user"+CT+"] [opt:"+colorWhite+"password"+CT+"] -- "+colorOrange+"BUFFER"+CT+" a shell object using credentials"+char(10)+"--"+char(10)+
	"Usage: "+colorGold+"</b>psudo"+CT+" ["+colorWhite+"-s|-sf"+CT+"] [opt:"+colorWhite+"password"+CT+"] -- "+colorOrange+"BUFFER"+CT+" a <b>root</b> shell object using credentials"+char(10)+
	"-- passing -s will prompt to open the object's menu in malp"+char(10)+
	"-- passing -sf will skip the prompt and go straight to the menu"+char(10)+
	"-- both modes return the shell object on success or a string on failure"+char(10)+
	"Usage: "+colorGold+"</b>psudo"+CT+" ["+colorWhite+"-sn"+CT+"] [opt:"+colorWhite+"password"+CT+"] -- as above but skips prompt and skips malp menu"+char(10)+
	"-- returns shell object on success, string on failure"
//
    _psudo_menu = function()
        print colorGold+"</b>psudo: "+CT+"["+colorWhite+"y</b>|<b>l"+CT+"] execute "+colorCyan+"</b>start_terminal"+CT+" on the currently active shell object"
        print colorGold+"</b>psudo: "+CT+"["+colorWhite+"u"+CT+"] BUFFER a <b>local</b> user shell using credentials"
        print colorGold+"</b>psudo: "+CT+"["+colorWhite+"s"+CT+"] BUFFER a <b>root</b> shell using credentials"
        print colorGold+"</b>-- press any other key to abort"
        op = user_input(colorWhite+"||: "+colorGold+"</b>",0,1).lower
        if "ylus".indexOf(op) == null then return 0 else return "-"+op
    end function
//
    _go_time = function(user=null,pass=null,open_it)
		if DEBUG then print "debug: go time: "+char(10)+"usr: "+user+" is a: "+typeof(user)+char(10)+"pass: "+pass+" is a: "+typeof(pass)
        if not user or not pass or user == "" or pass == "" then return colorGold+"</b>psudo: aborting..."
		if typeof(user) != "string" or typeof(pass) != "string" then return colorGold+"</b>psudo: aborting..."
        locals.sh = get_shell(user,pass)
        if typeof( locals.sh ) == "shell" then 
            colorLightBlue+"</b>malp: "+colorGreen+"success</color></b>; new shell sent to "+colorOrange+"BUFFER"
            if open_it == 0 then open_it = user_input(colorGreen+"</b>-- view context menu in "+colorOrange+"BUFFER"+CT+"? [y/<b>N</b>] ||: "+colorWhite,0,1)
            if open_it == 1 or open_it == "y" or open_it == "Y" then return command.malp("-b",locals.sh) else globals.BUFFER.push(locals.sh)
            colorGold+"</b>psudo: returning shell object..."
            return locals.sh
        else 
            return colorGold+"</b>psudo: "+colorRed+"</b>failed</color> to obtain shell object"+char(10)+colorGold+"</b>-- check credentials and try again"
        end if
    end function
    _shell_prompt = function(sh)
		if typeof(sh) != "shell" then return colorGold+"psudo: error, expected shell, got: "+sh
        if user_input(colorGold+"</b>psudo: "+colorOrange+"warning; start_terminal ends the script!"+char(10)+
            colorGold+"psudo: "+colorOrange+"warning; start_terminal may result in an active trace"+char(10)+
            colorGold+"</b>Continue? ["+colorWhite+"y"+CT+colorGold+"</b>/"+CT+colorWhite+"N"+CT+colorGold+"</b>] ||: "+colorWhite,0,1).lower == "y" then
				get_custom_object.return_value = "#!#CASCADE#!#"
                exit locals.sh.start_terminal
                exit "starting_terminal on target shell..."
                return char(10)+
                colorGold+"psudo:"+colorOrange+" Attention: if you are seeing this message:"+char(10)+
                colorOrange+"</b>-- A game anomoly has kept the script running"+char(10)+
                colorOrange+"</b>-- despite having used start_terminal."+char(10)+
                colorOrange+"</b>-- You will need to manually exit out of 5hell to start the terminal."+char(10)+
                colorOrange+"</b>-- Note: you must <b>exit</b>; do not use ctrl+c"
                exit "This is a game bug, not mine."
            return 0
		else 
		 	return colorGold+"</b>psudo: aborting..."
        end if
    end function
	if not operation then operation = _psudo_menu
	if not operation then return colorGold+"</b>psudo: aborting..."
    // if it's a shell we warn and confirm
    if typeof(operation) == "shell" then _shell_prompt(operation)
    // otherwise we parse the flag or return if invalid flag
    if typeof(operation) != "string" then return colorGold+"</b>psudo: aborting..."
    if operation == "-l" or operation == "-y" then return _shell_prompt(globals.shell)
	usr = null
	psw = null
    if operation == "-u" then 
		if not arg2 then usr = user_input("user name:> ") else usr = arg2 
		if arg3 then psw = arg3 else psw = user_input("user passwor:> ")
		return _go_time(usr,psw)
	end if
    if operation == "-s" or operation == "-sf" or operation == "-sn" then
		conf = 0
		if operation == "-sf" then conf = 1
		if operation == "-sn" then conf = -1
		usr = "root"
		if not arg2 then psw = user_input("root password:> ",1) else psw = arg2
		return _go_time(usr,psw,conf)
	end if
    return colorGold+"</b>psudo: invalid input"+char(10)+"-- aborting..."
end function
command.ls = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "-h" or arg1 == "help" then return "List Files | List Folders | File Details"+char(10)+
	"Usage: ls [opt: -l|-a|-s|-r] [opt: /path] -- list files in path"+char(10)+
	"Opt: [-l] -- list all file details for given path"+char(10)+
	"Opt: [-a] -- list all files, alphabetically, for given path"+char(10)+
	"-- by default files and folders are listed from first created"+char(10)+
	"---- to last created "+char(10)+
	"Opt: [-s] -- list all files by size (not yet implemented)"+char(10)+
	"Opt: [-r] -- list all files and return raw, uncolorized output"+char(10)+
	"Note: option flags may be combined in any order"+char(10)+
	"-- eg: <b>ls -lars"
	subFiles = null
	folderPath = globals.currentPath
	if DEBUG then print("ls: "+folderPath)
	raw_output = false
	showHide = 1
	showDetails = 0
	a_order = 0
	s_order = 0
	if arg1 then 
		if arg1.indexOf("-") == 0 then 
			if arg2 then folderPath = arg2
			if arg1.indexOf("l") != null then showDetails = 1
			if arg1.indexOf("a") != null then a_order = 1
			if arg1.indexOf("s") != null then s_order = 1
			if arg1.indexOf("r") != null then raw_output = true
		else 
			folderPath = arg1
		end if
	end if 
	folder = globals.get_file(folderPath)
	if not folder then return "ls: No such file or directory"
	if DEBUG then print("folder: "+folder.path+" is a: "+typeof(folder))
	if folder.is_folder then 
		subFiles = folder.get_folders + folder.get_files
		if DEBUG then print "debug: pre alpha sort"
		if a_order then 
			f_buf = []
			s_buf = []
			for sub in subFiles 
				f_buf.push(sub.name)
			end for
			f_buf.sort
			for f in f_buf 
				for sub in subFiles
					if sub.name == f then s_buf.push(sub)
				end for 
			end for 
			subFiles = s_buf
		end if
		if DEBUG then print "debug: pre size sort"+char(10)+
		"-- subFiles: "+subFiles
	else 
		subFiles = [folder]
	end if
	output = ""
	for subFile in subFiles
		line_color = colorWhite+"</b>"
		nameFile = subFile.name
		permission = subFile.permissions
		owner = subFile.owner
		size = subFile.size
		group = subFile.group
		is_bin = subFile.is_binary
		if is_bin then line_color = colorCyan + "</b>"
		if subFile.is_folder then line_color = colorLightBlue + "</b>"
		if subFile.is_symlink then nameFile = colorGold+"</b>"+nameFile
		if raw_output then line_color = ""
		if showDetails then
			output = output + char(10) + line_color + permission + " " + owner + " " + group + " "+ size + " bin["+is_bin+"] " + nameFile
		else
			output = output + char(10) + line_color + nameFile
		end if
	end for

	output = output.trim
	output = output.split(char(10))
	return format_columns(output.join(char(10)).trim)
end function
command.cd = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "Usage: cd [path] -- change current working directory to path"+char(10)+"Usage: cd .. -- go back to parent directory."+char(10)+"Usage: cd -- return to home directory."+char(10)+"Returns: 0 on success or string on failure."
	if arg1 == "" then arg1 = 0
	if not globals.get_file(globals.currentPath) then globals.currentPath = home_dir
	chd = localmachine.File(globals.currentPath)
	if not arg1 then
		globals.currentPath = globals.homePath
		return 0
	end if
	if not chd then
		globals.currentPath = "/"
		return "cd: path error. Setting path to<b> / </b>"+char(10)+"...please try again."
	end if
	if arg1 == ".." then
		if chd.name != "/" then
			globals.currentPath = chd.parent.path
		end if
		return 0
	end if
	new_path = globals.get_file(arg1)
	if new_path then
		if new_path.is_folder then globals.currentPath = new_path.path else return "cd: "+new_path.path+" is not a directory."
	else
		return "cd: "+arg1+" not found."
	end if
	return 0
end function
command.rm = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == 0 or arg1 == "-h" or arg1 == "help" then return "<b><u>Remove File || RM || Delete</b></u> "+char(10)+"Usage: rm [opt:-r] [path|file_object] [opt:shell|computer]"+char(10)+"Usage: rm [path|file_object] - deletes a file"+char(10)+"Usage: rm -r [path|file_object] - deletes a folder (and all contents)"+char(10)+"Usage: rm [opt:-r] [/absolute/path] [shell_object|computer_object]"+char(10)+"-- uses supplied shell or computer to delete file or folder at path"+char(10)+char(10)+"N.B. The system.log delete entry will be from the originating IP"+char(10)+"-- NOT the ip of the remote shell or computer"+char(10)+"-- be sure to clean the log when remote deleting"
	path_to_delete = null
	recursive = false
	remote = false
	shell_to_use = globals.shell 
	file = null
	usage = "rm: usage:<b> rm [opt:-r] [path|file_object] [opt:shell|computer]</b>"
	print "<u>"+colorRed+"- - - - - "
	if arg1 == "-r" then 
		recursive = true 
		arg1 = arg2 
		arg2 = arg3 
	end if	
	if not arg1 then return usage
	if typeof(arg1) == "string" then 
		path_to_delete = arg1 
		file = globals.get_file(path_to_delete)
	end if
	if typeof(arg1) == "file" then 
		file = arg1
		path_to_delete = file.path 
	end if
	if typeof(arg1) == "shell" or typeof(arg1) == "computer" then return usage
	if not path_to_delete then return usage 
	if arg2 and typeof(arg2) == "shell" then 
		shell_to_use = arg2 
		remote = true 
		file = shell_to_use.host_computer.File(path_to_delete)
		if not file then return "rm: file not found on remote shell." else print "rm: found file on remote shell..."
	end if
	if arg2 and typeof(arg2) == "computer" then file = arg2.File(path_to_delete) 
	if file then
		if not file.has_permission("w") then return "rm: permission denied"
		print "rm: "+colorWhite+"deleting: </b><u>"+file.path
		if file.is_folder then
			if recursive == true then return file.delete else return "rm: use<b> rm -r [path|file_object] </b>to remove a folder."
		end if
		return file.delete
	end if
	return "rm: file not found."
end function
command.mv = function(arg1, arg2=0, arg3=0, arg4=0)
	if arg1 == "-h" or arg1 == "help" then return "MOVE || MV || rename || I like to move it move it"+char(10)+
	"Usage:"+colorWhite+" mv [opt:-r] [source_path|file_object] [destination_path|file_object]"+char(10)+
	"-- move file or folder to new path"+char(10)+
	"-- optionally rename the file"+char(10)+
	"-- if destination is folder uses original filename, else renames"+char(10)+
	"-- overwrites destination file if it exists and is not a folder"+char(10)+
	"-- passing the [-r] flag will result in <b>overwriting the destination folder"+char(10)+
	"-- if file objects are supplied then uses the object's path"+char(10)+
	"-- e.g:<b> mv bob /burger -- moves bob to / dir and renames to burger"+char(10)+
	"---- if /burger is a directory; moves bob into burger as /burger/bob"+char(10)+
	"-- if bob is already a folder at the destination, and the [-r] flag is passed: "+char(10)+
	"---- /burger/bob will be overwritten, otherwise the result is /burger/bob/bob"+char(10)+
	" "+char(10)+
	"Usage: mv [opt:-r] [source_path|file_object] [@]"+char(10)+
	" -- move file to current path using original file name"+char(10)+
	" ---- otherwise works as above"+char(10)+
	"NOTE: this command moves files between folders on the active shell/computer object"+char(10)+
	"-- please use <b>scpm</b> or BUFFER <b>scp</b> to transfer files between remote machines"+char(10)
	
	ow_fldr = false
	if arg1 == "-r" then
		ow_fldr = true
		arg1 = arg2
		arg2 = arg3 
		arg3 = arg4 
	end if

	if not arg1 or not arg2 then return "mv: not enough input"
	if typeof(arg1) != "string" and typeof(arg1) != "file" then return "mv: invalid parameters;"+char(10)+
	"-- expects strings or file objects"
	if typeof(arg2) != "string" and typeof(arg2) != "file" then return "mv: invalid parameters;"+char(10)+
	"-- expects strings or file objects"
	print "<u>"+colorLightBlue+"= = = = ="
	if typeof(arg1) == "file" then 
		if p_validate(arg1,"size") then file = arg1 else return "mv: error: input file object does not exist"
	else 
		file = globals.get_file(arg1)
	end if
	if not file then return("mv: can't find " + arg1)
	destination = null
	final_name = null
	if typeof(arg2) == "file" then 
		if p_validate(arg2,"size") then dest = arg2 else return "mv: error: output file object does not exist"+char(10)+
		"-- please purge this object, recreate the file, or supply a string instead"
	else 
		dest = globals.get_file(arg2)
	end if
	if not dest then
		if typeof(arg2) == "string" then 
			split = arg2.split("/")
			final_name = split.pop
		else 
			return "mv: invalid parameters"
		end if
		if DEBUG then print("mv_split: "+split)
		if split.len and split[0] == "" then dest = globals.get_file(split.join("/")) else dest = globals.get_file(split.join("/"))
		if DEBUG then print("dest: ["+dest+"]")
		if not dest then
			if arg2[0] == "/" then destination = "/" else destination = currentPath
		else
			destination = dest.path
		end if
	else
		if dest.is_folder and not ow_fldr then
			destination = dest.path
			final_name = file.name
			if dest.path == file.path then destination = dest.parent.path
		else
			destination = dest.parent.path
			final_name = dest.name
		end if
	end if
	if final_name == "@" then final_name = file.name
	//if destination == "/" then print "mv: "+file.path+" -> "+destination+final_name+"..." else print "mv: <u>"+colorWhite+file.path+" -> "+destination+"/"+final_name+"..."
	slash = "/"
	if destination == "/" then slash = "" 
	print "mv: <u>"+colorWhite+file.path+" -> "+destination+slash+final_name
  return file.move( destination, final_name )
end function
command.cp = function(arg1, arg2=0, arg3=0, arg4=0)
  if arg1 == 0 or arg2 == 0 or arg1 == "-h" or arg1 == "help" then return "COPY || copy files || CP"+char(10)+
  "Usage: cp [/old_path] [/new_path] -- copy file or folder to new_path "+char(10)+
  "Usage: cp [/old_path] [@] -- copy old path to current path and use original file name"+char(10)+
  "Usage: cp [/old/path] [/newpath/newname] -- make a copy of a file with a new name/path"+char(10)+
  "Usage Example:"+char(10)+
  "-- cp /root/file.txt @ "+char(10)+
  "---- copies file.txt to the current directory with name: file.txt"+char(10)+
  "Usage Example:"+char(10)+
  "-- poke /root/haha |  | poke /root/heehee |  | cp /root/haha /root/heehee"+char(10)+
  "---- creates files haha and heehee then copies haha over heehee, overwriting heehee"+char(10)+
  "Usage Example:"+char(10)+
  "-- poke haha |  | grep -p syst / | cp haha"+char(10)+
  "---- create file haha, grep for (system.log) and return file_path, overwrite /var/system.log with haha"
  print "<u>"+colorGreen+"= = = = ="
  file = null
  if typeof(arg1) == "file" then file = arg1 else file = globals.get_file(arg1) 
  if not file then return("cp: can't find " + arg1)
  destination = null
  final_name = null
  dest = globals.get_file(arg2)
  if not dest then
    split = arg2.split("/")
    final_name = split.pop
		if DEBUG then print("split: "+split)
    if split.len and split[0] == "" then dest = globals.get_file(split.join("/")) else dest = globals.get_file(split.join("/"))
		if DEBUG then print("dest: ["+dest+"]")
		if not dest then
      if arg2[0] == "/" then destination = "/" else destination = currentPath
    else
      destination = dest.path
    end if
  else
    if dest.is_folder then
      destination = dest.path
      final_name = file.name
    else
      destination = dest.parent.path
      final_name = dest.name
    end if
  end if
	if final_name == "@" then final_name = file.name
	if destination == "/" then print "cp: "+file.path+" => "+destination+final_name else print "cp: <u>"+colorWhite+file.path+" => "+destination+"/"+final_name+"..."
	print colorGold+"- - - - - - - - - - - - - - - - - - - - - - -"
  return file.copy( destination, final_name )
end function
command.usr = function(arg1, arg2, arg3=0, arg4=0)
	if not arg1 or arg1 == "-h" or arg1 == "help" then return "USR || ADD USER || CHOWN"+char(10)+
	"Usage: usr [opt: -r] [user] [path] -- asign ownership of file at path to user"+char(10)+
	"-- the -r flag applies user ownership recursively"+char(10)+
	"Usage: usr [-a|add] [opt:user] [opt:password] -- add a user to the system"+char(10)+
	"-- omitting user and or password will result in a prompt for these values"+char(10)+
	"Usage: usr [-d|del] [username] [opt:bool 1|0] -- delete a user from the system"+char(10)+
	"-- 0 == do not delete the home folder"+char(10)+
	"-- 1 == delete the home folder"+char(10)+
	"-- any other value results in a prompt"+char(10)+
	"Usage: usr -u [path] -- return owner of file at path"+char(10)+
	"NOTE: It is good practice to run:"+char(10)+
	"|><b> usr -r root / | grp -r root / | rm /etc/passwd | lock </b>"+char(10)+
	"-- for optimal security <u><b>on a rented server"+char(10)+
	"<size=75%>NOTE: for your peace of mind please use "+colorCyan+"lock"+CT+" and "+colorGreen+" kore -s "+char(10)+
	"<size=75%>-- to secure your "+colorGold+"main home"+CT+" pc as"+char(10)+
	"<size=75%>-- this ensures you will not brick your system"+char(10)+
	"<size=75%>---- however if you somehow get Xorg to be removed from .show_procs, it will fail!!!"
	is_recursive = false 
	if arg1 == "add" or arg1 == "-a" then
		if not arg2 then arg2 = user_input("new_user:> ")
		if not arg3 then arg3 = user_input(arg2+" password:> ")
		if arg2 == "" then return "usr: aborting..."
		print "usr: attempting to create user:<b> "+arg2
		uc = localmachine.create_user(arg2, arg3)
		if uc == 1 then return "-- user created" else return uc 
	end if
	if arg1 == "del" or arg1 == "-d" then
		d_user = null
		if not arg2 then d_user = user_input("del_user:> ") else d_user = arg2
		del_home = null
		if arg3 == "0" then del_home = false 
		if arg3 == "1" then del_home = true 
		if del_home == null then 
			del_home = user_input("Delete /home/"+d_user+"? [Y/n] "+char(10)+"||: ",0,1)
			if del_home == "n" then del_home = false else del_home = true
		end if
		ud = localmachine.delete_user(d_user, del_home)
		if ud == 1 then return "usr: deleted user: "+d_user else return ud
	end if
	if arg1.lower == "-r" then 
		arg1 = 1
	end if
	if typeof(arg1) == "string" then 
		if not arg2 then
			check_u = globals.get_file(arg1)
			if typeof(check_u) == "file" then return check_u.owner 
		end if
	end if
	if arg1 == 1 then 
		if not arg3 then return "usr: invalid arguments. please supply a path."
		t_f = globals.get_file(arg3)
		if t_f then return t_f.set_owner(arg2, 1) else return "usr: "+arg3+" not found."
	else 
		if not arg2 then return "usr: "+arg1+" not found <b>or</b> path not supplied."
		t_f = localmachine.File(arg2)
		if t_f then return t_f.set_owner(arg1, 0) else return "usr: "+arg2+" not found."
	end if
	return 0
end function
command.grp = function(arg1, arg2, arg3=0, arg4=0)
	if not arg1 or arg1 == "-h" or arg1 == "help" then return "<u>GROUP || ADD GROUP || CHGRP</u>"+char(10)+
	"Usage: grp [add|del] [group] [user] -- add or remove group to|from user"+char(10)+
	"-- users may multiple groups assigned to them"+char(10)+
	"Usage: grp -u [user] -- returns groups associated with user"+char(10)+
	"Usage: grp -f [path] -- returns group associated with file at path"+char(10)+
	"Usage: grp [opt:-r] [group] [path] -- set group of file at path"+char(10)+
	"-- the -r flag applies the group recursively"+char(10)+
	"-- each file may have only one group"+char(10)+
	"NOTE: It is good practice to run:"+char(10)+
	"|><b> usr -r root / | grp -r root / | rm /etc/passwd | lock </b>"+char(10)+
	"-- for optimal security <u><b>on a rented server"+char(10)+
	"<size=75%>NOTE: for your peace of mind please use "+colorCyan+"lock"+CT+" and "+colorGreen+" kore -s "+char(10)+
	"<size=75%>-- to secure your "+colorGold+"main home"+CT+" pc as"+char(10)+
	"<size=75%>-- this ensures you will not brick your system"+char(10)+
	"<size=75%>---- however if you somehow get Xorg to be removed from .show_procs, it will fail!!!"
	is_recursive = false
	if arg1 == "-f" then 
		if not arg2 or arg2 == "" then return "Usage: grp -f [path]"
		f_t = globals.get_file(arg2)
		if not f_t then return "grp: "+arg2+" not found."
		return f_t.group
	end if 
	if arg1 == "-u" then 
		if not arg2 or arg2 == "" then return "Usage: grp -u [user]"
		return globals.localmachine.groups(arg2)
	end if 
	if arg1 == "add" then
		if not arg2 or not arg3 then return "Usage: grp add [group] [user]"
		return localmachine.create_group(arg3, arg2)
	end if
	if arg1 == "del" then
		if not arg2 or not arg3 then return "Usage: grp del [group] [user]"
		return localmachine.delete_group(arg3, arg2)
	end if
	if arg1 == "-r" or arg1 == "-R" then is_recursive = true
	if is_recursive then
		if not arg3 then return "grp: invalid arguments. Usage: grp -r [group] [path]."
		t_f = localmachine.File(arg3)
		if t_f then return t_f.set_group(arg2, 1) else return "grp: "+arg3+" not found."
	else
		if not arg2 then return "grp: invalid arguments. Usage: grp [group] [path]"
		t_f = localmachine.File(arg2)
		if t_f then return t_f.set_group(arg1, 0) else return "grp: "+arg2+" not found."
	end if
	return 0
end function
command.perms = function(arg1, arg2, arg3=0, arg4=0)
	if DEBUG then print("debug: in perms")
	if (arg1 == "-h" or arg1 == "help") and arg2 == "extra" then return "Q: Perms lock all (aka the <b>lock</b> command): what does it do?"+char(10)+"A: the following:"+char(10)+"perms -R o-rwx /"+char(10)+"perms -R g-rwx /"+char(10)+"perms -R u-rwx /"+char(10)+"if on home computer, does the following to avoid lockout:"+char(10)+"perms g+x /bin/sudo"+char(10)+"perms g+x /bin/psudo"+char(10)+"perms g+x /bin/ssh"+char(10)+"perms g+x /usr/bin/Terminal.exe"+char(10)+"perms g+x /usr/bin/Chat.exe"+char(10)+"perms g+x /usr/bin/Mail.exe"+char(10)+"perms g+x /bin/bash"+char(10)+"perms -r g+x /etc/init.d"+char(10)+"To bypass this and lock down anyway use:<b> perms lock down </b> (use with caution)"+char(10)+"n.b mail and chat are on this list because bugs happen when they are fully locked."+char(10)+"N.B: you may remove any of these actions by commenting out"+char(10)+"-- the appropriate lines in 5hell.5pk > command.perms"+char(10)+"-- each entry will have a <b>command.perms(""g+x"",""path"") entry"
	perms_usage = "<u>CHMOD || PERMISSIONS || PERMS || SECURITY</u>"+char(10)+
		colorWhite+"</b>Usage: perms [opt:-r] [userstring{+|-}permission] [path]"+char(10)+
		"-- opt: -r -- run recursively on all files and folders under [path]"+char(10)+
		colorCyan+"</b>-- userstring: o = other, g = group, u = user/owner"+char(10)+
		"-- {toggle}: [+] = add permission, [-] = remove permission"+char(10)+
		"-- permission: r = read, w = write, x = execute"+char(10)+
		"--eg:<b> perms -r o-rwx / </b> -- remove rwx permissions from 'others' for all files"+char(10)+
		"--eg:<b> perms -r g+x /bin</b> -- add group execute permissions to all files in /bin"+char(10)+char(10)+
		"<color=white>Aliases: presets for common permissions"+char(10)+
		colorGold+"</b>Usage: perms lock [all] -- remove all permissions from all files (alias:<b> lock</b>)"+char(10)+
		"-- "+colorGold+"</b>includes anti-brick technology:"+char(10)+
		colorWhite+"</b>-- perms will check running processes for: "+colorLightBlue+"Xorg"+char(10)+
		colorWhite+"</b>-- if detected, critical binaries will be given: "+colorGold+"</b>g+x"+char(10)+
		colorWhite+"</b>---- if we are home: add "+colorLightBlue+"g+x to:"+char(10)+
		colorWhite+"</b>-- <size=85%> sudo, ssh, Terminal.exe, Chat.exe, Mail.exe, /etc/init.d"+char(10)+
		colorWhite+"</b>-- <size=85%> /bin/bash will also be set if EXPERIMENTAL branch is detected"+char(10)+char(10)+
		"<b>Shortcut:</b> "+colorRed+"</b>lock"+CT+"-- an alias for <b>perms lock all</b>"+char(10)+
		"-- uses "+colorGold+"anti-brick"+CT+" technology"+char(10)+
		"-- lock is a secondary command that uses command.perms(""lock"",""all"")"+char(10)+
		"-- see <b>lock -h</b> for more"+char(10)+
		colorGold+"</b>Usage: perms lock [path] -- lock permissions on an individual file"+char(10)+
		"-- returns the target file as an object"+char(10)+
		"-- dpes not use "+colorGold+"anti-brick"+CT+" technology"+char(10)+
		"<b>Shortcut:</b> "+colorRed+"</b>lock [path]"+CT+"-- an alias for <b>perms lock [path]</b>"+char(10)+
		"-- uses "+colorGold+"anti-brick"+CT+" technology"+char(10)+
		colorGold+"</b>Usage: perms lock [down] -- force locking down"+char(10)+
		"-- explicitly bypass "+colorGold+"anti-brick"+CT+" technology"+char(10)+char(10)+
		colorGold+"</b>Usage: perms unlock [all] -- add o+rwx to all files"+char(10)+
		colorGold+"</b>Usage: perms unlock [path] -- add o+rwx, recursively, to a path"+char(10)+char(10)+
		"Note: it is good practice to run:"+char(10)+
		"-- |><b> usr -r root / | grp -r root / | rm /etc/passwd | lock </b>"+char(10)+
		"-- for optimal security."+char(10)+
		colorGold+"</b>-- you may type:<b> kore -s</b> to have this action performed for you"+char(10)+
		"Extra: perms [-h|help] extra -- view extra help information about this command."
	if arg1 == "-h" or arg1 == "help" then return perms_usage
	if not arg1 then return "usage: perms [opt:-r] [arg] [path]"+char(10)+"usage: perms lock [all|/path]"
	if arg1 == "unlock" then 
		if arg2 == "all" then 
			print "perms: setting all to o+rwx"
			command.perms("-R", "o+rwx", "/") 
			//_ = globals.get_file("/")
			return localmachine.File("/")
		else 
			ulf = globals.get_file(arg2)
			if typeof(ulf) == "file" then 
				print "perms: unlocking: "+ulf.path
				command.perms("-R","o+rwx",ulf.path)
				return ulf
			else 
				return "perms: "+arg2+" not found"
			end if
		end if
	end if
	if arg1 == "lock" then
		lf = "/"
		if arg2 == "all" then 
			if not localmachine.File("/").has_permission("w") then return "perms: lockdown failed: permission denied"
			command.perms("-R", "o-rwx", "/")
			command.perms("-R", "g-rwx", "/")
			command.perms("-R", "u-rwx", "/")
			home = null 

			if is_home == true then
				print(colorBlack+"<mark=red><size=75%><color=yellow>Auto-detected: u r home</mark> -- setting critical binaries to <b>g+x</b>...")
				command.perms("g+x","/bin/sudo")
				command.perms("g+x","/bin/psudo")
				command.perms("g+x","/bin/ssh")
				command.perms("g+x","/usr/bin/Terminal.exe")
				command.perms("g+x","/usr/bin/Chat.exe")
				command.perms("g+x","/usr/bin/Mail.exe")
				command.perms("g+x","/bin/bash")
				command.perms("-R","g+x","/etc/init.d")
				print("<size=75%>perms: rerun with <b>perms lock down</b> to force full lockdown")
			end if
			//
			return colorCyan+"</b><size=75%>perms: lockdown complete"
		end if
		if arg2 == "partial" then 
			command.perms("-R","g+x", "/")
			return "perms: partial lockdown complete"
		end if
		if arg2 == "down" then arg2 = "/"
		lf = globals.get_file(arg2)
		if typeof(lf) == "file" then
			print "perms: locking: <u><b>"+lf.path
			command.perms("-R", "o-rwx", lf.path)
			command.perms("-R", "g-rwx", lf.path)
			command.perms("-R", "u-rwx", lf.path)
			return lf
		else
			return "perms: "+arg2+" not found"
		end if
	end if
	perms = arg1
	pathFile = arg2
	isRecursive = 0
	if arg1.lower == "-r" then
		perms = arg2
		if arg3 and typeof(arg3) == "string" or typeof(arg3) == "file" then pathFile = arg3 else return "perms: invalid path"
		isRecursive = 1
	end if
	file = null
	if typeof(pathFile) == "string" then file = globals.get_file(pathFile)
	if typeof(pathFile) == "file" then file = pathFile 
	if not file then return("perms: can't find " + pathFile)
	output = file.chmod(perms, isRecursive)
	if output then print(output)
	print colorGold+perms+": <size=75%>"+file.path+" "+file.permissions
	return file
end function
command.lock = function(arg1,arg2,arg3,arg4)
	if arg1 == "help" or arg1 == "-h" then return "perms || chmod || lock || security || permissions"+char(10)+
	colorWhite+"Usage: lock [opt: path] -- run <b>perms lock [all|/path]"+char(10)+
	"-- this command is a shortcut for perms lock all / perms lock [path]"+char(10)+
	"-- this command was formerly an alias defined in 5hell.src"+char(10)+
	"-- it is now a sub-command similar to prox and scrub"+char(10)+char(10)+
	"Usage: lock -- lock down all files; uses anti-brick technology"+char(10)+char(10)+
	"Usage: lock [path] -- lock down a specific path; does not use anti-brick"+char(10)+char(10)+
	"See <b>perms -h</b> for more info"
	a = "all"
	if typeof(arg1) == "string" or typeof(arg1) == "file" then a = arg1
	return command.perms("lock",a)	
end function
command.mkdir = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "/" or arg1 == 0 or arg1 == "-h" or arg1 == "help" then	return "Usage: mkdir [/path/new_folder] -- create a new folder in path. path must exist."
	if globals.get_file(arg1) then return "mkdir: "+arg1+" already exists."
	newpath = arg1.split("/")
	new_dir = ""
	if newpath[0] == "" then
		newpath.pull
		new_dir = "/"
	else
		new_dir = currentPath
		if new_dir != "/" then new_dir = new_dir + "/"
	end if
	new_name = newpath.pop
	new_dir = new_dir+newpath.join("/")
	if new_dir == "" then new_dir = "/"
	new_dir = globals.get_file(new_dir)
	if not new_dir then return "mkdir: unable to create "+arg1+": parent folder not found."
	print colorGold+"mkdir: creating "+colorWhite+new_name+"</color> in:</b> "+new_dir.path
	return localmachine.create_folder( new_dir.path , new_name )
	return 0
end function
command.cat = function(arg1, arg2=0, arg3=0, arg4=0)
	if not arg1 or arg1 == "help" or arg1 == "-h" then return "File Contents || cat || what's in that file"+char(10)+
	"Usage: cat ["+colorWhite+"path_to_text_file"+CT+"] -- returns contents of text file or null if read denied"+char(10)+
	"Usage: cat ["+colorLightBlue+"file_object"+CT+"] -- <b>returns</b> contents of piped file object"+char(10)+
	"-- e.g: grep -f passwd | cat "+char(10)+
	"Usage: cat ["+colorOrange+"-n|--noparse"+CT+"] [path|object] -- <b>prints</b> contents of text with with richtext tags escaped "+char(10)+
	"-- ie: it uses the <noparse><noparse> richtext tag"
	file = null
	kittehns = ["=^._.^= S","^·-·^","^• •^","~(^._.)","(^._.^)s","(^..^)S","(^-.-^)","Z(=^.^=)"]
	kittehns.shuffle
	kitteh = kittehns.pop
    no_parse = false
    if arg1 == "-n" or arg1 == "--noparse" then 
        no_parse = true 
        arg1 = arg2
        arg2 = arg3 
        arg3 = arg4
    end if
	print "<u>"+colorGold+"- - - - - - - - - c a t - - - - - - - -"+char(10)+
			    colorGold+"                 "+kitteh+"              "
	if typeof(arg1) == "file" then
		file = arg1
	else
		if typeof(arg1) == "string" then
			if arg1 == "" or arg1 == " " then return "cat: file not found."
			if arg1.indexOf(char(10)) != null then return "cat: invalid input"
			file = globals.get_file(arg1)
			if not file then return ("cat: "+arg1+" not found")
		else
			return "cat: expected path or file_object, got "+arg1
		end if
	end if
	if file.is_binary then return ("Cannot open binary file: "+arg1)
	if no_parse then print file.get_content.noparse else return file.get_content
	return 0
end function
command.run = function(arg1, arg2, arg3=0, arg4=0)
	if DEBUG then print("debug: arg1: "+arg1+ " :end arg1")
	if not @arg1 then return "run: usage: run [path] [opt:params|shell] [opt:shell]"
	if @arg1 == "help" or @arg1 == "-h" then return "run || launch || shell.launch || execute || script || binary"+char(10)+
	colorMagenta+"Usage: </b>run [file|path_to_file] [opt:parameters|shell] [opt:shell]"+char(10)+
	"-- launch a script binary at path (.exe's not supported outside of experimental branch)"+char(10)+
	"-- there is a game imposed max 14 nested launches before stack call error"+char(10)+
	"---- the <b>stack_pool</b> in the custom object counts the number of nested launches"+char(10)+
	"-- piped file objects are launched from the object's path"+char(10)+
	"-- if you wish to launch a binary on another shell object:"+char(10)+
	"---- either:"+char(10)+
	"------ glasspool into that shell object before using run"+char(10)+
	"---- or:"+char(10)+
	"-- pipe in a shell object;"+char(10)+
	colorOlive+"--eg: </b>brutus | "+colorMagenta+"run /root/rkit/5hell"+char(10)+
	colorOlive+"--eg: </b>brutus | "+colorMagenta+"run /root/rkit/5hell "" rshell @home """+char(10)+
	"---- this will launch the binary using that shell object"+char(10)+
	"-- pipe or wrap in floating quotes complex launch params (more than one word)"+char(10)+
	"-- use echo and/or easy clip (@a,@b,@c) or <b>""</b> floating quotes <b>""</b> "+char(10)+
	colorOlive+"---- eg: "+colorMagenta+"run /bin/credi7"+char(10)+
	colorOlive+"---- eg: </b>zap | "+colorMagenta+"run /root/crowsploit"+char(10)+
	colorOlive+"---- eg: </b>echo "" do 1 -f pwn.bat "" | clipa | clipb @B 1 || "+colorMagenta+"run /home/guest/rkit/5hell @a @b"+char(10)+
	colorOlive+"---- eg: </b>echo rshell 1.1.1.1 | clipa || brutus | "+colorMagenta+"run /root/rkit/5hell @a"+char(10)+
	colorOlive+"---- eg: </b>ssh notroot@boot 192.168.0.2 | "+colorMagenta+"run /root/rkit/5hell "" brutus | rclean "" "+char(10)+char(10)+
	colorWhite+"</b>New: you may now launch binaries by path, without prepending the path with 'run'"+char(10)+
	"-- this is to give it more bash-like functionality"+char(10)+
	colorMagenta+"-- eg: </b>/bin/echo "" this is new "" @B -m"
	"Note: run supports pshells with the launch function however p_shells are not currently in game"
	if typeof(@arg1) != "string" and typeof(@arg1) != "file" then return "run: arg1 should be file object or path to file" 
	parameters = ""
	rr = colorMagenta+"</b>run:"+colorWhite+"</b> launching external program..."
	if typeof(@arg2) == "shell" then
		if typeof(@arg3) == "string" then parameters = arg3 else parameters = ""
		if typeof(arg1) == "string" then 
			globals.stack_pool("up")
			print rr
			print colorWhite+"</b>-- on target shell"
			cc = arg2.launch(arg1, parameters)
			globals.stack_pool("down")
			_cascade // exit if cascade
			return cc
		end if
		if typeof(@arg1) == "file" then 
			globals.stack_pool("up")
			print rr
			print colorWhite+"</b>-- on target shell"
			cc = arg2.launch(arg1.path, parameters)			
			globals.stack_pool("down")
			_cascade // exit if cascade
			return cc
		end if
		return "run: arg1 should be file or path to file"
	end if
	if typeof(@arg3) == "shell" then 
		run_path = null
		if typeof(arg1) == "string" then run_path = arg1
		if typeof(arg1) == "file" then run_path = arg1.path
		if typeof(run_path) != "string" then return "run: arg1 should be file object or path to file"
		if typeof(arg2) == "string" then parameters = arg2
		if typeof(arg2) == "file" then return "run: arg2 should be string (params) or shell object"
		globals.stack_pool("up")
		print rr
		print colorWhite+"</b>-- on target shell"
		cc = arg3.launch(run_path, parameters)
		globals.stack_pool("down")
		_cascade // exit if cascade
		return cc
	end if
	if arg2 == "ssh: failed" or arg3 == "ssh: failed" then return "run: input shell is not a shell, received:"+char(10)+"ssh: aborting..."
	file = arg1
	if typeof(file) != "file" then file = globals.get_file(arg1)
	if not file then return "run: "+arg1+" not found."
	parameters = ""
	if typeof(@arg2) == "string" then parameters = arg2
	//if arg3 and typeof(arg3) == "string" then parameters = parameters + " " + arg3 
	//if arg4 and typeof(arg4) == "string" then parameters = parameters + " " + arg4 
	if DEBUG then print("run: "+file.path+", "+parameters)
	globals.stack_pool("up")
	print rr
	if GLASSPOOL then print "-- via "+colorLightBlue+"<size=75%>GLASSPOOL"
	cc = shell.launch(file.path, parameters)
	globals.stack_pool("down")
	_cascade // exit if cascade
	return cc
end function
command.scribus = function(arg1=0, arg2=0, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "Scribus Terminal Text Editor by Plu70"+char(10)+"scribus [path_to_file] -- open terminal text editor on file at path"+char(10)+"Advanced: scribus @clipa|@clipb|@clipc -- This edits the clipboard directly."+char(10)+"Advanced: scribus @cc -- edit the command buffer."+char(10)+"Advanced: scribus [file_object] -- text only, open contents of piped object."+char(10)+"Advanced: scribus @do -- edit the do buffer (to write / edit <b>do</b> scripts without launching them)"+char(10)+"-- see <b>do -h</b> for more info"+char(10)+"Note: you may press <b>@h</b> on a new line to get additional command info within the editor."
	p = arg1
	if not p then
		print(":> "+colorCyan+"/relative/path/to/file"+CT+" - open a text file in the editor")
		print(":><b> @clipa | @clipb | @clipc </b>- edit clipboards in the editor"+char(10)+":><b> @do </b>- edit do command buffer (without running do)"+char(10)+":> @cc edit command buffer"+char(10)+"press <return> to abort.")
	end if
	if p == 0 then p = user_input("Scribus:> ")
	if p == "" then return "aborting..."
	if p == "@cc" then
		print("Editing the command buffer...")
		globals.command_buffer = globals.scribus(globals.command_buffer).split(char(10))
		return 0
	end if
	if typeof(p) == "file" then return globals.scribus(p)
	if p == "@clipa" then return command.clipa(globals.scribus(command.clipa))
	if p == "@clipc" then return command.clipc(globals.scribus(command.clipc))
	if p == "@clipb" then return command.clipb(globals.scribus(command.clipb))
	if p == "@do" then
		if not globals.clip_board_delta then globals.clip_board_delta = []
		globals.clip_board_delta = globals.scribus(globals.clip_board_delta)
		print("do: clipped: "+char(10)+colorBlack+"*"+CT+char(10)+globals.clip_board_delta)
		return globals.clip_board_delta
	end if
	if typeof(p) == "string" then
		f = localmachine.File(p)
		if not f then f = localmachine.File(currentPath+"/"+p)
		if not f then f = localmachine.File(currentPath+p)
		if not f then return "scribus: "+p+" not found. "
		return globals.scribus(f)
	end if
	return 0
end function
command.games = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "-h" or arg1 == "help" then return "games: battleship and blackjack and drugwars!"
	print("[0] Battleship")
	print("[1] Battleship - AI vs AI")
	print("[2] Blackjack  - jokers wild")
	print("[3] Drugawars")
	print("[4] Back")
	pick = user_input("||: ",0,1)
	if pick == "0" then return bat("")
	if pick == "1" then return bat("-s")
	if pick == "2" then return g2
	if pick == "3" then return g3
	return 0
end function
command.mail = function(arg1=0, arg2=0, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return colorGreen+"<u></color>"+colorGold+"Mail || metaMail || herme5 || hermes || mail client"+char(10)+
	"herme5 mail client: its the mail (wip) -- its good enough but you may want to write your own;"+char(10)+
	"-- name your function<b> command.mail </b> to overwrite this one."+char(10)+
	"-- see 5hell.src, template.5pk.src for instructions."+char(10)+
	"Note: You may overwrite any command this way."+char(10)+char(10)+
	colorGold+"- - - - - - - - - - - - - - - - - - - - - - - - - - - -"+char(10)+
	colorGreen+"Usage: mail -- opens the herme5 mail menu"+char(10)+
	"Extra: when prompted for a password you may enter:</b> -brutus"+char(10)+
	"-- this will invoke <b>brutus</b> and attempt to crack the email password."+char(10)+
	"-- the password will be saved to the custom object as:"+char(10)+
	"-- key == password and value == public_ip:local_ip"+char(10)+
	"---- this will change once i work out a better storage system bc this is not ideal"+char(10)+
	"-- you will be prompted to choose between the tables/tp folder on file, or"+char(10)+
	"---- the currently loaded onboard dictionary"+char(10)+
	"-- see: <b>brutus -h and cerebrum -h</b> for more"+char(10)+
	"Extra: when viewing your inbox you may type <b>spool</b> to dump all mail to a file (up to 160kb)"+char(10)+char(10)+
	colorGreen+"Usage: "+colorGold+"mail "+CT+"["+colorGold+"email"+CT+"] ["+colorGold+"password</color>|"+colorWhite+"-brutus"+CT+colorGreen+"</b>] "+char(10)+
	"-- log into or crack the given email"+char(10)
        herme5 = function()
            mail = {}
            mail.meta = null  // metaMail object
            if globals.inbox then mail.meta = globals.inbox
            mail.data = null
            if globals.inbox then mail.data = mail.meta.fetch
            mail.user = null
            if globals.inbox then mail.user = globals.mail_user
            mail.pass = null
            if globals.inbox then mail.pass = true
			mail.a1 = outer.arg1 
			mail.a2 = outer.arg2
          
            mail.pwn = function(arg)
              dsize = globals.dict_a.len
              mode = user_input("[<b>0</b>] Onboard Dictionary -- [1] /root/tables/tp "+char(10)+"||: ",0,1)
              if mode == "0" or mode == "" then
                reverse_it = user_input("[<b>0</b>] start at dict_a[0]  --  [1] start at dict_a[-1] "+char(10)+"(type [q] abort) ||: ",0,1 )
                if reverse_it.lower == "q" then return "aborting..."
				if reverse == "1" then reverse_it = 1 else reverse_it = 0
                show_count = user_input("Show the count? ["+dsize+"] [y/<b>N</b>] ||: ",0,1)
                show_pass = user_input("Show passwords? [y/<b>N</b>] ||: ",0,1)
                if show_pass.lower == "y" then show_pass = true else show_pass = false
                if show_count.lower == "y" then show_count = true else show_count = false
                print(colorGold+"Accessing onboard dictionary..."+CT+char(10)+"<align=center><<>></align>")
                ds = dsize - 1
                for p in range( 0, ds )
                  dsize = dsize - 1
                  if reverse_it then pa = globals.dict_a[0 - p] else pa = globals.dict_a[p]
                  if show_count then print(colorGold+colorWhite+"["+CT+dsize+colorWhite+"]"+CT+CT)
                  if show_pass then print(colorGold+colorWhite+"["+CT+pa+colorWhite+"]"+CT+CT)
                  try = mail_login(arg, pa)
                  if typeof(try) == "MetaMail" then
                    print("brutus: <b>password found</b>: "+colorWhite+pa+CT)
					print command.cob("set",pa,arg)
                    return try
                  end if
                end for
              else
                if mode == "1" then
                  tp = localmachine.File("/root/tables/tp")
                  if not tp then return 0
                  print(colorGold+"Accessing /root/tables/tp..."+CT+char(10)+"<align=center><<>></align>")
                  tp_f = tp.get_files
                  i=0
                  for f in tp_f
                    i = i + 1
                    print(i+"/"+(tp_f.len))
                    chunc = f.get_content.split(char(10))
                    for p in chunc
                      try = mail_login( arg, p )
                      if typeof(try) == "MetaMail" then
                        print("brutus: <b>password found</b>: "+colorWhite+p+CT)
						print("brutus: accessing cob: saving password as key, email as value")
						print command.cob( "set", p, arg)
                        return try
                      end if
                    end for
                  end for
                end if
              end if
              return 0
            end function
          
			_is_mail = function(strng)
				if typeof(strng) == "string" and strng.indexOf("@") != null then return 1 else return 0 
			end function
            mail.Login = function()
              if globals.inbox then
                mail.meta = globals.inbox
                return mail.user+" is already logged in."
              end if
              if _is_mail(mail.a1) then mail.user = mail.a1 else mail.user = user_input("email:> ")
              if mail.user == "" or mail.user == " " then mail.user = user_mail_address
              if not mail.user then return "Invalid mail address."
              print("Enter <b>-brutus</b> to crack password with brutus.")
              if _is_mail(mail.a1) and mail.a2 then mail.pass = mail.a2 else mail.pass = user_input(mail.user+" pass:> ", 1)
              if mail.pass == "" or mail.pass == " " then return "Invalid login credentials."
              if mail.pass == "-brutus" then
				print "herme5: calling brutus..."
                mail.meta = mail.pwn(mail.user)
              else
				print "herme5: loging in: "+mail.user+"..."
                mail.meta = mail_login(mail.user, mail.pass)
              end if
          
              if typeof(mail.meta) == "MetaMail" then
                globals.inbox = mail.meta
                globals.mail_user = mail.user
                return "Login complete."
			  else 
				print mail.meta
              end if
              return "Invalid login credentials."
            end function
            mail.get_id = function(arg)
              ds = mail.data[arg].split(char(10))
              i = ds[2].split(" ")
              i = i[1]
              return i
            end function
            mail.Fetch = function()
              if typeof(mail.meta) != "MetaMail" then return "Invalid login credentials."
              mail.data = mail.meta.fetch
              return "Fetching mail for: "+mail.user+"..."+char(10)
            end function
            mail.Read = function()
              if typeof(mail.meta) != "MetaMail" then return "Invalid login credentials."
              print(mail.Fetch)
              print(mail.data_stream(mail.data))
			  r = null 
			  if mail.a1 == "spool" then r = "spool" else r = user_input("Enter an index to read or type <b>spool</b> to dump to a file :> ").to_int
              print(colorGold+"- - - - - - - - - - - - - - - - - - - - - - - - - - "+CT)
			  if mail.data.len < 1 then return "herme5: mailbox is empty"
			  spool_buf = []
			  spooling = false
			  if r == "spool" then 
				spooling = true
			  	r = mail.data.len - 1
			  end if
			  while r >= 0
				if r >= 0 and r < mail.data.len then
					read_this = mail.meta.read(mail.get_id(r))
					if spooling then print "<size=80%>herme5: spooling: ["+colorWhite+r+CT+"]" else print(read_this)
					if spooling then spool_buf.push(read_this+char(10))
					if read_this.split(char(10))[2] == "Subject: *" then
						print(colorLightBlue+"<u><mark=#DF8600>= = = = = = = = = = = = = = = = = = = = = = = = = = = = =</mark></u>"+CT)
						print(command.code("-b", read_this[read_this.indexOf("Subject: *")+11:]))
					end if
				end if
				if spooling then r = r - 1 else r = -1
			  end while
			  if spooling then 
			  	st = time
			  	if typeof(mail.a2) == "string" then spool_file_path = mail.a2 else spool_file_path = user_input( colorGold+"herme5: please enter a path for the spool file: "+char(10)+"[/path, <<b>enter</b>=home_dir/spool.txt, </b>q</b>=quit]:> " )
				if spool_file_path.lower == "q" or spool_file_path.lower == "quit" then return "aborting..."
				if spool_file_path == "" or spool_file_path == " " then spool_file_path = homePath+"/spool.txt"
				spool_file = globals.get_file(spool_file_path)
				if typeof(spool_file) != "file" then print "herme5: could not locate spool file."+char(10)+"herme5: creating: "+spool_file_path else print "herme5: spool file found; overwriting"
				if typeof(spool_file) == "file" and spool_file.is_binary then return "herme5: cannot spool to binary file"
				print colorWhite+"<size=80%>Saving data to spool file: <b>"+spool_file_path
				if DEBUG then print "debug: spool_buf is: "+spool_buf+" and is a "+typeof(spool_buf)
				spool_file = command.poke("-f",spool_file_path, current_date+char(10)+char(10)+spool_buf.join(char(10))+char(10)+current_date)
				if typeof(spool_file) != "file" then return "herme5: error: check write permissions"
				globals.BUFFER.push(spool_file)
				wait(.1) 
				ttt = time - st
				print colorGold+"herme5: "+CT+"spool_file object sent to "+colorOrange+"BUFFER"+CT+char(10)+colorGold+"</b>herme5: task completed in <b>"+ttt+"</b> seconds."
			  end if
              return "returning..."
            end function
            mail.Write = function()
              if typeof(mail.meta) != "MetaMail" then return "Invalid login credentials."
              addr = user_input("address:> ")
              subj = user_input("subj:> ")
              mbuf = []
              send = ""
              body = globals.scribus(mbuf)
              munin = user_input(colorLightBlue+"Encode with <mark=black>M</mark>unin<mark=black>C</mark>ipher before sending? [Y/n] ||: "+CT,0,1)
              if munin.lower != "n" then
                send = command.code("-a",body)
                subj = "*"
              else
                send = body
                print(colorGreen+"<u>= = = = = = = = = = = = = = = = = = = = = = = = = = = = =</u>"+CT)
              end if
			  if DEBUG then print "debug: addr: "+addr+char(10)+"-- subj: "+subj+char(10)+"-- send: "+send
              return mail.meta.send( addr, subj, send )
            end function
            mail.Delete = function(r=0)
              if typeof(mail.meta) != "MetaMail" then return "Invalid login credentials."
              print(mail.Fetch)
              print(mail.data_stream(mail.data))
              if not r then r = user_input("delete [*=all,<enter>=quit]:> ").to_int
			  if r and r == "*" then
				for m in range(0,mail.data.len - 1)
					mail.meta.delete( mail.get_id(m) )
			  	end for 
				print colorOrange+"All emails deleted!"
				return mail.Fetch
			  end if
              if typeof(r) == "number" and mail.data.hasIndex(r) then
                id = mail.get_id(r)
                if id then print("Deleting (crt+c to cancel): "+id+"...")
                wait(.5)
                print("in 3...")
                wait(1)
                print("2...")
                wait(1)
                print(mail.meta.delete( id ))
                return mail.Fetch
              else
                return "aborting..."
              end if
              return 0
            end function
            mail.Widget = function()
              if typeof(mail.meta) != "MetaMail" then return "Invalid login credentials."
              if HERMES == true then
                globals.HERMES = false
                wState = "off"
              else
                globals.HERMES = true
                wState = "on"
                globals.this_mail = user_input("Configuring widget..."+char(10)+"pin_mail_# (default: 0 for newest):> ").to_int
                mail.data = mail.meta.fetch
                if typeof(globals.this_mail) == "number" and globals.this_mail >= 0 and globals.this_mail < mail.data.len then
                  print(colorGold+"Pinned: "+colorWhite+globals.this_mail+colorGold+"."+CT+char(10)+colorGold+"Herme5 mail widget configured."+CT)
                else
                  print(colorGold+"Defaulting to: "+colorWhite+"0"+colorGold+"."+CT+char(10)+colorGold+"Herme5 mail widget configured."+CT)
                  globals.this_mail = 0
                end if
              end if
              return "Herme5 mail widget toggled "+wState+"."
            end function
            mail.Exit = function()
              return "herme5: exiting..."
            end function
            mail.data_stream = function(alist)
              d = ""
              i = 0
              for el in alist
                d = d + "[" +colorWhite+ i +CT+ "] " + el + char(10)
                i = i + 1
              end for
              return d
            end function
            mail.menu = function()
              mailing = true
              menu_options = ["Exit", "Login", "Fetch", "Read", "Write", "Widget", "Delete"]
              while mailing
                print(colorGold+"- - - - - - - Herme5 v 0.4.5 by Plu70 - - - - - - - - "+CT)
				print colorGold+"- - - - - - [ </b><u>"+colorWhite+mail.user+"</color></u> ]</b> - - - - - -"
				opt = 0
				if _is_mail(mail.a1) then opt = 1 
				if mail.a1 == "spool" then opt = 3
				if not opt then 
					mail.a1 = 0
					print(mail.data_stream(menu_options))
					opt = user_input("(q=quit)||: ",0,1).to_int
			  	end if
                print(colorGold+"- - - - - - - - - - - - - - - - - - - - - - - - - - "+CT)
                if opt == "q" then opt = 0
                if opt < 0 or opt > menu_options.len-1 or typeof(opt) != "number" then continue
                mm = @mail[menu_options[opt]]
                print(mm)
				if mail.a1 != 0 then return "herme5: returning..."
                mailing = opt
              end while
              return mailing
            end function
            return mail.menu
          end function
	return herme5
end function
command.fwr = function(arg1, arg2, arg3=0, arg4=0) 
	if GLASSPOOL then print(colorOrange+"fwr: ignores glasspool."+CT)
	if arg1 == "help" or arg1 == "-h" then return "Usage: fwr [ip] -- returns firewall rules for ip. returns local rules if no ip given."
	if not localmachine.is_network_active then return "fwr: no network connection"
	router = get_router
	if typeof(router) != "router" then return "fwr: router not found"
	if arg1 and is_valid_ip(arg1) then
		router = get_router(arg1) 
		if DEBUG then print "debug: router is a: "+typeof(router)
		if typeof(router) != "router" then return "fwr: router not found"
	end if
	if DEBUG then print "debug: router is a: "+typeof(router)
	return router.firewall_rules
end function
command.memdump = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "memdump: dump MEMORY, XPLOITS, PORT_MAP, clipboards,  to current_path+/memdump.mx"+char(10)+"n.b. ignores glasspool. main purpose is generating reports for clients."
	return globals.dump_memory
end function
command.enum = function(arg1, arg2=0, arg3=0, arg4=0)
	if not arg1 or arg1 == "help" or arg1 == "-h" then return "<b><u>enumeration || ENUM || enum buffer"+char(10)+
	"Use this to put things in a list."+char(10)+
	colorLightBlue+"</b>Usage: enum [opt|/path|file_object|array|#]"+char(10)+
	colorWhite+"</b>Usage: enum [list|map|string] -- enumerates a list or a newline separated string"+char(10)+
	"-- if the string is a single word it will be interpreted as a path"+char(10)+
	"-- multiple words on a single line (piped) will be interpreted as a single entry"+char(10)+
	"-- use enum -a [word] to add a single word to the enum buffer"+char(10)+
	"-- lists and maps will be enumerated by element"+char(10)+
	colorWhite+"</b>Usage: enum [path|file_object]"+char(10)+
	"-- enumerate file contents as a list of strings"+char(10)+
	"-- useful for 5hell scripting (see the '<b>do</b>' command)."+char(10)+
	"-- e.g: enum file.txt | enum 1"+char(10)+
	"-- use enum -a [file] to add a single file to the enum buffer"+char(10)+
	"---- enumerate file.txt then return index [1] from the list"+char(10)+
	"Usage: enum [-l]  -- return the length of enum buffer."+char(10)+
	"Usage: enum [-s]  -- show the enum buffer and return the length"+char(10)+
	"Usage: enum [-d]  -- enumerate the onboard dictionary"+char(10)+
	"Usage: enum [#] -- return the element at index # in the enum buffer"+char(10)+
	"UsagE: enum -r [index] -- remove the element at index"+char(10)+
	colorGreen+"Usage: enum -i [index] [element] -- insert element at index "+char(10)+
	"-- shifts everything below it down"+char(10)+
	colorGreen+"Usage: enum -a [element] -- append element to end of enum buffer"+char(10)+
	"-- unlike enum [string] you may use enum -a [string] to append a single word to the enum buffer"+char(10)+
	"Usage: enum [-e] -- return the enum buffer as a list"+char(10)+
	"Usage: enum [-b]  -- concatonate the BUFFER and globals.enumerated (the enum buffer)"+char(10)+
	"Usage: enum [-p] -- purge the enum buffer"+char(10)+
	"Advanced: poke files.txt | lock |  | ls | append files.txt | cat files.txt | clipb | enum"+char(10)+
	"-- Or: ls | enum -- pipe ls output to the enum buffer"+char(10)+
	"Advanced: lanpro | enum -- scan network and enumerate all LAN addresses found. "+char(10)+
	"Note: limited map support"
	if arg1 == null then return 0
	if not arg1 or arg1 == "0" then
		if globals.enumerated.len then return globals.enumerated[0] else return 0
	end if
	if arg1 == "-r" then 
		if not arg2 then return "enum: -r expects an index"
		if typeof(arg2.to_int) != "number" then return "enum: invalid index"
		if globals.enumerated.hasIndex(arg2.to_int) then 
			globals.enumerated.remove(arg2.to_int)
			return "enum: entry at index "+arg2+" removed"
		else 
			return "enum: invalid index"
		end if
	end if
	if arg1 == "-b" then 
		if globals.enumerated.len < 1 then return "enum: enumerated buffer is empty"
		print "enum: <b>appending enumerated buffer to main BUFFER</b>"
		globals.BUFFER = globals.BUFFER + globals.enumerated
		return 0
	end if 
	if arg1 == "-p" then 
		globals.enumerated = []
		return "enum: "+colorOrange+" enum buffer purged"
	end if
	if arg1 == "-i" then 
		if not arg3 then return "enum: -i [index] [element]"
		buf_bak = globals.enumerated
		if typeof(arg2) != "string" then return "enum: -i expects string index"
		if typeof(arg3) != "string" and typeof(arg3) != "list" then return "enum: -i [index] [string|list]"
		dx = arg2.to_int
		sbb = null 
		if typeof(arg3) == "list" then sbb = arg3 
		if typeof(arg3) == "string" then sbb = arg3.split(char(10))
		if typeof(dx) != "number" or dx >= buf_bak.len or dx < 0 then return "enum: invalid index"
		sli_1 = buf_bak[0:dx]
		sli_2 = buf_bak[dx:]
		new_buf = sli_1 + sbb + sli_2
		return "enum: element inserted at index "+dx
	end if
	if arg1 == "-a" then 
		if not arg2 then return "enum: append failed: missing input"
		sb = ""
		if typeof(arg2) == "list" then sb = arg2
		if typeof(arg2) == "string" then sb = arg2.split(char(10))
		if sb == "" then return "enum: append failed: invalid type: expects string or list"
		globals.enumerated = globals.enumerated + sb
		return "enum: list appended"
	end if
	if arg1 == "-d" then
		globals.enumerated = globals.dict_a[0:]
		print("enum: <b>onboard dictionary enumerated</b>. Num entries:")
		return globals.enumerated.len
	end if
	if arg1 == "-l" then return str(globals.enumerated.len)
	if arg1 == "-s" then
		if not globals.enumerated.len then return 0
		ie = 0
		for ge in globals.enumerated
			print("["+ie+"] " + ge)
			ie = ie + 1
		end for
		return globals.enumerated.len
	end if
	if arg1 == "-e" then
		return globals.enumerated
	end if
	if typeof(arg1) == "list" then 
		globals.enumerated = arg1
		return "enum: list enumerated"
	end if
	if typeof(arg1) == "map" or typeof(arg1) == "custom_object" or typeof(arg1) == "shell" or typeof(arg1) == "computer" or typeof(arg1) == "file" then
	globals.enumerated = []
		for a in arg1
			globals.enumerated.push(a)
		end for
		return "enum: map <b>enumerated.</b>"
	end if
	if typeof(arg1) == "number" then arg1 = str(arg1)
	if typeof(arg1) == "string" and typeof(arg1.to_int) == "number" then
	 	if globals.enumerated.hasIndex(arg1.to_int) then return globals.enumerated[arg1.to_int] else return "enum: error: invalid index"
	end if
	if typeof(arg1) == "string" then
		if arg1.split(char(10)).len > 1 or arg1.split(" ") > 1 then // more than one line or more than one word, otherwise it's a path
			globals.enumerated = arg1.split(char(10))
			for el in globals.enumerated
				if el == "" then
					globals.enumerated.remove(globals.enumerated.indexOf(el))
					continue
				end if
				globals.enumerated[globals.enumerated.indexOf(el)] = el.replace(char(32),"").trim
			end for
			return "enum: entry <b>enumerated.</b>"
		end if
		file = null
		file = globals.get_file(arg1)
		if not file then return "enum: error: "+arg1+" not found."
		arg1 = file
	end if
	if typeof(arg1) == "file" then
		print("enum: purging...")
		globals.enumerated = []
		if arg1.is_binary then return "enum: can't open binary file" else stuff_buf = arg1.get_content
		if stuff_buf then globals.enumerated = stuff_buf.split(char(10)) else return "enum: error: file empty or read protected."
		return "enum: "+arg1+" <b>enumerated.</b>"
	end if
	return "enum: error: unknown type"
end function
command.rclean = function(arg1, arg2=0, arg3=0, arg4=0)
	if @arg1 == "help" or @arg1 == "-h" then return "Remote Clean || log scrubber || system.log cleaner"+char(10)+
	"Copy a file over the system.log to corrupt it"+char(10)+
	"Usage: rclean [opt: int ] -- select an object from buffer to atttempt a remote log wipe."+char(10)+
	"Usage: rclean [file|shell|computer] -- remote wipe piped object"+char(10)+
	"-- e.g. clipb @B 1 | rclean -- where BUFFER[1] was a file|shell|computer"+char(10)+
	"-- rclean with no params will display a menu "+char(10)+
	"-- rclean is intended for remote scrubbing using BUFFER objects."+char(10)+
	"-- However you may use silentclean or rclean for local log scrubbing"+char(10)+
	"-- if rclean detects a file named <b>silentclean</b> it will use that file to scrub the log"+char(10)+
	"-- for this reason it is a good idea to include an empty file named silentclean in the rkit"+char(10)+
	"-- or, rename an empty system.log file to silentclean"+char(10)+
	"---- or, a not so empty system.log file..."+char(10)+
	"Usage: rclean -d [#|shell|file|computer] -- run rclean as above and delete rkit and/or 5hell, if present"+char(10)+
	"Usage: rclean -n [#|shell|file|computer] -- run rclean as above and delete the contents of /boot, if present"
	if arg1 == "-d" then 
		arg1 = arg2
		arg2 = "-d"
	end if 
	if arg1 == "-n" then 
		arg1 = arg2 
		arg2 = "-n"
	end if
	//if not arg1 then arg1 = globals.shell
	if DEBUG then print ("<b>in rclean: obj: "+typeof(@arg1)+" opt: "+@arg2)
	if arg1 and (typeof(arg1) == "shell" or typeof(arg1) == "ftpshell" or typeof(arg1) == "computer" or typeof(arg1) == "file") then return globals.rclean(arg1,arg2)
	//if arg1 and typeof(arg1.to_int) == "number" then return globals.rclean(command.clipb("@B",arg1),arg2)
	if arg1 and typeof(arg1.to_int) == "number" then return globals.rclean( globals._ez_clip(["@B",arg1]), arg2)
	//return globals.rclean(command.clipb("@B","-m"),arg2)
	
	return globals.rclean( globals._ez_clip(["@B","-m"]), arg2)
end function
command.ipfit = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "Usage: ipfit -- menu to specify a way to generate ips. (wip)"+char(10)+"Recommendation: pipe the output to a file or to the clipboard."+char(10)+"e.g<b> ipfit | clipb </b>, or<b> ipfit | poke iplist </b>"
	print("Configuring: ")
	print("<b>How do you want to specify ip's? </b>"+char(10)+"[0] - enter manually"+char(10)+"[1] - read from file "+char(10)+"[2] - random")
	print("[3] - specify range"+char(10)+"[4] - from clipb")
	choice = user_input("||: ",0,1).to_int
	ips = []
	if choice == 0 then
		ips = globals.scribus(ips)
		return ips
	end if
	if choice == 1 then
		ips = command.cat(user_input("path_to_file:> "))
		return ips
	end if
	if choice == 2 then
		ips = command.rnip(user_input("# ips to create: "))
		return ips
	end if
	if choice == 3 then
		print("Soon (tm)")
		return "Soon (tm)"
	end if
	if choice == 4 then
		return command.clipb
	end if
	return 0
end function
command.md5 = function(arg1, arg2, arg3=0, arg4=0)
	if not arg1 or arg1 == "help" or arg1 == "-h" then return "MD5SUM || md5 sum || password hash decipher || encode"+char(10)+"Usage: md5 [string] -- returns the md5sum of a string"+char(10)+"Usage: md5 -d [32_char_hash] -- checks hash against onboard dictionary then attempts decipher"+char(10)+"-- defaults to crypto.so if cerebrum is not loaded"+char(10)+"-- one of three main ways to decipher password hash combo's"+char(10)+"-- see also: <b>gopher</b>, <b>hashim</b>, <b>brutus</b>"
	if arg1 == "-d" then
		if not arg2 or typeof(arg2) != "string" or arg2.len != 32 then
			return "[-d] expects 32 character hash string"
		else
			for d in dict_a
				if md5(d) == arg2 then
					print("md5: found: ["+colorWhite+" "+d+CT+" : "+colorGold+arg2+CT+" ]")
					return d
				end if
			end for
			print "gopher: hash not in dictionary"+char(10)+"-- defaulting to crypto.so"
			if crypto then
				rslt = crypto.decipher(arg2)
				if rslt then return rslt
			else 
				print "md5: cryto.so library is not loaded"
			end if
			return "md5: hash not found"
		end if
	end if
	if typeof(arg1) == "string" then return md5(arg1) else return "md5: string required"
end function
command.pipe = function(arg1, arg2, arg3=0, arg4=0)
	return "pipe usage: place <b>|</b> between sets of commands to pipe a commands output"+char(10)+
	"The output of a command can be piped to the input of the following command using a pipe."+char(10)+
	"Examples: "+char(10)+
	"lanpro | enum"+char(10)+
	"ls -la /root | clipb | enum | poke file.txt | lock || clipb | append file.txt"+char(10)+
	"You may chain commands without piping by using <b>||</b> instead"+char(10)+
	"-- eg: command1 || command2 -- output from command1 is NOT passed to command2"
end function
command.do = function(arg1, arg2=0, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then
		if arg2 == "extra" then
			return "<u><mark=red>=============</u></mark>"+char(10)+
			"Setup (copy after the |> and paste into 5hell): "+char(10)+
			"|> clipa 0 | rnip 11 | enum | enum -s | do"+char(10)+
			"Paste this Script : "+char(10)+
			"clipa | enum | probe"+char(10)+
			"clipa ++"+char(10)+
			"Result:"+char(10)+
			"set clipa to 0, produce 11 random ips, enumerate those ips, do 11 loops of: probe enum[clipa], clipa++"+char(10)+
			"-- this runs probe on 11 random ips stored in the enum(eration) buffer using calc and the clipboard to iterate through the list."+char(10)+
			"<u><mark=red>=============</u></mark>"+char(10)+
			"Setup (copy after the |> and paste into 5hell)"+char(10)+
			"|> clipa 1 | ls -a /lib | enum | enum -s | do"+char(10)+
			"Paste this Script : "+char(10)+
			"clipa | enum | db -l"+char(10)+
			"clipa ++"+char(10)+
			"Result:"+char(10)+
			"set clipa to 1, enumerate files in /lib, do [num_files+1] loops, start at 1 and run db (databaser) on each file, the error at the end is because ls returns with an extra blank line which gets enumerated at position [0] resulting in the loop being 1 over."+char(10)+
			"<u><mark=red>=============</u></mark>"+char(10)+
			"(all commands are valid but note interactive commands will still require interaction)"
		else
			return colorGold+"<u>DO || SCRIPTING || AUTOMATION || NOT BASH || BATCH COMMANDS || DORC || BASHRC"+char(10)+
			colorWhite+"</b>The scheduling or automation service for 5hell. You write a set of"+char(10)+
			colorWhite+"</b>commands for 5hell to <b>do</b>. Commands may be entered in-line on the"+char(10)+
			colorWhite+"</b>command line, entered into a text editor buffer, or read from a text file."+char(10)+
			colorWhite+"</b>see also: do help extra -- for some example do scripts"+char(10)+
			colorGold+"</b>-- see also: <b>help prompt</b>, <b>dig -h</b>, <b>scribus -h</b>"+char(10)+
			colorWhite+"</b>Do may be launched in a number of ways, depending on your goals:"+char(10)+char(10)+
			colorCyan+"Usage: do [int] [command] [arg1] [arg2]-- perform [command] [int] times"+char(10)+
			colorLightBlue+"</b>-- passes arg1 and arg2 to the command"+char(10)+
			colorLightBlue+"</b>-- use text blocks to pass complex arguments and/or complex commands"+char(10)+
			colorGold+"</b>-- eg: |><b> do 3 "" rnip 1 | probe | db -r | zap "" "+char(10)+
			colorGold+"</b>-- eg: |><b> do 1 poke test.txt "" this is a bunch of text "" "+char(10)+
			colorLightBlue+"</b>---- note: in practice the above line can be done without the <b>do 1</b>"+char(10)+
			colorLightBlue+"</b>---- it's just an example of how you would supply complex parameters to <b>do</b>"+char(10)+
			colorLightBlue+"- - - - - - - - - - - "+char(10)+
			colorCyan+"Usage: do -- without arguments will prompt for iterations then open the editor"+char(10)+
			colorCyan+"Usage: do [#] -- supplying iteration without a command opens the editor immediately"+char(10)+
			colorLightBlue+"</b>-- enter commands into the editor and enter @ on a newline to begin execution"+char(10)+
			colorLightBlue+"</b>-- the commands in the editor remain until changed and therefore may be rerun/reused"+char(10)+
			colorLightBlue+"</b>-- you may use <b>scribus @do</b> to edit the <b>do</b> buffer without firing the script"+char(10)+char(10)+
			colorCyan+"Usage: do [int] -f [/path] -- perform commands in [/path] [int] times"+char(10)+
			colorLightBlue+"</b>-- the preferred method of firing a 'batch' of commands"+char(10)+
			colorLightBlue+"</b>-- many examples may use a .bat extension but the .bat extension is not enforced at all"+char(10)+
			colorLightBlue+"</b>-- it is just a convention, you may name them whatever you wish except:"+char(10)+
			colorLightBlue+"</b>---- dig.bat must be named dig.bat in order for <b>dig</b> to use it (see dig -h)"+char(10)+
			colorGold+"</b>-- nested calls to the do command within these files are valid and encouraged"+char(10)+
			colorGold+"</b>---- dig.bat: cerebrum | brutus | run /home/guest/rkit/5hell "" do 1 -f file2.bat "" "+char(10)+
			colorGold+"</b>---- file2.bat: rshell @home | sc -d | exit rshell_placed"+char(10)+
			colorLightBlue+"</b>-- by placing these two files in your rkit folder and running <b>dig [ip]</b> you are able to:"+char(10)+
			colorLightBlue+"</b>---- automate: infiltrating and placing a root rshell on the target"+char(10)+
			colorLightBlue+"</b>----- removing your rkit"+char(10)+
			colorLightBlue+"</b>----- and cleaning the log"+char(10)+
			colorCyan+"Alias: "+colorWhite+"do 1 -f [path]"+CT+" has been aliased to"+colorWhite+" bat [path]"+CT+" in 5hell.src"+char(10)+char(10)+
			colorCyan+"You may launch 5hell from the game's command line with a 'do' instruction:"+char(10)+
			colorLightBlue+"</b>-- instead of launching 5hell simply by typing '5hell' you may launch with:"+char(10)+
			colorGold+"</b>----# 5hell do [#] [opt:-f] [command|path]"+char(10)+
			colorLightBlue+"</b>-- and 5hell will launch and immediately begin running the given commands"+char(10)+
			colorLightBlue+"</b>-- 5hell will then drop to the exit prompt;"+char(10)+
			colorLightBlue+"</b>---- press 'y' if you wish to exit, press enter or any other key to continue running"+char(10)+
			colorGold+"This allows 5hell to launch 5hell with instructions to launch 5hell with instructions to..."+char(10)+
			colorLightBlue+"</b>-- keep in mind there is a game limit of 15 <u>nested</u> uses of shell.launch"+char(10)+
			colorLightBlue+"</b>-- but no limit to the number of uses of shell.launch; meaning "+colorWhite+"do 1000 dig -s</color></b> is completely valid"+char(10)+
			colorLightBlue+"</b>-- please note that the game does not allow the use of <b>""</b> in launch parameters"+char(10)+
			colorLightBlue+"</b>----<b> 5hell do 1 echo three | echo two | echo one"+char(10)+
			colorLightBlue+"</b>---- will result in 5hell running the three echoes at launch "+char(10)+
			colorLightBlue+"</b>---- if this line were typed at runtime, it would have to be:"+char(10)+
			colorLightBlue+"</b>----<b> do 1 "" echo three | echo two | echo one """+char(10)+
			colorLightBlue+"</b>Note: launching 5hell with <b>do</b> results in 5hell exiting on completion"+char(10)+
			colorCyan+"</b>However:"+char(10)+
			colorLightBlue+"</b>-- you may launch 5hell with params, without do:"+char(10)+
			colorLightBlue+"</b>----<b> 5hell echo three | echo two | echo one"+char(10)+
			colorLightBlue+"</b>---- will result in the same behavior, but 5hell will <b>not exit</b> on completion"+char(10)+char(10)+
			colorGold+"Advanced: Resource Configuration"+char(10)+
			colorCyan+"You may place a file named "+colorWhite+"do.rc</color> in your "+colorWhite+"rkit</color> and/or "+colorWhite+"Config folder"+char(10)+
			colorLightBlue+"</b>-- the contents of the file should look like a standard <b>do</b> script and will be executed on launch"+char(10)+
			colorLightBlue+"</b>-- unlike launching with <b>5hell do 1 -f do.rc</b>, this method will not exit on completion"+char(10)+
			colorLightBlue+"</b>-- do.rc in <b>Config</b> will take priority over do.rc in <b>rkit</b>. This allows a 'home' and 'away' do.rc"+char(10)+
			char(10)+
			colorCyan+"Early Termination:"+char(10)+
			colorLightBlue+"</b>If the final return value of a line in a do script is: "+colorWhite+"@STOP"+CT+", then:"+char(10)+
			colorLightBlue+"</b>-- that iteration will cease, and the next iteration will begin"+char(10)+
			"----: equivalent to a <b>continue</b>"+char(10)+
			colorLightBlue+"</b>If the final return value of a line in a do script is: "+colorWhite+"@RETURN"+CT+", then:"+char(10)+
			"-- the do script will terminate; no further iterations will run"+char(10)+
			"----: equivalent to a <b>break</b>"+char(10)+char(10)+
			colorCyan+"Comments:"+char(10)+
			colorLightBlue+"</b>You may add comments to <b>do</b> scripts. The comment character must be placed"+char(10)+
			colorLightBlue+"</b>on it's own line. Comments place within command strings or at the end will error."+char(10)+
			colorLightBlue+"</b>Valid comment characters are: <b>#, /, and -</b>"+char(10)+
			colorLightBlue+"</b><size=75%>While <b>|</b> will technically work, it might break things down the road if"+char(10)+ 
			colorLightBlue+"5hell.src changes. If a comment character is the first character on a line, <b>do</b> will skip that line."+char(10)+
			colorLightBlue+"Please note that because macros are done in-line, they may not include comments. Please"+char(10)+
			colorLightBlue+"keep this in mind if piping the contents of a do script into a macro definition."

			colorGreen+"As you can see, 5hell is designed to be (almost*) completely automated."+char(10)
			colorGreen+"See Also: macro -h, help conventions, help alias, help automation"
		end if
	end if
	iter = 0
	cmd = []
	if arg1 then
		if typeof(arg1) == "number" then iter = arg1 else iter = arg1.to_int // needs a check for invalid type
	else
		iter = user_input("Number of iterations to run command:"+char(10)+":> ").to_int
	end if
	if not iter or typeof(iter) != "number" then return "do: invalid iteration."
	if arg2 and arg2 != "" then
		if arg2 == "-f" then
			cmd.push(arg2)
		else
			if arg3 then arg2 = arg2 + " " + arg3
			if arg4 then arg2 = arg2 + " " + arg4
			cmd.push(arg2)
		end if
	else
		print("Configure command list: ")
		print("* piped commands go on a single line separated by | ")
		print("* non-piped commands go on a new line ")
		print("* @ on newline to save and execute")
		print("* @@ on newline to abort and quit")
		cmd_hold = command.scribus("@do")
		if cmd_hold then cmd = cmd_hold.split(char(10)) else return "aborting..."
	end if
	if cmd[0] == "-f" then
		if arg3 then
			cf = globals.get_file(arg3)
			if not cf then return "do: file: "+arg3+" not found"
			if cf.is_binary then return "do: cannot open binary file"
			if not cf.has_permission("r") then return "do: can't read "+arg3+": permission denied"
			cmd = cf.get_content.split(char(10))
		else
			return "do: input error: -f expects a file path"
		end if
	end if
	time_s = time
	if DEBUG then print(cmd)
	if cmd.len then
		cmd = cmd.replace(char(10)," || ")
		for i in range(1,iter)
			for c in cmd
				if c == globals.SAFEWORD then break
				//c = c.replace(" || "," |  | ") + " | return"
				if DEBUG then print "debug: do: c: "+char(10)+": "+c
				if c.len < 1 or c[0] == "#" then continue
				c = c + " | return"
				r = command.shell(c)
				if r == "@STOP" then break
				if r == "@RETURN" then return
			end for
		end for
	else
		return "<b>aborting...</b>"
	end if
	return colorCyan+"<size=50%>do: batch complete in [</size><size=75%>"+colorOrange+(time-time_s)+colorCyan+"</size><size=50%>] seconds"+CT
end function
command.cc = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return ": carbon copy: command buffer."+char(10)+"Usage: cc -- select command from history."+char(10)+"Usage: cc [#] -- where # corresponds to the command you wish to run from the command buffer."+char(10)+"-- will <b>return</b> the output of the commands as if they were run normally."+char(10)+"-- you may use cc inside of pipe chains."+char(10)+"---- e.g: cc 22 | echo | cc 10 | poke file.txt"
	i = 0
	schtick = "| return"
	if not arg1 then 
		for ccom in globals.command_buffer
			print("["+colorWhite+i+CT+"] "+char(187)+" "+ccom)
			i = i + 1
		end for
	end if
	do = null
	if arg1 then do = arg1.to_int
	if not do then do = user_input("cc:> ",0,0).to_int
	if typeof(do) == "number" and do >= 0 and do < globals.command_buffer.len then
		carbon = globals.command_buffer[do]
		carbon = carbon +" "+ schtick
		return command.shell( carbon )
	else
		return "cc: invalid index"	
	end if
	return 0
end function
command.time = function(arg1, arg2=0, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "Usage: time -- returns current game time."+char(10)+"Usage: time [-d|date] -- returns current game time and date."+char(10)+"Usage: time [-t] -- returns time in seconds since script launch."
	if arg1 == "-t" then return time
	if arg1 == "-d" or arg1 == "date" then return current_date
	return current_date.split(" ")[2]
end function
command.pause = function(arg1=0, arg2=0, arg3=0, arg4=0)
	if not arg1 or arg1 == "0" or arg1 == "help" or arg1 == "-h" then return "Pause || Wait || Hang || Sleep"+char(10)+
	// note, this function expects time as a string, the user should form the string as a float. eg: pause .01 -- where .01 is a string
	"Usage: pause [seconds(float)] -- pauses script execution"+char(10)+
	"-- Minumum time: .01 seconds"+char(10)+
	"-- Maximum time: 300 seconds"+char(10)+
	"-- useful for putting a delay in 'do' scripts."+char(10)+
	"-- useful for putting a delay in a chain of commands"+char(10)+
	"-- this command uses the general function: wait(time)"+char(10)+
	"Usage: pause [-v] [delay] -- as above but prints a notification at each pause"+char(10)+
	"Usage: pause [-m] -- pause until manually unpaused (by pressing enter)"

	time_to_wait = "1" // default wait 1 second 
	manual_unpause = false // if false the chain of commands continues after the pause, if true then press a key to continue
	verbose = false // if false; works silently. if true; prints a line on each pause
	if arg1 == "-m" then 
		manual_unpause = true 
		arg1 = ".01"
	end if
	if arg1 == "-v" then 
		verbose = true 
		arg1 = arg2 
	end if
	if DEBUG then print "debug: in pause: arg 1 is: "+arg1+" and manual pause is: "+manual_unpause
	if typeof(arg1.val) == "number" then time_to_wait = arg1.val else return "pause: invalid interval: expects positive float [.01 : 300]"+char(10)+"n.b. - negative values will not reverse time"
	if manual_unpause then return user_input(colorWhite+"pause</b>: script execution paused"+char(10)+"-- press <"+colorGreen+"enter"+CT+"> to continue --")
	if time_to_wait <= 300 and time_to_wait >= .01 then
	else
		time_to_wait = 1
		print "pause: invalid wait time: changing time_to_wait to 1 second"
	end if
	if verbose then print colorWhite+"<u>pause</b>: script execution paused for <b>"+time_to_wait+"</b> seconds..."
	wait(time_to_wait)
	if verbose then return colorWhite+"pause:"+CT+" resuming script execution"
	return 0
end function
command.bios = function(arg1=0, arg2=0, arg3=0, arg4=0)
if arg1 == "help" or arg1 == "-h" then return "OBJECT | MEMORY | BIOS | CERBIOS"+char(10)+
"Usage: bios -- system info"+char(10)+
"Advanced:copy the following to 5hell's command line:"+char(10)+
"<b>mkdir /virt | poke /virt/hdd.io dev_sda:SIZE </b>"+char(10)+
"-- replace SIZE with the maximum size of your hdd in bytes. "+char(10)+
"-- this lets bios report the remaining hdd space"+char(10)+
"Usage: bios -a -- return the currently loaded <color=#FFD000>aptclientlib object"+char(10)+
"Usage: bios -m -- return the currently linked <color=#13E6CA>metaLib object"+char(10)+
"Usage: bios -x -- return the currently loaded <color=#FF0800>metaxploitLib object"+char(10)+
"Usage: bios -c -- return the currently loaded <color=#8C00FF>crypto object"+char(10)+
"Usage: bios -C [cryptoLib|/path] -- replace the currently loaded <color=#64184B>crypto object"+char(10)+
"-- eg: bios -i /lib/crypto.so | <b>bios -C"+char(10)+
"-- eg: <b>bios -C /root/crypto.so"+char(10)+
"Usage: bios -n -- return the currently linked <color=#0011FF>netsession object"+char(10)+
"Usage: bios -p -- return the currently loaded <color=#69E488>port_map object as a string"+char(10)+
"Usage: bios -P -- return the currently loaded <color=#00FF40>port_map object as a map"+char(10)+
"Usage: bios -H -- return the currently linked <color=#E4EE58>herme5 meta.mail object"+char(10)+
"-- returns null if not logged in to a mail account"+char(10)+
"Usage: bios -s -- return the currently loaded <color=#8B8568>meta_scan information</color> as a string"+char(10)+
"Usage: bios -X -- return the currently loaded <color=#065F0D>XPLOITS as a list"+char(10)+
"Usage: bios -M -- return the current <color=#FF00C8>MEMORY object or null"+char(10)+
"Usage: bios -B -- return the global <color=#E68A13>BUFFER as a list"+char(10)+
"Usage: bios -r [opt: ip] -- return the <b>local<b> <color=#71858D>router object</color> [opt:ip]"+char(10)+char(10)+
"<b>Usage: bios -i [/path] -- runs <u></b>include_lib</u><b> on /path and returns result"+char(10)+
"-- init.so, net.so, kernel_module.so cannot be imported as they lack an API"+char(10)+
"-- prompts for a path if path not supplied"+char(10)+
"---- e.g.|> bios -i /lib/blockchain.so | malp "+char(10)+
"---- returns the blockchainLib object and pipes it to malp (to the BUFFER)"+char(10)+
"---- note: cannot include_lib net.so, init.so, kernel_module.so"+char(10)+
"------ only libs with API's may use include_lib"+char(10)+
"------ use meta link to load those with the metaxploitLib"+char(10)+char(10)+
"Usage: bios --stack -- return the global stack_pool value (as a string numeral)"+char(10)+
"-- this value is incremented by one with each use of <B>run</b> (shell.launch)"+char(10)+
"-- this value is decremented on return from <b>run</b>"+char(10)+
"-- current stack_pool: <b>"+globals.stack_pool+char(10)+char(10)+
"Usage: bios --home -- return the get_custom_object.HOME map"+char(10)+
"-- current @home address: <size=75%><b>"+get_custom_object.HOME.ip
if arg1 == "--stack" then return str(globals.stack_pool)
if arg1 == "-C" then 
	ilib = null
	if typeof(arg2) == "cryptoLib" then 
		ilib = arg2
		globals.cryptoLibVersion = "-.-.-"
	end if
	if typeof(arg2) == "string" then 
		lib = globals.get_file(arg2)
		if typeof(lib) == "file" then ilib = include_lib(lib.path) else return "bios: file not found"
		if typeof(ilib) == "cryptoLib" then 
			if metaxploit then globals.cryptoLibVersion = metaxploit.load(lib.path).version else globals.cryptoLibVersion = "-.-.-"
		else 
			return "bios: target file is not a cryptoLib"
		end if
	end if
	if typeof(ilib) == "cryptoLib" then globals.crypto = ilib else return "bios: invalid input"
	print colorGold+"</b>bios: global cryptoLib replaced: "+char(10)+"-- crypto.so v "+globals.cryptoLibVersion
	return ilib
end if	
if arg1 == "-a" then return globals.apt_get 
if arg1 == "-x" then return globals.metaxploit 
if arg1 == "-c" then return globals.crypto 
if arg1 == "-n" then return globals.net_session
if arg1 == "-p" then return globals.display_portmap(1)
if arg1 == "-P" then return globals.PORT_MAP
if arg1 == "-H" then return globals.inbox
if arg1 == "-m" then return globals.metaLib
if arg1 == "-s" then return globals.meta_scan
if arg1 == "-X" then return globals.XPLOITS 
if arg1 == "-M" then return globals.MEMORY
if arg1 == "-B" then return globals.BUFFER
if arg1 == "--home" then return get_custom_object.HOME.ip
if arg1 == "-r" then 
	if arg2 then
		if is_valid_ip(arg2) then return get_router(arg2)
		return "bios: get_router: invalid ip"
	else 
		return get_router
	end if
end if
if arg1 == "-i" then 
	if not arg2 then 
		arg2 = user_input("Enter path to file.so :> ")
	end if
	tf = globals.get_file(arg2)
	if not tf then return "bios: "+colorRed+"</b>target file not found!"
	inc = include_lib(tf.path)
	if inc then 
		globals.BUFFER.push(inc)
		print "bios: sending "+inc+" to "+colorOrange+"BUFFER"+char(10)+"-- returning..."
		return inc
	else
		return "bios: "+colorRed+"</b>include_lib failed:"+char(10)+"-- target file does not have an API"+char(10)+colorGreen+"kore: helper:</b> perhaps try<b> meta load [libname]"+char(10)+"-- if you meant metax.load("+arg2+")" 
	end if
end if

bios_info = []
bios_info.push("<mark=red><u>=======================================================================</u></mark>")
bios_info.push("<u><mark=red>=</mark><color=red>__(WIP)________________cer_bios_v_0.6_by_Plu70________________(WIP)__</color><mark=red>=</mark></u>")
bios_info.push("* "+current_date+" "+globals.localmachine.local_ip+" @ "+globals.localmachine.public_ip+" up: "+time)
procs = globals.localmachine.show_procs.split(char(10))
root_procs = 0
user_procs = 0
guest_procs = 0
mem_used = 0
cpu_used = 0
for p in procs
	spl = p.split(" ")
	pro_usr = spl[0]
	pro_idn = spl[1]
	pro_cpu = spl[2].remove("%")
	pro_mem = spl[3].remove("%")
	pro_nam = spl[4]
	if pro_cpu != "CPU" then cpu_used = cpu_used + pro_cpu.val
	if pro_mem != "MEM" then mem_used = mem_used + pro_mem.val
	if pro_usr == "root" then
		root_procs = root_procs + 1
	else
		if pro_usr == "guest" then
			guest_procs = guest_procs + 1
		else
			if pro_usr != "USER" then user_procs = user_procs + 1
		end if
	end if
end for
root = localmachine.File("/")
hdd_io = localmachine.File("/virt/hdd.io")
h_size = "<color=red>dev_sda error</color>"
if hdd_io then
	h_c = hdd_io.get_content.split(char(10))
	h_s = h_c[0].split(":")
	h_n = 0
	if h_s.len > 1 then h_n = h_s[1].val
	if h_n then h_size = h_n - root.size.val
end if
if globals.stack_pool >= 15 then stack_print = "depleted; further nested launches not possible" else stack_print = globals.stack_pool
bios_info.push("<mark=red><size=85%>|</size></mark>")
bios_info.push("<size=85%>Macula Registry: [stack_pool:"+colorRed+stack_print+CT+"] </size>")
bios_info.push("<size=85%>root_procs [<b>"+root_procs+"</b>] user_procs [<b>"+user_procs+"</b>]  guest_procs [<b>"+guest_procs+"</b>] t:<b> "+(procs.len-1)+"</b></size>")
bios_info.push("<size=85%>cpu_usage: ["+cpu_used+"%] mem_usage: ["+mem_used+"%] temp: <color=red>therm_io not found</color></size>")
bios_info.push("<size=85%>[cpu:<mark=green>|"+"|"*(cpu_used/4)+"</mark>"+"_"*((100-cpu_used)/4)+"]   [ram:<mark=green>"+"|"*(mem_used/4+1)+"</mark>"+"_"*((100-mem_used)/4)+"]</size>")
hdd=(root.size.val / 1000000)
if typeof(h_size) == "number" then h_size = h_size / 1000000
bios_info.push("<size=85%>[hdd_used: <b>"+str(hdd)+" </b>MB]  [hdd_free: "+h_size+" MB]</size>")
allfiles = command.tree("-r","/")
folds = 0
bins = 0
txts = 0
tot = 0
for f in allfiles
	if f.is_folder then 
		folds = folds + 1
	else if f.is_binary then 
		bins = bins + 1
	else
		txts = txts + 1
	end if
end for
tot = folds + bins + txts
bios_info.push("<size=85%>num_folders ["+folds+"] num_binaries ["+bins+"] num_ascii ["+txts+"] total: ["+tot+"]</size>")
ess = "-wifi disabled-"
if localmachine.active_net_card == "WIFI" then
	sig = 0
	nets = localmachine.wifi_networks("wlan0") 
	ess = get_router.essid_name
	_get_wifi = function(networks)
		for net in networks 
			n = net.split(" ")
			if DEBUG then print "debug: n is: "+n+" and n[1] is: "+n[2]
			if ess == n[2] then
				sig = n[1].replace("%","")
				sig = sig.to_int
				if DEBUG then print "debug: sig strength is: "+sig+"%"
				return sig 
			end if
		end for
		return 0
	end function
	sig = _get_wifi(nets)
	sig_not = 100 - sig
	bios_info.push("<size=85%>[wifi_signal:<mark=green>|"+"|"*(sig/2)+"</mark>"+"_"*(sig_not/2)+"]</size>")
end if
dl = localmachine.network_devices.split(char(10))
bios_info.push("<size=85%>["+dl.join("] [")+localmachine.active_net_card+"] ["+ess+"]")
ports = localmachine.get_ports
pl = []
for p in ports
	pl.push(p.port_number)
end for
bios_info.push("<size=85%>ports: ["+pl.join("] [")+"] </size>")
bios_info.push("<mark=red><size=50%>|</size></mark>")
if DEBUG then print "debug: bios searching for database..."
database = command.tree("/","database.csv",1,"N")
data_lines = "--"
data_size = "-not_found-"
if database then
	if DEBUG then print "-- found database.csv: "+database.path
	data_size = command.file("-c",database)
	if database.has_permission("r") then data_lines = command.file("-l",database) else data_lines = "-check_perms-"
	if data_size.to_int > "150000".to_int then data_size = colorOrange+"Warning: "+data_size+CT
end if
bios_info.push("<size=85%>[database_size:"+data_size+"]  [database_lines:"+data_lines+"]</size>")
bios_info.push("<size=85%>[BUFFER: "+globals.BUFFER.len+" objects]</size>" )
bios_info.push("<size=85%>[Custom_Object: "+get_custom_object.len+" indexes]")
bios_info.push("<size=85%>[tagged4scp: "+globals.tagged_for_scp+"]</size>")
bios_info.push("[tbuf:<size=60%>"+globals.T_BUF.join(" ")+"</size>]</size>")
if typeof(@CLIP["a"]) == "string" then
	bios_info.push("[clipa:<size=60%>"+CLIP["a"].replace(char(10),", "))
else
	bios_info.push("[clipa:<size=60%>"+@CLIP["a"])
end if
if typeof(@CLIP["b"]) == "string" then
	bios_info.push("[clipb:<size=60%>"+CLIP["b"].replace(char(10),"</size=60%>, "))
else
	bios_info.push("[clipb:<size=60%>"+@CLIP["b"])
end if
if typeof(@CLIP["c"]) == "string" then
	bios_info.push("[clipc:<size=60%>"+CLIP["c"].replace(char(10),"</size=60%>, "))
else
	bios_info.push("[clipc:<size=60%>"+@CLIP["c"])
end if
mscan = "-none-"
if globals.meta_scan then mscan = "ready"
bios_info.push("<size=85%>[portmap:"+globals.PORT_MAP.len+"] [xploits: "+globals.NUM_SPLOITS+"] [metascan: ]</size>")
bios_info.push("<size=85%>[dict_a:"+colorGold+globals.dict_a.len+CT+"]  [dict_size: "+dict_a.join(", ").len+"]</size>")
bios_info.push("<mark=red><size=50%>|</size></mark>")
score = 10
co = colorOrange
pwf = command.tree("/etc","passwd",1,"N")
if pwf then 
	pwf = co + pwf.path +CT
	score = score - 1
else 
	pwf = "--null--"
end if
bff = command.tree("/","Bank.txt",1,"N")
if bff then
	bff = co + bff.parent.path +CT
	score = score - 1
else 
	bff = "--null--"
end if
mtf = command.tree("/","Mail.txt",1,"N")
if mtf then 
	mtf = co + mtf.parent.path +CT
	score = score - 1
else 
	mtf = "--null--"
end if
mcf = command.tree("/","Map.conf",1,"N")
if mcf then 
	mcf = co + mcf.parent.path +CT
	score = score - 1
else 
	mcf = "--null--"
end if
bcf = command.tree("/","Browser.txt",1,"N")
if bcf then 
	bcf = co + bcf.parent.path +CT
	score = score - 1
else 
	bcf = "--null--"
end if
clf = command.tree("/","ConfigLan.conf",1,"N")
if clf then 
	clf = co + clf.parent.path +CT
	score = score - 1
else 
	clf = "--null--"
end if
unsec_files = 0
unsec_dirs = 0
for file in allfiles
	fp = file.permissions.values 
	if fp[-1] != "-" or fp[-2] != "-" or fp[-3] != "-" then 
		if file.is_folder then unsec_dirs = unsec_dirs + 1 else unsec_files = unsec_files + 1
	end if	
end for
if unsec_files then score = score - 1
if unsec_dirs then score = score - 1
log = localmachine.File("/var/system.log")
log_size = 0
log_is_binary = 0
log_permissions = "-log-missing-"
if log then
	log_size = log.size
	log_is_binary = log.is_binary
	log_permissions = log.permissions
end if
log_ps = log_permissions.values
if log_ps[-2] != "-" or log_ps[-3] != "-" then score = score - 1
if score == 10 then 
	score = colorGreen+str(score) 
	else if score < 2 then 
		score = colorRed+str(score)
	else 
		score = colorOrange+str(score)
end if
bios_info.push("<size=85%>Security Audit Score: "+score+"/10</size>")
bios_info.push("<size=60%>[unsecured_files:"+unsec_files+"]  [unsecured_directories: "+unsec_dirs+" ]</size>")
bios_info.push("<size=60%>[/etc/passwd:"+pwf+"] [Mail.txt:"+mtf+"] [Bank.txt:"+bff+"]</size>")
bios_info.push("<size=60%>[Map.conf:"+mcf+"] [Browser.txt:"+bcf+"] [ConfigLan.conf:"+clf+"]</size>")
bios_info.push("<mark=red><size=50%>|</size></mark>")


bios_info.push("<size=85%>[/var/system.log: "+log_size+" bytes || is_binary: "+log_is_binary+" || perms: "+log_permissions+" ]")
bios_info.push("<mark=red><size=50%>|</size></mark>")
bios_info.push("*<size=50%> (obvious stub needs obvious improvement)</size>")
bios_info.push("*<size=50%> see <b>bios -h</b> for additional usage info.")
bios_info.push("<mark=red><u>=======================================================================</u></mark>")

return bios_info.join(char(10))
end function
command.cname = function(arg1,arg2,arg3,arg4)
	if arg1 == "help" or arg1 == "-h" then return "Usage: cname -- returns the name of the currently active computer_object"
	return localmachine.get_name
end function
command.whoami = function(arg1,arg2,arg3,arg4)
	if arg1 == "help" or arg1 == "-h" then return "WHOAMI || current user || active user || new user, who dis?"+char(10)+
	"Usage: whoami -- returns the active_user"+char(10)+
	"-- if GLASSPOOL is active; returns best guess at active user"
	if GLASSPOOL then return checkUser(localmachine) else return active_user
end function

command.credits = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "credits"
	logo = []
	logo.push("  |-----\ "+CT+colorWhite+"   |      |   /--------   |          |         ")
	logo.push("  |     | "+CT+colorWhite+"   |      |   |           |          |         ")
	logo.push("  |       "+CT+colorWhite+"   |      |   |           |          |         ")
	logo.push("  |____   "+CT+colorWhite+"   | _____|   |--------   |          |         ")
	logo.push("       |  "+CT+colorWhite+"   |      |   |           |          |         ")
	logo.push("       |  "+CT+colorWhite+"   |      |   |           |          |         ")
	logo.push(" |     |  "+CT+colorWhite+"   |      |   |           |          |         ")
	logo.push(" \ ____|  "+CT+colorWhite+"   |      |   \--------    \_______   \_______ "+char(8482))
	for l in logo
		print(colorRed+l+CT)
	end for
	print("by Plu70 aka jhook, aka ra'al")
	print("special thanks to: KuRouZu")
	print("MuninCipher by:"+colorWhite+" Plu70, CypherRaven"+CT)
	print("CheckUser function by: "+colorWhite+"Corvus"+CT)
	print("Blackjack card art by: "+colorWhite+"3nigma"+CT)
	print("Pwgen by : "+colorWhite+" UsesPython, additions by Plu70 "+CT)
	print("Glosure by: "+colorWhite+"rocketorbit")
	print("Htop by: "+colorWhite+"redit0")
	print("Additional code contributions by: Clover, redit0, muhahahahe, rocketorbit")
	print("Github Readme by: "+colorWhite+"Hikaru918")
	print("5hell Discord by: "+colorWhite+"Redit0")
	print("5hell.src optimizations by: "+colorWhite+"Clover")
	print("beta testing by: "+colorWhite+"CypherRaven, Deckard, KotyKD, Silent, Wulf, Amanda, Sabranan ")
	print("Inspiration from: "+char(10)+colorWhite+"AweTux, Kirin, Rasputin, Haro, CypherRaven, 3nigma, muhahahahe, Arcane, Sl3ekr, bakeneko, Slat3r, Swep, GSQ, blujoker, Lady, KotyKD, Corvus, Amanda, DHZA, Silent, Conner, STYX, Fear_Rua, Penelope, Andreno, Minidevil96, Tyy, Sabranan, CyanMatter, MrMember, Clover, Maho_Citrus, Trashed, Bit, OmegaKawaii, Hikaru918, Notepid, Xagic, Omega, Redit0, Eclipse00, Jessa, Forteyn, Hecate, Nyx "+char(10)+"and many others!")
	return 0
end function
command.quit = function(state=1, arg2=0, arg3=0, arg4=0) // NOT reboot command, rather ends script
	if state == "help" or state == "-h" then return "<u>QUIT || EXIT || RETURN</u>"+char(10)+"Usage: quit [opt:state] -- exits the program."+char(10)+"-- if no optional state then prompts before exit"+char(10)+"-- if state supplied then skips confirmation and exits with state"+char(10)+"Usage:<b> exit [opt:state]</b> -- also exits the program with optional state"+char(10)+"Usage: return -- used to return from glasspool. Will exit 5hell if glasspool is inactive."
	did = false
	if globals.hasIndex("params") and globals.params.len > 0 and globals.params[0] == "do" then did = true
	if not state or did then 
		if not state then 
			if user_input("Exit "+colorRed+"5hell"+char(8482)+CT+"? [y/N]"+char(10)+"||: ",0,1).lower != "y" then return "aborting shutdown..."
		end if
	end if
	exit(state)
end function
command.help = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "helping..."
	if arg1 == "shell" then return (colorRed+instance.name+CT+" v "+ver+" by Plu70"+char(10)+"(type<b> shell </b> for more info.)")
	if arg1 == "guide" then
		print(colorGold+"<u>= = = = = = = = = = = = = =</u>"+CT)
		print("Quick start guide: (5hell command line: |> )")
		print(colorGold+"probe [ip]"+CT+" -- perform a whois and portscan on target ip. Sets target IP in 5phinx/sphinx.")
		print(colorGold+"sphinx"+CT+" -- bring up pentest tool with target already set."+char(10)+
		"-- Press [0] to view portmap, [4] to change target ip, [5] to set target port.")
		print("Use arrow keys to access other 5phinx menus.")
		print("in sphinx "+colorGold+"press [=]"+CT+" -- connect metalib and get net_session (or load local lib)")
		print("in sphinx "+colorGold+"press [3]"+CT+" -- if target lib is unknown (scan/add to dbase)")
		print("in sphinx "+colorGold+"press [a] or [2]"+CT+" -- single attack or attack with all. results are stored in the BUFFER.")
		print("access "+colorGold+"malp"+CT+" -- memory alpha, (left arrow from sphinx or malp from |> )")
		print("in malp "+colorGold+"press [5]"+CT+" for BUFFER objects.")
		print("the BUFFER in <b>malp</b> is where you will interact with most objects.")
		print("use "+colorGold+" scpm "+CT+"command from |> or select a shell in BUFFER and press [7] scp to upload rkit ")
		print("do this<u> before </u>activating glasspool for best results.")
		print("use "+colorGold+"felix"+CT+" -- file explorer to send files/folders to BUFFER")
		print("all other commands are utility. explore them!")
		print(colorGold+"glasspool is shell/computer mirroring. some commands may change when this is active. "+CT+char(10)+
		"N.B. when active you are on the other side of the mirror looking back.")
		print(colorGold+"*--*"+CT)
		print("<b>/root/rkit</b> is the default location of the rootkit which should consist of:"+char(10)+
		"<b>   5hell, crypto.so, metaxploit.so, database.csv </b>"+char(10)+"Additionally it may contain: "+char(10)+
		"   dig.bat, ScanLan.exe, and other tools/libs you find useful.")
		print("In most cases you may type<b> kore -r</b> to have the rkit built for you."+char(10)+
			"kore will look for 5hell in /bin, and meta and crypto in /lib."+char(10)+
				"Add these files manually if kore is unable to do so.")
		print("For scripting see:<b> do -h</b>"+char(10)+
		"For dictionary attacks see:<b> cerebrum -h, brutus -h, gopher -h, hashim -h</b>")
		print("For networking see:<b> air -h, iwlist -h, ifconfig -h, ssh -h, kraken -h</b>")
		print("For security see:<b> perms -h, usr -h, grp -h, sniff -h, silentclean -h, bios -h")
		print("For dev tools see:<b> scribus -h, makfit -h, clipb -h, make -h, chop -h, dfit -h </b>")
		print(colorGold+"*--*"+CT)
		return 0
	end if

	help_conventions = "<b>CONVENTIONS</b>"+char(10)+"While a great deal of 5hell is discordant, there are some conventions:"+char(10)+char(10)+
	"You may toggle the full prompt and minimal promt by typing: "+char(10)+
	"<b>prompt</b> at the command line"+char(10)+
	"- - - - - - - - - - "+char(10)+
	colorWhite+"Input: arguments and quote blocks and piping oh my!"+char(10)+
	"-- 5hell uses a 4 argument system. This means all commands take at most 4 arguments"+char(10)+
	"-- this might sound limiting but it isn't at all in practice. Each of the 4 arguments may be overloaded."+char(10)+
	"Some input methods are:"+char(10)+
	colorLightBlue+"----* simply typing input: |> ping 1.1.1.1"+char(10)+
	"------ up to four typed arguments"+char(10)+
	"------ remember that |> is the prompt, you don't type that part"+char(10)+
	colorLightBlue+"----* using single quotes to wrap text: |> echo "" this is a text block "" "+char(10)+
	"------ would return: this is a text block"+char(10)+
	"------ note that: |> echo ""this is a text block"" "+char(10)+
	"------ would return: """"this is a text "+char(10)+
	"------ this allows you to overload each argument with more than one ""word"""+char(10)+
	"------ easy clip and piping and objects(mostly) are preserved inside of text blocks"+char(10)+
	"------ <b>you may escape a floating quote with <b>\"""+char(10)+
	"--------eg: macro set foo "" echo \"" bar none \"" """+char(10)+
	colorLightBlue+"----* use <color=yellow>do</b></color> to run a batch of commands from a file or from memory using an editor"+char(10)+
	"------ |> do -- without arguments do will prompt for number of iterations then open the editor"+char(10)+
	"------ |> do 1 -- would bring up an editor commands typed here will be executed in order"+char(10)+
	"------ |> do 1 ping 1.1.1.1 -- would result in pinging 1.1.1.1 once"+char(10)+
	"------ |> do 5 "" rnip 1 | dig "" -- would run dig on a random ip 5 times"+char(10)+
	"------ |> do 1 -f /foo.bar -- execute the batch of commands in the file foo.bar"+char(10)+
	"-------- you may launch 5hell from the game's command line with <b>do</b> parameters"+char(10)+
	"-------- the format is the same as if typing commands on the command line"+char(10)+
	"-------- newlines in the script are considered to be new command line entries"+char(10)+
	"-------- you may use piping, easy clip, and even calls for <b>do</b> to execute further scripts"+char(10)+
	"-------- you may use text blocks for complex commands in place of files or the editor"+char(10)+
	"--eg:  |> do 3 "" rnip 1 | dig |  | cob get metx | meta -i | db -m | zap "" | poke test.txt "" this is a bunch of text going into a file """+char(10)+
	colorGold+"** it is possible to almost completely automate every aspect of 5hell via <u>do</u> and <u>dig</u>"+char(10)+
	"------ for ease of use <b><color=white>do 1 -f</b></color> has been aliased to <color=white><b>bat</b></color> in 5hell.src:"+char(10)+
	"-------- |> <b>bat /foo.bar</b> is equivalent to |> <b>do 1 -f foo.bar</b>"+char(10)+
	"------ please see <u><b><color=yellow>do -h</b> and <b>dig -h</b></u></color> for more information on automation"+char(10)+
	colorLightBlue+"----* piping input: |> grep -f ^syst | file -p | cp /etc/passwd"+char(10)+
	"------ would result in copying /etc/passwd over top of system.log (if permissions allowed it)"+char(10)+
	"------ piping allows you to transfer the output of one command to the innput another command"+char(10)+
	"------ in the above example the output of grep [args...] is the input of file -p [input]"+char(10)+
	"------ and the output of file -p [args] is the input of cp /etc/passwd [input]"+char(10)+
	"------ please see <b>pipe -h</b> for more"+char(10)+
	"------ if malp is the backbone of 5hell, pipes are the circulatory system of 5hell"+char(10)+char(10)+
	colorWhite+"Prompts: "+CT+"|> , :> , ||: "+char(10)+
	"<color=#FFFFFF>|>  --  this is the standard Command Line Interface prompt"+char(10)+
	"-- by default there will be information printed before this"+char(10)+
	"-- toggle to a minimalist prompt with: <b>prompt</b>"+char(10)+
	"-- fires CLI commands"+char(10)+
	colorLightBlue+"|> "+CT+"  --  by default, the GLASSPOOL prompt turns the "+colorLightBlue+"|>"+CT+" blue"+char(10)+
	"-- this means commands execute on the remote object controlled by glasspool"+char(10)+
	"-- see glasspool -h for more"+char(10)+
	colorWhite+":>  "+CT+" --  this is a liminal prompt, it expects a string or empty return"+char(10)+
	"-- this is used to gather user input within a command"+char(10)+
	colorWhite+"||: "+CT+" --  this is an 'any key' prompt"+char(10)+
	"-- it takes a single keypress"+char(10)+
	"-- this is used in 'button' driven menus"+char(10)+char(10)+
	colorWhite+"Decision Prompts: "+CT+"[ N/Y/X ] [n/y/x]"+char(10)+
	"-- Multiple choice prompts have a default"+char(10)+
	"-- the default is always Capitalized and sometimes highlighted"+char(10)+
	"-- the default is chosen if <b><enter></b> is pressed without input"+char(10)+
	"-- unless otherwise noted, default is chosen if input doesn't match a choice"+char(10)+
	"E.G: |> psudo"+char(10)+
	"Open shell? [c/y/N]"+char(10)+
	"||:"+char(10)+
	"-- in this example, the choices are [c], [y], and [N]"+char(10)+
	"---- [c] -- enter credentials"+char(10)+
	"---- [y] -- open shell"+char(10)+
	"---- [n] or anything else -- no; return/abort"+char(10)+
	"------ this is because N is the default"+char(10)+char(10)+
	colorWhite+"Prompt: advanced:"+char(10)+
	"-- by default the prompt will display the public and local ip of the active shell"+char(10)+
	"---- or computer if using glasspool on a computer object"+char(10)+
	"-- by default the prompt will display computer name and working directory"+char(10)+
	"-- by default the prompt indicates user privileges (root,user,guest) with:"+char(10)+
	"---- under the ip information there will be a:"+char(10)+
	"------ a<color=red> red line for root</color>, <color=green>green line for user </color>, </color>and <color=white>white line for guest"+char(10)+
	"---- please note that user permissions are determined by access level"+char(10)+
	"---- in some cases, this might not be the actual user"+char(10)+
	"-- you may customize the prompt to your liking in 5hell.src"+char(10)

	help_tools = "<u><b>Main tools:"+char(10)+
	colorCyan+"probe "+colorWhite+"-- whois and portmap a target"+char(10)+
	colorCyan+"db "+colorWhite+"-- scan target and <b>database results</b>"+char(10)+
	colorCyan+"meta "+colorWhite+"-- metaLib and metaxploitLib fine control"+char(10)+
	colorCyan+"zap "+colorWhite+"-- select and fire exploits one at a time (does not database)"+char(10)+
	colorCyan+"roil "+colorWhite+"-- fire all exploits at once (does not database)"+char(10)+
	colorCyan+"malp "+colorWhite+"-- Memory Alpha: BUFFER management"+char(10)+
	"-- exploit results and other objects go here"+char(10)+
	"-- this is arguably the backbone of 5hell"+char(10)+
	colorCyan+"scpm "+colorWhite+"-- menu and/or cli driven scp"+char(10)+
	colorCyan+"kraken "+colorWhite+"-- proxy management"+char(10)+
	colorCyan+"scribus "+colorWhite+"-- simple text editor"+char(10)+
	colorCyan+"cerebrum "+colorWhite+"-- add 325k+ passwords to custom_object.dictionary"+char(10)+
	colorCyan+"brutus "+colorWhite+"-- use custom_object.dictionary to get root on any (unmodified) npc machine"+char(10)+
	colorCyan+"See: [command] [-h|help] for more help on these and other commands"+char(10)

	help_buffer = colorOrange+"The BUFFER"+char(10)+
	colorOrange+"</b>The BUFFER stores objects. Anything may be stored in the BUFFER."+char(10)+
	colorOrange+"You access the BUFFER with the <b>malp</b> command >> option [5]"+char(10)+
	colorOrange+"</b>When an exploit is run, the result is stored in the BUFFER. You"+char(10)+
	colorOrange+"</b>may interact with these objects in a number of ways by selecting them"+char(10)+
	colorOrange+"</b>from the list and using their context menu (if the object has one)."+char(10)+
	colorOrange+"</b>One way to fetch an object from the BUFFER for use elswhere is to use the clipboard:"+char(10)+
	colorOrange+"</b>|> "+colorGreen+"clipb @B [index|-m]</color>"+colorOrange+"</b>-- where index == BUFFER[index]"+char(10)+
	colorOrange+"</b>-- then pipe the value to another function"+char(10)+
	colorOrange+"</b>Easy Clip! As of version 3.9.6 any command may take <b>@B [index|-m] as one or more parameters!"+char(10)+
	colorOrange+"</b>-- if -m is passed instead of an index, a menu is displayed"+char(10)+
	colorOrange+"</b>|> roil | scpm /root/rkit @B -m"+char(10)+
	colorOrange+"You may pipe anything into the buffer with |><b> [command_returning_input] | malp</b>"+char(10)+char(10)+
	colorGreen+"Easy Clip! You may reference the clipboards with the @ symbol:"+char(10)+
	colorGreen+"***  clipa, clipb, and clipc are all clipboard spaces  ***"+char(10)+
	colorGreen+"</b>You may use @a, @b, and @c to reference their values"+char(10)+
	colorGreen+"</b>e.g. echo hello world | clipa |  | poke hello.txt @a"+char(10)+
	colorGreen+"*** tbuf, home, do ***"+char(10)+
	colorGreen+"</b>e.g. <b>gopher @tbuf</b>, e.g. <b>rshell @home</b>, e.g <b>scribus @do"+char(10)+char(10)+
	colorCyan+"</b>The CUSTOM_OBJECT is a way for scripts to share information between"+char(10)+
	colorCyan+"</b>nested launches. This means you can launch 5hell with 5hell and pass objects back and forth."+char(10)+
	colorCyan+"</b>You interact with the custom_object via the various <b>cob</b> commands"+char(10)+
	colorCyan+"</b>Namely: cob get and cob set."+char(10)+
	colorCyan+"For ease of use: <color=white>cob get</color> and <color=white>cob set</color> have been aliased to:"+char(10)+
	colorCyan+"</b>-- <color=white>get</color> and <color=white>set</color> in 5hell.src"+char(10)+
	colorCyan+"</b>-- |> <b>cob set bob burger </b>is equivalent to |><b> set bob burger"+char(10)+
	colorCyan+"</b>-- |> <b>cob get bob</b> is quivalent to |><b> get bob"+char(10)+
	colorCyan+"</b>An example would be "+colorGold+"cerebrum</color> which loads the dictionary to the custom object."+char(10)+
	colorCyan+"</b>-- When generated, the dictionary is loaded to the custom object under the key: <b>dictionary</b>."
	colorCyan+"</b>-- Once loaded, you may <b>run</b> 5hell through nested launches and the dictionary will persist."+char(10)+
	colorCyan+"</b>-- This also allows you to import/export metaLib's and metaxploitLib's between machines!"+char(10)
	colorCyan+"</b>-- Easy Clip! You may reference a value in the custom object by it's key with: <b>@o [key]</b>"+char(10)+
	colorGold+"</b>--eg:<b> set foo "" look out for that tree, "" | echo @o foo george </b>// look out for that tree, george"+char(10)+
	colorCyan+"</b>-- Please see cob -h for more informaiton"

	help_logs = colorWhite+"The dreaded "+colorRed+"System.log"+char(10)+
	"Actions that generate an entry in system.log: "+char(10)+
	"-- establishing a net_session on a server (not a router)"+char(10)+
	"-- connecting via Browser.exe to a server"+char(10)+
	colorWhite+"---- connection established on port ##"+char(10)+
	"-- obtaining a shell (server/router)"+char(10)+
	colorWhite+"---- shell obtained on port ##"+char(10)+
	"-- deleting a file"+char(10)+
	colorWhite+"---- file deleted [ip]"+char(10)+
	"-- routing a connection with:"+char(10)+
	"-- connect_service or file_explorer"+char(10)+
	colorWhite+"---- connection routed [ip]"+char(10)+
	"-- shell disconnect"+char(10)+
	"-- i.e. exiting from start_terminal"+char(10)+
	colorWhite+"---- connection closed [ip]"+char(10)+char(10)+
	colorRed+"Active Traces"+CT+" will start when <b>shell.start_terminal</b> is used"+char(10)+
	"on an npc machine with an active admin of sufficient knowledge and give-a-damn."+char(10)+
	"Generally, if there is a root: dsession active, using start_terminal will trigger"+char(10)+
	"an active trace. Active traces are stopped by disconnecting (exiting) that terminal instance."+char(10)+char(10)+
	"When using 5hell you should NOT ever open a terminal (on a target) unless you are doing an Academic or"+char(10)+
	"Police record mission. OR if you absolutely need to open the browser to edit firewall or port rules"+char(10)+
	"on a target. Otherwise, use <b>glasspool</b> and <b>run</b> to leverage shell object manipulation instead."+char(10)+char(10)+
	"However! You <u>should</u> start_terminal on your end point attack proxy. In fact, do it twice:"+char(10)+
	"-- use <b>prox</b> to tunnel to your end point proxy then launch 5hell and type <b>psudo</b> and then select [y]"+char(10)+
	"-- this will start_terminal on top of your start_terminal, effectively looping your connection on that machine"+char(10)+
	"-- this will ensure your end point proxy's ip is left in logs, not your origin ip"+char(10)+
	"-- without this, you risk exposing ip's behind the proxy"+char(10)+
	"-- note: this means you'll have to 'exit' twice from that proxy to return home"+char(10)+
	colorRed+"Passive Traces"+CT+" can/will start when certain actions have been left unaddressed:"+char(10)+
	"- Deleting a file and not removing the log entry"+char(10)+
	"- Leaving a connection closed log without a corresponding connection established log"+char(10)+
	"- Leaving a shell connected log at all"+char(10)+
	"- I think connection routed logs trigger traces, too. Not sure though."+char(10)+char(10)+
	colorMagenta+"We all leave logs, sometimes. To clean them up, here are a few methods:"+char(10)+
	colorLightBlue+"Silentclean "+CT+"-- local log corruption using a text file"+char(10)+
	"-- creates a file used to corrupt logs"+char(10)+
	"-- has nuke option (see: silentclean -h)"+char(10)+
	colorCyan+"Rclean "+CT+"-- remote (or local) log corruption using objects"+char(10)+
	"-- uses a file already on system to corrupt logs"+char(10)+
	"-- accepts and works on piped objects (see: rclean -h)"+char(10)+
	colorGold+"MV "+char(10)+"-- yep, just the <b>mv</b> command"+char(10)+
	"-- poke haha | mv haha /var/system.log"+char(10)+
	colorOrange+"Wiping the log with one of these methods using a reverse shell is best"+char(10)+
	"but not necessary. You may run silentclean, exit 5hell, exit the terminal, and you will not leave a disconnect log."+char(10)+
	"-- be aware that taking any log-creating action after running sc, except exiting, may regenerate the log."+char(10)

	help_alias = "<u><b>aliases || do script || shortcuts || macros || User Defined Behavior"+char(10)+
	"5hell can be very simple to use, or very, very complicated, depending on your goals."+char(10)+
	"It isn't necessary to learn 100% of 5hell. Nor is it necessary to suffer through some of it's"+char(10)+
	"more complex chains of commands. You can define your own behavior in a number of ways:"+char(10)+char(10)+
	colorLightBlue+"Aliases: "+char(10)+
	colorWhite+" You may define aliases in the aliases section of 5hell.src"+char(10)+
	colorWhite+"the default ones supplied are all prompt replacements. There are also 'easy clip' defenitions"+char(10)+
	colorWhite+"that replace arguments in the user input with, for instance, the contents of a clipboard or"+char(10)+
	colorWhite+"your @home server ip. These hard coded aliases may be more complicated than a simple"+char(10)+
	colorWhite+"word or string replacement. You may, for instance, have a simple two word alias fire"+char(10)+
	colorWhite+"a whole series of commands. This might be considered a macro at that point, but also"+char(10)+
	colorWhite+"might not quite qualify."+char(10)+char(10)+
	"Here is a list of the currently defined default aliases in 5hell.src:"+char(10)+
	colorLightBlue+"Alias           | Definition"+char(10)+
	colorCyan+"bat [path]      |</b> do 1 -f [path]"+char(10)+
	colorCyan+"set [key] [val] |</b> cob set [key] [val]"+char(10)+
	colorCyan+"get [key]       |</b> cob get [key]"+char(10)+
	colorCyan+"lock            |</b> perms lock all"+char(10)+
	colorCyan+"exit            |</b> quit"+char(10)+
	colorCyan+"sc [opt]        |</b> silentclean [opt]"+char(10)+
	colorCyan+"gp [#]          |</b> glasspool [#]"+char(10)+
	colorCyan+"prompt          |</b> -this will toggle the full_prompt on/off-"+char(10)+char(10)+
	colorWhite+"Easy Clip       |</b> Replacement"+char(10)+
	colorGold+"@a              |</b> clipa -- globals.CLIP[""a""]"+char(10)+
	colorGold+"@b              |</b> clipb -- globals.CLIP[""b""]"+char(10)+
	colorGold+"@c              |</b> clipc -- globals.CLIP[""C""]"+char(10)+
	colorGold+"@tbuf           |</b> transmission buffer -- globals.T_BUF"+char(10)+
	"-- this is                |</b> where hashes go when the tree command finds them"+char(10)+
	colorGold+"@t              |</b> targetIP"+char(10)+
	colorGold+"@p              |</b> targetPort"+char(10)+             
	colorGold+"@home           |</b> get_custom_object.HOME server ip address defined in 5hell.src"+char(10)+
	"-- this is                |</b> usually an attack proxy running ssh and rshell servers"+char(10)+
	"-- please don't           |</b> use your actual home pc for this"+char(10)+
	colorGold+"@B [index|-m]   |</b> directly reference a value in the"+colorOrange+" BUFFER "+CT+"by [index] or menu: [-m]"+char(10)+
	colorGold+"@o [key]        |</b> directly reference a value in the custom object by key"+char(10)+
	colorGold+"@r [index]      |</b> directly reference a shell in the rsi buffer by [index] or menu: [-m]"+char(10)+
	colorWhite+"All <b>@</b> aliases (known as ez_clips) may be escaped with the <b>\</b> character:"+char(10)+
	"<size=75%>--eg: <b>\@a</b>, \@home"+char(10)+
	"<size=75%>--eg: <b>clipa bob || echo @a -- will echo 'bob', while "+char(10)+
	"<size=75%>--eg: <b>clipa bob || echo \@a -- will echo '@a' "+char(10)+char(10)+
	"Please note: several commands have their own references for editing the clipboards"+char(10)+
	"-- these commands will use @clipa, @clipb, @clipc instead of @a, @b, @c"+char(10)+
	"Further, the clipa, clipb, and clipc will use @B to reference the BUFFER:"+char(10)+
	"-- e.g: |> <b>clipa @B 1</b> -- copy the object at index 1 in the BUFFER to clipa"+char(10)+
	"---- that object may then be used by other commands that accept piped objects as input"+char(10)+
	"-- as of 3.9.6 any command may use @B [index] as any parameter(s)"+char(10)+
	"-- there are other ways to pipe objects around besides the clipboards, explore to learn more."+char(10)+
	char(10)+
	colorOlive+"Marcos and Automation: "+char(10)+
	colorWhite+"<size=75%></b>You may define custom macro's with the "+colorOrange+"</b>macro</color> command. A macro is a "+char(10)+
	colorWhite+"<size=75%></b>runtime-defined set of instructions executed by a single command. Think of it as an alias that performs"+char(10)+
	colorWhite+"<size=75%></b>commands for you. Additionally, you may execute batch commands either from a file or from memory. There are"+char(10)+
	colorWhite+"<size=75%></b>a few differences between a <u>macro</u> and a <u>do script</u>."+char(10)+
	colorWhite+"<size=75%></b>Please see:  "+colorLightBlue+"</b>do -h, macro -h, and help automation for more information on this topic."+char(10)

	help_automation = "<u><b>automation || macro || do script || batch file"+char(10)+
	colorCyan+"How to fully automate <color=red>5</color><color=white>hell</color>:"+char(10)+
	colorWhite+"</b> As mentioned in <b>help alias</b>, you may define custom macro's, or sets of commands"+char(10)+
	colorWhite+"</b>that <color=red>5hell</color> will execute automatically. The two commands involved are:"+char(10)+
	colorOrange+"--: </b>macro</color> and "+colorOrange+"</b>do"+char(10)+
	colorWhite+"</b>The two commands function similarly in that they execute the defined commands as "+char(10)+
	colorWhite+"</b>if they were typed by you. The list of commands, or 'script,' is formed the same "+char(10)+
	colorWhite+"</b>way for both commands. Therefore both commands may execute the same scripts. That is, "+char(10)+
	colorWhite+"</b>do may execute a macro, and macro may execute a do script. This way, don't have to "+char(10)+
	colorWhite+"</b>remember two different formats for these similar commands."+char(10)+
	colorWhite+"</b>The specific behavior of each is as follows:"+char(10)+
	colorOrange+"DO: "+char(10)+
	colorCyan+" Do is essentially a 'do while' loop that executes at least once. You specify the number "+char(10)+
	colorCyan+"</b>of loops with the first argument: <b>do [some integer]</b> "+char(10)+
	colorCyan+"</b>The <b>primary</b> way to use do is like a macro that you want repeated on a loop."+char(10)+
	colorCyan+"</b>If there are no more arguments after the number, an editor will open (scribus) where you may"+char(10)+
	colorCyan+"</b>type out the commands you want executed line by line. Lines may be complex lines, that is, "+char(10)+
	colorCyan+"</b>the lines may include piping. The output of a line will <b>not</b> be passed to the following "+char(10)+
	colorCyan+"</b>line. This way, you may type out commands without using the <b>|  |</b> trick. Once "+char(10)+
	colorCyan+"</b>you type <b>@</b> on a new line, the script will begin executing. Use <b>@@</b> on a new line"+char(10)+
	colorCyan+"</b>to abort execution. Additionally, you may use<b> scribus @do</b> to edit the buffer without executing."+char(10)+
	colorCyan+"</b>You may then fire it later with<b> do [#]</b> and then <b>@</b>."+char(10)+
	colorLightBlue+"An example do script, either written in the editor or read from a file* (*explained in the third usage): "+char(10)+
	colorGold+"</b>ifconfig -p | probe"+char(10)+
	colorGold+"</b>brutus | clipb"+char(10)+
	colorGold+"</b>grep -p 5hell | clipc"+char(10)+
	colorGold+"</b>run @c "" do 1 rshell @home "" @b"+char(10)+
	colorGold+"</b>rclean @b/b>"+char(10)+
	colorLightBlue+"</b>This would result in a network probe, an escalation, a root rshell placement, and "+char(10)+
	colorLightBlue+"</b>finally a log scrub. This is useful to run each time you attack a new target and "+char(10)+
	colorCyan+"</b>is also included as the default <b>dig.bat</b>."+char(10)+
	char(10)+
	colorCyan+"</b>The <b>Second</b> way to use do is to define the commands on a single line, wrapped by floating quotes. "+char(10)+
	colorLightBlue+"</b>This would look like:<b> do 5 "" rnip 1 | ping 1.1.1.1 """+char(10)+
	colorLightBlue+"</b>This results in pinging 1.1.1.1 five times. More complex commands may be further chained by piping. "+char(10)+
	colorLightBlue+"</b>Be sure to wrap the commands you wish to <b>do</b> in quotes* that do not touch anything "+char(10)+
	colorLightBlue+"</b>(ie, floating) as shown above."+char(10)+
	colorLightBlue+"<b>* If the command string is only two words, quotes are not needed. eg: do 1 ping 1.1.1.1"+char(10)+
	char(10)+
	colorCyan+"The <b>Third</b> way to use do is to read defined commands from a file."+char(10)+
	colorLightBlue+"</b>The commands in the (text) file are written exactly as they are when using the editor to list commands."+char(10)+
	colorLightBlue+"</b>These commands are executed with:<b> do [#] -f [pathToFile]"+char(10)+
	colorLightBlue+"</b>For your convenience, the alias "+colorGold+"</b>bat [path]</color> will be relaced by <b>do 1 -f [path]"+char(10)+
	colorLightBlue+"</b>This is most useful when launching 5hell with a set of instructions. If you launch 5hell from the command "+char(10)+
	colorLightBlue+"</b>line with: <b>5hell do 1 -f [path] </b>5hell will automatically execute the commands in the file and then exit."+char(10)+
	colorLightBlue+"</b>If you do not wish 5hell to exit after completion, use a file named <b>do.rc</b> in your home_dir/Config or"+char(10)+
	colorLightBlue+"</b>in rkit (executes only if ~/Config/do.rc does not exist). Note that <b>do</b> does not return a value other than"+char(10)+
	colorLightBlue+"</b>it's completion time. Macros, however, do return the final value. Additionally, the <b>dig</b> command makes"+char(10)+
	colorLightBlue+"</b>use of the <b>do</b> engine when executing <b>dig.bat</b> (which itself, may reference other do scripts). "+char(10)+
	colorLightBlue+"</b>This allows 5hell to be fully automated throughout an arbitrary number of attacks. Cool stuff, right!?"+char(10)+
	char(10)+
	colorGold+"Macro:"+char(10)+
	colorWhite+"</b>A macro is similar to a do script, except it is intended to be written 'on the fly.' In other words, you type "+char(10)+
	colorWhite+"</b>the macro definition on the command line, without the editor, in most cases. If you do wish to use the editor, "+char(10)+
	colorWhite+"</b>simply use: <b>scribus @clipa/b/c | macro set [macro_name]"+char(10)+
	colorWhite+"</b>Marco's are stored in the custom object and are executed when called by name: <b>macro [name]"+char(10)+
	colorWhite+"</b>A macro <b>will</b> return it's final value and will not print execution time. There is no built in option "+char(10)+
	colorWhite+"</b>to read a macro from a file, however <b>cat [file] | macro set [name]</b> may be used to achieve this."+char(10)+
	colorWhite+"</b>An example macro definition:"+char(10)+
	colorWhite+"macro set prop "" cp 5hell /bin | cp /bin/5hell rkit | kraken /bin/5hell | kraken rkit/5hell """+char(10)+
	colorWhite+"</b>Again, it looks exactly the same as an inline do script, because it is! However, this script is stored "+char(10)+
	colorWhite+"</b>in the custom object, meaning it's string may be retrieved with <b>get macro.[name]</b> and piped somewhere,"+char(10)+
	colorWhite+"</b>such as to a file. You may absolutely fire a macro with <b>do</b>. Simply type: <b>do [#] @o [macroName]</b>"+char(10)+
	colorWhite+"</b>and do will happily execute the macro. Likewise, as mentioned earlier, piping the </b>contents of a "+char(10)+
	colorWhite+"</b>do script to macro will define the macro as that do script."+char(10)+
	char(10)+
	"This all may seem complicated, but it is actually rather simple: "+char(10)+
	"--define a list of commands as if you were typing them, fire the batch of commands."+char(10)+
	"For more information, please see: <b>do -h, macro -h, dig -h</b>, help alias, and help conventions."+char(10)+
	"Also, visit the 5hell discord for example scripts!"

	help_daemon = colorWhite+colorRed+"</b>5</color>hell has a handful daemon commands: htop, hashim, outmon, and rsi."+char(10)+
	colorWhite+"Three of these commands; htop, hashim, and outmon, are controlled by a 'daemon controller.' "+char(10)+
	colorWhite+"This controller functions by creating a file named<b> 5hell.d</b> in your root directory and writes a"+char(10)+
	colorWhite+"line to that file that matches a daemon process that is running. When this line is removed from the file, or"+char(10)+
	colorWhite+"or the file itself is deleted, the daemon process will end. This allows you to start and stop daemons in 5hell"+char(10)+
	colorWhite+"without having to kill the whole script with ctrl+c. Note that rsi is not controlled by the daemon manager as it"+char(10)+
	colorWhite+"exits daemon mode when a reverse shell connects to it."+char(10)+
	"See also: htop -h, hashim -h, outmon -h, rsi -h"

	if arg1 == "-s" or arg1 == "show" or arg1 == "search" then
		c_buf = []
		h_buf = []
		for cmd in command.indexes.sort
			if cmd == "shell" or cmd == "help" or cmd == "__isa" or cmd == "classID" then continue
			h = @command[cmd]
			c_buf.push(colorWhite+cmd+CT)
			c_buf.push(h("help"))
		end for
		c_buf.push(colorWhite+"shell"+char(10)+"Usage: shell -- outputs instance_name, num_commands and dictionary_size.")
		c_buf = c_buf+[help_buffer,help_conventions,help_logs,help_tools,help_alias]

		if arg2 then
			invoke_regex = false
			special_chars = ["*","^","$","#"]
			for special in special_chars
				if arg2.indexOf(special) >= 0 then invoke_regex = true
			end for
			for c in c_buf
				found = false
				if not invoke_regex then 
					if c.indexOf(arg2) >= 0 then 
						found = true
					end if
				else
					for w in c.split(" ")
						if globals.re.match(arg2.values, w.values) then 
							c = c.replace(w,colorRed+w+CT)
							found = true
						end if
					end for
				end if
				if found then h_buf.push( c.replace(arg2, colorRed+arg2+CT) +char(10)+ colorGold+"<u>---</u>"+ CT +char(10) )
				if DEBUG then print(h_buf[-1])
			end for
			return colorGold+"<u>= = = = = = Help Search = = = = = =</u>"+char(10)+colorLightBlue+"Found: </b>"+h_buf.len+"<b> results."+CT+char(10)+h_buf.join(char(10))
		end if
		return c_buf.join(char(10))
	end if
	if arg1 == "home" then
		return "  Convention: <b>@home</b> -- indicates a server you, the end user, have set up for 5hell"+char(10)+
		"services. Servers should be of type <b>SSH</b> and/or <b>RSHELL</b> and it is recommended to run:"+char(10)+
		"<b> pwgen | pwgen hash</b>"+char(10)+
		"on ssh servers running the <b>hashim daemon</b>. The @home server is used by:"+char(10)+
		"<b> cerebrum, brutus, linkdb, transmit, and rshell/rsi</b>"+char(10)+
		"For example: <b>rshell @home notAvirus</b> would create an rshell with ip set as your @home server."+char(10)+
		"That server would be running the rshell_server used by the rsi command. An @home server may also run:"+char(10)+
		"<b> hashim, outmon, or other custom services</b>. Please contact Plu70 if you have questions about setting"+char(10)+
		"up these resources."+char(10)+
		"Please edit the appropriate line in 5hell.src to setup @home by providing an ip address, port, password,"+char(10)+
		"and directory for the pass file. It is important that you secure 5hell with login authentication,"+char(10)+
		"either stock or your own, to prevent exposure of this information! "
	end if
	
	if arg1 == "-A" or arg1 == "alias" then return help_alias
	if arg1 == "-c" or arg1 == "conventions" or arg1 == "-p" or arg1 == "prompt" then return help_conventions
	if arg1 == "-t" or arg1 == "tools" then return help_tools
	if arg1 == "-b" or arg1 == "buffer" then return help_buffer
	if arg1 == "-l" or arg1 == "logs" then return help_logs
	if arg1 == "-a" or arg1 == "automation" then return help_automation
	if arg1 == "-d" or arg1 == "daemons" or arg1 == "daemon" then return help_daemon

	index = command.indexes
	if index.indexOf("__isa") != null then index.remove( index.indexOf("__isa"))
	if index.indexOf("classID") != null then index.remove( index.indexOf("classID"))
	if arg1 != "-i" then
		index = index.sort
	end if

	num_commands = index.len
	columns = 8 // # commands per line
	if globals.DEBUG then print("commands: "+num_commands+" columns: "+columns)
	rows = ceil(num_commands / columns)
	if globals.DEBUG then print("rows: "+rows)
	buf = []
	count = 0
	for i in range(0,rows)
		//buf.push("<color=#FFFFFFFF><b>"+index[count:count+columns].join(" "))
		buf.push(colorWhite+index[count:count+columns].join(" "))
		count = count + columns
	end for
	print(colorGold+"- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"+CT)
	print(format_columns(buf.join(char(10))).replace("sphinx", "<color=#FF0000FF>sphinx</color>" ) )
	print(colorGold+"- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"+CT)
	print(":><b> help</b> -- print this page: lists commands alphabetically")
	print(":><b> help guide</b> -- for a quick getting started guide")
	//print(":> help [-c|conventions] -- information about 5hell prompt conventions")
	print(":> help [-p|prompt|-c|conventions] -- information about 5hell prompt conventions")
	print(":> help [-t|tools] -- a short list of the main tools")
	print(":> help [-a|automation] -- print information about automating tasks")
	print(":> help [-d|daemon|daemons] -- information about daemon control")
	print(":> help [-A|alias] -- a list of the current default aliases in 5hell.src")
	print(colorOrange+":> help [-b|buffer] -- buffer, clipboard, and custom_object info")
	print(":> help [-l|logs] -- information regarding system.log")
	print(":> help [-s|show|search] -- for a full descriptive list of commands")
	print(colorCyan+":> help [-s|show|search] [word|string|regex] -- search all help info for pattern"+char(10)+"-- see grep -h for regex tokens")
	print(":> help [-i] -- list commands by command map index")
	print(":> help [home] -- information about the @home system")
	print(":> lock -- shortcut for perms lock all")
	print(":> prompt -- toggle full_prompt on and off")
	print(colorCyan+":> [command] [-h|help] -- for more information on a specific command."+char(10))
	return 0
end function

