if DEBUG then print("<size=75%>loading net.5pk v 4.2.8.(149.786)")

command.target = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "-h" or arg1 == "help" then return "Target || Target IP || Target Port"+char(10)+"Usage: target -- return current target ip and port"+char(10)+"Usage: target ip -- returns current target ip"+char(10)+"Usage: target pt -- return current target port"+char(10)+"Usage: target [ip] -- set target ip address (ip must be a valid ip)"+char(10)+"Usage: target -p [port] -- set target port (returns target port if not supplied)"+char(10)+"Usage: target [ip] [port] -- set targt ip and port in a single command"+char(10)+char(10)+"Note: target ip and port are used by 5phinx, transmit, meta, db, probe, and others."
	print char(10)+colorCyan+"</b><u><size=75%>"+CT+colorWhite+"</b>target: processing targetIP and targetPort..."
	if not arg1 then  
		print "<size=75%>target: returning targetIP and targetPort:"
		return globals.targetIP+" "+globals.targetPort
	end if
	if arg1 == "ip" or arg1 == "-i" then 
		if not arg2 or (typeof(arg2) != "string" and typeof(arg2) != "number") then 
			print "<size=75%>target: returning targetIP:"	
			return globals.targetIP
		end if
		if is_valid_ip(arg2) then 
			globals.targetIP = arg2 
			print "<size=75%>target: targetIP set to: "
			return targetIP
		else 
			return "target: invalid target ip"
		end if
	end if
	if arg1 == "-p" or arg1 == "port" or arg1 == "pt" then 
		if arg2 and arg2.to_int >= 0 then 	
			if arg2 then globals.targetPort = arg2.to_int
		else 
			if arg2 == "*" then 
				globals.targetPort = "*" 
			else 
				print "<size=75%>target: returning targetPort:"
				return globals.targetPort
			end if
		end if
		print "<size=75%>target: set targetPort to:"
		return globals.targetPort
	end if
	if is_valid_ip(arg1) then globals.targetIP = arg1 else return "target: invalid ip"
	if arg2 and arg2.to_int >= 0 then 
		globals.targetPort = arg2.to_int 
	else 
		if arg2 == "*" then
			globals.targetPort = "*"
		else
			globals.targetPort = "router"
		end if 
	end if
	print "<size=75%>target: returning targetIP and targetPort:"
	return globals.targetIP+" "+globals.targetPort
end function
command.transmit = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "-h" or arg1 == "help" then return "<b>Transmit</b> -- t_buf transmission protocol"+char(10)+"Usage: transmit [opt: 1|0] --  transmit @t_buf to your @home server. "+char(10)+"-- set @home credentials in 5hell.src before building 5hell"+char(10)+"-- options: 1 == wait for reply, 0 (or blank) == don't wait for reply"+char(10)+"-- use with hashim running on the @home server"
	return globals.transmit(arg1)
end function
command.rsi = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "<b><u>Reverse Shell Interface || RSI Daemon || Install rshell server"+char(10)+
	colorWhite+"</b>Using rsi requires first setting an rshell server. To do so, rent a proxy, then"+char(10)+
	colorWhite+"</b>install librshell.so (usually from your hackshop). Once you have the lib, you can"+char(10)+
	colorWhite+"</b>type <b>rsi install</b> to install and start the server. Then, navigate to your"+char(10)+
	colorWhite+"</b>proxy's router's port 8080 using Browser.exe and forward your desired port to"+char(10)+
	colorWhite+"</b>port 1222 at your server's lan ip. Use this ip and port when placing your rshells."+char(10)+
	colorGreen+"Usage: rsi [opt: -d|-i|install|start|stop] [opt: -r|# ] [opt: #]"+char(10)+char(10)+

	colorLightBlue+"</b>Usage: <b>rsi</b> -- open rshell_interface server"+char(10)+
	"-- access and control connected reverse shell clients"+char(10)+char(10)+

	colorCyan+"</b>Usage: rsi [<b>-d|-D</b>] [opt:-r|#] -- daemon mode"+char(10)+
	"-- listen for connections until an rshell connects"+char(10)+
	"<b>-- opens the last (most recent) rshell on connect"+char(10)+
	"-- ["+colorWhite+"-d"+CT+"] -- listen until 1 or more rshells have connected"+char(10)+
	"---- stops listening immediately if 1 or more rshells are already connected"+char(10)+
	"-- ["+colorWhite+"-D"+CT+"] -- listen until a <b>new</b> rshell has connected"+char(10)+
	"---- use this if you don't want to purge rshells between uses"+char(10)+
	"<b><size=75%>--note: you may pass a menu option that will be executed on the rshell when it connects:"+char(10)+
	"----eg: <b>rsi -d 4</b> -- opens the most recent rshell connection with "+colorLightBlue+"</b>glasspool"+char(10)+
	"----eg: <b>rsi -D 7</b> -- returns the next rshell that connects as an object"+char(10)+
	"----eg: <b>rsi -d 3</b> -- infiltrate the most recent rshell connection"+char(10)+
	"<b><size=75%>--note: you mass pass an option flag that will be executed when an rshell connects"+char(10)+
	"----eg: <b>rsi -D -s</b> -- run silentclean on all rshells when a new rshell connects"+char(10)+
	colorCyan+"</b>Usage: rsi [<b>-r</b>] [#] -- return the shell object at rshell index #"+char(10)+
	"-- eg: rsi [<b>-r</b>] 3  -- returns the rshell at index # as an object"+char(10)+
	colorCyan+"</b>Usage: rsi [<b>#</b>]  -- auto-selects the rshell at index [#] and opens the context menu"+char(10)+
	"<b>Usage: rsi [<b>#1</b>] [<b>#2</b>] -- access the rshell at index #1 and auto select menu option [#2]"+char(10)+
	"-- please note, rshell indexes start at 1 not 0"+char(10)+
	"-- eg: <b>rsi 1 7 | gp</b> -- return the first rshell as an object and open in glasspool"+char(10)+
	"----: identical to:<b> gp -r 1"+char(10)+
	colorGreen+"</b>Usage: rsi [<b>-l</b>] -- return the length of the rsi buffer"+char(10)+
	"-- returns the number as a <b>string</b>"+char(10)+
	colorOrange+"</b>Usage: rsi [<b>-p</b>] [opt:y|exclude1:exclude2:...] "+char(10)+
	"-- close ALL processes on ALL rshells, purging all rshells in the process"+char(10)+
	"-- supplying 'y' by itself will skip confirmation"+char(10)+
	"-- supplying ':' followed by process names or ID's will exclude those processes from the purge"+char(10)+
	"----ie: you may protect individual or named rshells from the purge"+char(10)+
	"---- this also skips confirmation"+char(10)+
	"-- if you wish to exclude a process named 'y' you must pass: <b>y:y"+char(10)+
	"--eg: <b>rsi -p ch4r0n:ps</b> "+char(10)+
	"---- terminate all processes on all rshells except those named ch4r0n and ps"+char(10)+
	"--eg: <b>rsi -p 1024:4186:9009"+char(10)+
	"---- terminate all processes on all rshells except 1024, 4186, and 9009"+char(10)+
	"--eg: <b>rsi -p y</b> -- terminate all processes on all rshells; no exceptions"+char(10)+
	"--eg: <b>rsi -p y:y</b> -- terminate all processes on all rshells except those named 'y'"+char(10)+
	"-- create a "+colorMagenta+"macro"+CT+" with a whitelist to make full use of this"+char(10)+
	colorCyan+"</b>Usage: rsi ["+colorWhite+"-s|-S"+CT+"] -- scrub logs of all rshells (if possible)"+char(10)+
	"-- [<b>-s</b>] -- uses silentclean"+char(10)+
	"-- [<b>-S</b>] -- uses rclean"+char(10)+
	colorCyan+"</b>Usage: rsi ["+colorGold+"-k|-K"+CT+"] -- scrub logs on and remove <b>rkit</b> from all rshells"+char(10)+
	"-- [<b>-k</b>] -- uses silentclean -d to <b>delete rkit</b> and scrub log"+char(10)+
	"-- [<b>-K</b>] -- uses rclean -d to delete rkit and scrub log"+char(10)+
	colorCyan+"</b>Usage: rsi ["+colorRed+"</b>-n|-N"+CT+"] -- nuke all rshells"+char(10)+
	"-- [<b>-n</b>] -- uses silentclean -n"+char(10)+
	"-- [<b>-N</b>] -- uses rclean -n"+char(10)+
	colorGold+"</b>Usage: rsi [<b>-i</b>|install] -- installs the reverse shell server if librshell.so is on the machine"+char(10)+
	"Usage: rsi [<b>start</b>|<b>stop</b>] -- start or stop the installed rshell server"+char(10)+
	colorOrange+"</b>Usage: rsi --export -- return the entire rshell buffer as a list"+char(10)+
	"-- usage example: |> <b>rsi --export | enum -a | enum -b"+char(10)+
	"---- export rsi as a list, enumerate, concatonate the list to the buffer"+char(10)+
	"----ie: add all rshells to the buffer as individual entries"+char(10)+char(10)+
	"NOTE: rsi is not incorporated into the DaemonManager at this time"+char(10)+
	"-- daemon mode ends when an rshell connects"

	if not metaxploit and arg1 != "-i" and arg1 != "install" then return "Error: Can't find metaxploit library in the /lib path or the current folder"
	if not localmachine.is_network_active then return "rsi: no network connection"
	if arg1 == "-p" then return globals.rsi_purge("ALL:"+arg2)//command.purge("-r",arg2,arg3,arg4)
	if arg1 == "stop" then 
		rserver = null
		rserver = include_lib("/lib/librshell.so")
		if rserver then rc = rserver.stop_service else return colorRed+"rsi: /lib/librshell.so not found"+CT
		if rc then return colorGreen + "rsi: service stopped" +CT else return colorOrange + "rsi: service is not running" + CT
	end if
	if arg1 == "start" then 
		rserver = null
		rserver = include_lib("/lib/librshell.so")
		if rserver then rc = rserver.start_service else return colorRed+"rsi: /lib/librshell.so not found"+CT
		if rc then return colorGreen + "rsi: service started" +CT else return colorOrange + "rsi: service is already running" + CT
	end if
	if arg1 == "-i" or arg1 == "install" then 
		rserver = null
		
        lbrs = command.tree("/","librshell.so",1,"N")
        if not lbrs then 
			print "rsi: librshell.so missing"+char(10)+"-- attempting to download..."
			if globals.apt_get then print command.aptm("-i","librshell.so") else return "rsi: aptclientLib not loaded;"+char(10)+"-- unable to obtain librshell.so"+char(10)+"-- aborting..."
		    lbrs = command.tree("/","librshell.so",1,"N")
		end if
		if typeof(lbrs) != "file" then return colorWarning+"rsi:</b> unable to locate or install librshell.so"
		rc = null
        lib = globals.get_file("/lib")
        if not lib then return colorError+"rsi: error;</b> /lib is missing!"

		print "rsi: attempting to install the rshell service..."
        if lib.has_permission("w") and lbrs.has_permission("r") then lbrs.copy("/lib",lbrs.name)
        rserver = include_lib("/lib/librshell.so")
        if not rserver then return colorError+"rsi: failed:</b> librshell.so not installed in /lib"
        rc = rserver.install_service
		if rc then print colorLightBlue+"</b>rsi: service installed" else return colorRed + "rsi: failed to install service:<size=75%> "+rc
		print "To complete setup:"+char(10)+
			colorGreen+"<size=75%>-- Use your Browser.exe to navigate to: "+colorWhite+localmachine.network_gateway+":8080"+char(10)+
			colorGreen+"<size=75%>-- Add an entry that forwards the rshell port:"+char(10)+
			colorGreen+"<size=75%>---- usually port "+colorWhite+"1222"+CT+" to port "+colorWhite+"1222"+char(10)+
			colorGreen+"<size=75%>---- at lan_ip: "+colorWhite+localmachine.local_ip
		brwsr = command.grep("-f","^Browser.exe$")
		if typeof(brwsr) == "file" then 
			opn = user_input(colorLightBlue+"<size=75%>rsi: open "+colorWhite+"Browser.exe "+localmachine.network_gateway+":8080</color>?"+char(10)+colorWhite+"<size=75%></b>[<b>Y</b></b>/n]||: ",0,1)
			if opn != "n" then print command.run(brwsr,localmachine.network_gateway+":8080")
		end if
		return "rsi: task complete"
	end if
	//
	// need a smarter daemon mode
	print(colorLightBlue+"Listening for upcoming connections...")
	locals.rshells = globals.metaxploit.rshell_server
	rs_start_len = rshells.len
	one_loop = true
	d_mode = false
	if arg1 == "-d" or arg1 == "-D" then d_mode = true 
	if arg1 != "-D" then rs_start_len = 0
	listening = true
	while listening//while rshells.len == 0
		rshells = metaxploit.rshell_server
		if typeof(rshells) == "string" then return rshells
		if rshells.len == 0 and not d_mode then 
			if one_loop == false then return colorOrange+"</b>rsi: no reverse shells connected"+char(10)+"-- use<b> rsi -d </b> to run in daemon mode" else one_loop = false
		else 
			if rshells.len > rs_start_len then listening = false
			one_loop = false
		end if
	end while

	if arg1 == "-d" or arg1 == "-D" then 
		arg1 = arg2
		arg2 = arg3 
		arg3 = arg4
	end if
	return_it = false
	if arg1 == "-r" then 
		return_it = true
		ret = 0
		if arg2 then 
			ret = arg2.to_int
			if typeof(ret) != "number" or ret > rshells.len or ret < 1 then return "rsi: invalid index. Note rshell indexes start at 1 not 0"
			print "rsi: returning rshell ["+colorWhite+ret+CT+"]" 
			return rshells[ret - 1]
		end if
		arg1 = arg2
	end if
	if arg1 == "-l" then return str(metaxploit.rshell_server.len)
	if arg1 == "--export" then 
		print colorLightBlue+"rsi: "+colorWhite+"returning rshell buffer as a list..."
		return metaxploit.rshell_server
	end if
	if arg1 == "-s" or arg1 == "-n" or arg1 == "-k" then 
		print "-- scrubbing rshells..."
		football = 0
		time_s = time
		if arg1 == "-n" then football = "-n"		
		if arg1 == "-k" then football = "-d"
		for rs in rshells 
			store = globals.localmachine 
			globals.localmachine = rs.host_computer 
			print command.silentclean(football)
			globals.localmachine = store 
		end for
		return "<size=75%>rsi: task complete in: "+colorOrange+time-time_s+"</color></b> seconds"
	end if
	if arg1 == "-S" or arg1 == "-N" or arg1 == "-K" then 
		print "-- scrubbing rshells..."
		time_s = time
		for rs in rshells 
			if arg1 == "-S" then print command.rclean(rs)
			if arg1 == "-K" then print command.rclean("-d",rs)
			if arg1 == "-N" then print command.rclean("-n",rs)
		end for
		return "<size=75%>rsi: task complete in: "+colorOrange+time-time_s+"</color></b> seconds"
	end if 
	st = arg2
	if d_mode then st = arg1
	if typeof(arg1) == "string" then arg1 = arg1.to_int else arg1 = 0
	option = "0"
	if arg1 then option = arg1
	if d_mode then option = rshells.len

	rs_buf = []
	while typeof(option) != "number" or option > rshells.len or option < 0
		print(colorLightBlue + rshells.len + "</b> shell(s) connected:"+char(10)+"- if your expected shell isn't listed yet"+char(10)+"- press <<b>enter</b>> to refresh the page"+char(10)+"<b>Select a shell to access:"+CT)
		if rshells.len < 1 then return "rsi:"+colorRed+"</b> there are no reverse shells connected"
		rs_buf = []
		for i in range(0, rshells.len - 1)
			rs_buf.push(colorLightBlue+"-----------"+CT+char(10) +colorLightBlue+"Shell (" +colorWhite+ (i + 1) +CT+ ")" +CT+char(10)+ "Public IP: " + rshells[i].host_computer.public_ip + char(10) + "Local  IP: " + rshells[i].host_computer.local_ip + char(10) + colorWhite + command.ps(rshells[i]) )
		end for
		print(rs_buf.join(char(10)).trim)
		print(colorLightBlue+"-----------"+CT)
		option = user_input("Select shell ([0|q] to abort) :> ").to_int
		if option == 0 or option == "q" then return 0
		//wait(.01)
		rshells = metaxploit.rshell_server
	end while
	if option == 0 or option == "q" then return 0
	print("Accessing shell [" + option + "]...")
	ts = rshells[option - 1]
	if return_it == true then 
		print "rsi: returning rshell ["+colorWhite+(option)+CT+"]" 
		return ts
	end if
	print
	print(colorLightBlue+"-----------"+CT+char(10) +colorLightBlue+"Shell (" +colorWhite+ option +CT+ ")" +CT+char(10)+ "Public IP: " + rshells[option - 1].host_computer.public_ip + char(10) + "Local IP: " + rshells[option - 1].host_computer.local_ip + char(10))// + colorWhite + command.ps(rshells[option - 1]))
	print command.ps(rshells[option - 1])
	print colorWhite+"<u>"+colorLightBlue+" = = = = = = = = = = = = = </color>"+CT
	print "[7] return_object [8] fetch_binaries [9] scp"+char(10)+
	      "[4] glasspool [5] rclean [6] run [K] kill"+char(10)+
		  "[1] to_buffer [2] start_terminal [3] upload rkit "
	if typeof(st) != "string" then st = user_input("[q|0] quit ||: ",0,1)
	if st == "0" or st.lower == "q" then return 0
	if st.lower == "k" then print(ts.host_computer.close_program(user_input("kill pid:> ").to_int ) )
	if st == "4" then
		return command.glasspool(ts)
	end if
	if st == "2" then 
		//get_custom_object.return_value = "#!#CASCADE#!#"
		ts.start_terminal
		print colorWhite+"Starting terminal..."
	end if
	if st == "3" then return command.infil(ts)
	if st == "9" then
		if GLASSPOOL then
			print(colorLightBlue+"GLASSPOOL: "+colorOrange+"active"+colorLightBlue+" on: "+CT)
			print(colorWhite+globals.shell.host_computer.local_ip+"@"+globals.shell.host_computer.public_ip+CT)
			print("Upload from / Download to the linked filesystem:")
		end if
		return globals.secure_copy(ts)
	end if
	if st == "1" then
		BUFFER.push(ts)
		return "Shell sent to "+colorOrange+"BUFFER"
	end if
	if st == "5" then return globals.rclean(ts)
	if st == "6" then
		cpath = user_input("command_path:> ",0,0)
		if cpath == "" then return "rsi: aborting..."
		para = user_input("params:> ",0,0)
		globals.stack_pool("up")
		print(ts.launch( cpath,para ))
		//_cascade // exit if cascade
		globals.stack_pool("down")
	end if
	if st == "7" then  
		print "rsi: returning shell object"
		return ts
	end if
	if st == "8" then 
		destiny = user_input(colorWhite+"destination folder [q=quit]:> </b><u>")
		if destiny.lower != "q" then 
			fldr = globals.get_file(destiny)
			if fldr and typeof(fldr) == "file" and fldr.is_folder and fldr.has_permission("w") then return globals.get_binaries(ts, fldr) else return "rsi: invalid destination: check path and/or permissions"
		end if
	end if
	return "rsi: exiting..."
end function
command.scpm = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "SCPM: 5hell.SCP Menu"+char(10)+"Usage: scpm -- from menu select target shell (active shell is shown with an '*'). "+char(10)+"-- input source path and then destination path at prompts."+char(10)+"-- select upload or download. Note the printed trajectories."+char(10)+"-- (these can change when glasspool is involved)."+char(10)+"-- if uploading indicate if editing permissions"+char(10)+"-- if editing permissions press <b>enter</b> for defaults"+char(10)+"-- default is <b>o+rwx</b> before uploading and then o-rwx after uploading."+char(10)+"Always mind permissions! Type lock constantly to feel secure."+char(10)+"Advanced: scpm [string_path|piped_file] -- open scpm menu with path or file.path tagged for scp"+char(10)+"Advanced: scpm [piped_shell] -- skip menu and scp to/from piped shell"+char(10)+"E.G. - clipb @B 1 | scpm -- use the shell object from buffer[1] with .scp"+char(10)+char(10)+"<b>New: scpm [opt:-u|-d] [opt:copy_from|file_object_from] [opt:copy_to|file_object_to] [opt:shell_object]"+char(10)+"-- -u will force upload and skip permissions prompt"+char(10)+"-- -d will force download"+char(10)+"-- supplying path_from will skip copy_from prompt"+char(10)+"-- supplying path_to (must be after path_from) will skip destination prompt"+char(10)+"-- supply a shell will skip shell prompt"+char(10)+"-- supplying all will skip all prompts"+char(10)+"-- parameters may be in any order except path_from must precede path_to"+char(10)+"---- eg: clipb @B 1 | scpm /root/rkit /home/guest | run /home/guest/rkit/5hell "+char(10)+"---- eg: clipb @B 1 |  | scpm /root/rkit @b"+char(10)+"---- eg: zap [mem] [vuln] | scpm -d /var/system.log /root"
	target_shell = null
	target_path = null
	direction = -1 
	skip = 0
	paths = []
	if DEBUG then print "debug: in scpm top"+char(10)+"debug: tagged4scp: "+ globals.tagged_for_scp
	while arg1 
		if arg1 == "-d" then 
			direction = 1 // force download, skip confirmation
			if DEBUG then print "debug: setting direction to: "+direction
		else 
			if arg1 == "-u" then 
				skip = 1
				direction = 0
				if DEBUG then print "debug: setting skip to: "+skip
			else
				if typeof(arg1) == "string" then paths.push(arg1)
			end if
		end if
		if typeof(arg1) == "file" then paths.push(arg1.path)
		if typeof(arg1) == "computer" then return "scpm: computer object is an invalid input."+char(10)+"  valid inputs: string_path, shell, file"
		if typeof(arg1) == "shell" or typeof(arg1) == "pshell" then 
			if p_validate(arg1,"scp") then target_shell = arg1 else return "scpm: error, scp function not found in (p)shell object."
		end if
		arg1 = arg2 
		arg2 = arg3 
		arg3 = arg4 
		arg4 = 0
	end while 
	if paths != [] then 
		paths.push(0)
		globals.tagged_for_scp = paths[0]
		target_path = paths[1]
	end if
	if DEBUG then print "debug: in scpm middle"+char(10)+"debug: tagged4scp: "+ globals.tagged_for_scp
	if DEBUG then print "debug: dir: "+direction+ " skip: "+skip
	if direction == 1 and skip == 1 then return "scpm: invalid inputs cannot mix -d and -u"
		// the pick a shell menu
	if not target_shell then
		temp_buf = []
		for b in BUFFER
			if typeof(b) == "shell" or typeof(b) == "ftpshell" or (typeof(b) == "pshell" and p_validate(b,"scp")) then temp_buf.push(b)
		end for
		r_index = temp_buf.len
		if metaxploit then
			r_buf = metaxploit.rshell_server
			if typeof(r_buf) != "string" then temp_buf = temp_buf + r_buf
		end if
		ti = 0
		print(colorLightBlue+"<size=85%><mark=blue>======================================================================</mark></size>"+CT)
		active_icon = "<b> - </b>"
		print("<u>BUFFER contains: "+temp_buf.len+" (r)shell(s) ["+colorWhite+"0"+CT+"] == localhost "+colorCyan+"*"+CT+" == "+colorCyan+"active shell"+CT+"</u>"+char(10)+"<size=75%><u>"+colorLightBlue+" rshells "+CT+"are listed after"+colorOrange+" BUFFER "+CT+"shells. rshells in BUFFER will be listed twice.</size></u>")
		color_shelle = colorOrange
		she_buf = []
		for tb in temp_buf
            if typeof(tb) == "pshell" then 
                she_buf.push("["+colorWhite+ti+CT+"]"+active_icon+""+color_shelle+"["+checkUser(tb)+":"+typeof(tb)+"]")
                active_icon = "<b> - </b>"
			    ti = ti + 1
                continue
            end if
			if tb.host_computer.public_ip == globals.shell.host_computer.public_ip and tb.host_computer.local_ip == globals.shell.host_computer.local_ip then active_icon = colorCyan+" * "+CT
			if ti >= r_index then color_shelle = colorLightBlue
			she_buf.push("["+colorWhite+ti+CT+"]"+active_icon+""+color_shelle+"["+checkUser(tb)+":"+typeof(tb)+"] "+CT+tb.host_computer.local_ip+" @ <b>"+tb.host_computer.public_ip+"</b>")
			active_icon = "<b> - </b>"
			ti = ti + 1
		end for
		print(she_buf.join(char(10)))
		slect = user_input("select a <b>target</b> shell (q=quit):> ").to_int
		if typeof(slect) != "number" then return "aborting..."
		if slect >= 0 and slect < temp_buf.len then
			target_shell = temp_buf[slect]
		else
			return "aborting..."
		end if
	end if
	if DEBUG then print "debug: scpm bottom: tar_path: "+target_path+" t_file: "+globals.tagged_for_scp
	return globals.secure_copy(target_shell, target_path, direction, skip)
end function
command.iwlist = function(arg1, arg2=0, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "<u>iwlist || wifi networks "+char(10)+
	colorGreen+"Usage: iwlist -- returns a string containing all wifi networks in range"+char(10)+
	"-- displays bssid, essid, and signal strenghth (power)"+char(10)+
	"-- note: use <b>ifconfig -w</b> or <b>air</b> to connect wifi"+char(10)+
	"Usage: iwlist [-a|air] -- uses the command:<b> air false</b> to display network info "
	nets = localmachine.wifi_networks("wlan0")
	print colorGreen+"<u><size=75%>"+colorWhite+"- - - - - - wifi networks - - - - - -"
	if arg1 == "-a" or arg1 == "air" then
		return command.air("false")
	else 
		if typeof(nets) == "list" then return nets.join(char(10))
	end if
	return nets	
end function
command.ifconfig = function(arg1=0, arg2=0, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then 
		clb = colorLightBlue
		return "ifconfig || iwconfig || wifi || ethernet || internet || gateway || router"+char(10)+
			"Usage: ifconfig [opt:"+clb+"-l|-p|-c|-w|-g|-d"+CT+"] --  returns network interface information"+char(10)+char(10)+
			"Usage: <b>ifconfig</b> -- returns connection status and ip information of active computer object"+char(10)+char(10)+
			"Usage: ifconfig ["+clb+"-l"+CT+"|local] -- returns the lan ip of the active computer object"+char(10)+
			"-- respects glasspool"+char(10)+char(10)+
			"Usage: ifconfig ["+clb+"-p"+CT+"|public] -- returns the public ip of the active object computer object"+char(10)+
			"-- respects glasspool"+char(10)+char(10)+
			"Usage: ifconfig ["+clb+"-c"+CT+"|connect] [desired_lan_ip] [desired_gateway] "+char(10)+
			"-- connect via ethernet to gateway and request lan_ip."+char(10)+
			"-- useful for bypassing firewalls, in some cases"+char(10)+char(10)+
			"Usage: ifconfig ["+clb+"-w"+CT+"|wifi] [essid|bssid] [passkey] -- manually connect to a wifi network"+char(10)+
			"-- the computer must be in range of the wifi network in order to connect"+char(10)+
			"-- this a slightly simpler iwconfig:"+char(10)+
			"---- you pass an essid OR a bssid, not both"+char(10)+
			"-- note: use <b>air</b> for cracking wifi networks or accessing wifi via a menu"+char(10)+char(10)+
			"Usage: ifconfig ["+clb+"-g"+CT+"|gateway] -- returns the lan ip of the active object's gateway (router)"+char(10)+char(10)+
			"Usage: ifconfig ["+clb+"-d"+CT+"|devices] -- list network devices on active computer object"+char(10)
		end if
	print colorGreen+"- - - - - - - - - - - - - - - - - - - - - - -"
	dat = []
	globals.localip = globals.localmachine.local_ip
	globals.pubip = globals.localmachine.public_ip
	if arg1 == "-l" or arg1 == "local" or arg2 == "-l" or arg2 == "local" then dat.push(localip)// ?? #whyemoji.gif
	if arg1 == "-p" or arg1 == "public" or arg2 == "-p" or arg2 == "public" then dat.push(pubip)// ??
	if arg1 == "-d" or arg2 == "-d" or arg1 == "devices" or arg2 == "devices" then// ??
		dat.push("___")
		dat.push(localmachine.network_devices)
	end if
	if arg1 == "-w" or arg1 == "wifi" then 
		if not arg3 then return "ifconfig: -w expects [essid|bssid] [passykey]"
		if not localmachine.active_net_card == "WIFI" then return "iwconfig: no active WIFI card"
		dev = localmachine.network_devices
		if dev.indexOf("wlan0") != null then dev = "wlan0"
		if dev.indexOf("wlan1") != null then dev = "wlan1"
		essid = 0
		bssid = 0
		networks = localmachine.wifi_networks(dev)
		if DEBUG then print "debug: networks: "+networks.join(char(10))
		for net in networks 
			net = net.split(" ")
			if net[0] == arg2 or net[2] == arg2 then 
				bssid = net[0]
				essid = net[2]
			end if
		end for
		if DEBUG then print "debug: essid: "+essid+" bssid: "+bssid
		if not essid or not bssid then return "ifconfig: error; no such wifi network"
		return localmachine.connect_wifi(dev,bssid,essid,arg3)
	end if
	if arg1 == "-c" or arg1 == "connect" then
		device = "eth0"
		address = arg2
		gateway = arg3
		if not is_valid_ip(address) then return("ifconfig: invalid ip address")
		if not is_valid_ip(gateway) then return("ifconfig: invalid gateway")
		output = localmachine.connect_ethernet(device, address, gateway)
		return output
	end if
	if arg1 == "-g" or arg1 == "gateway" then return localmachine.network_gateway
	if arg1 == 0 and arg2 == 0 then //dat.push(pubip)
		if localmachine.is_network_active then
			router = get_router(localmachine.network_gateway)
			if not router then 
				dat.push("ifconfig: error: gateway: "+localmachine.network_gateway)
			end if
			dat.push("Connected to: "+localmachine.active_net_card)
			if localmachine.active_net_card == "WIFI" then
				if router then dat.push("<b>"+router.essid_name+"</b>")
				if router then dat.push(router.bssid_name)
			end if
			dat.push(localmachine.network_gateway+char(10)+"<b>"+localmachine.public_ip+char(10)+"<b>"+localmachine.local_ip)
		else
			dat.push(char(10)+"No active network connection."+char(10))
		end if
	end if
	return dat.join(char(10))
end function
command.air = function(arg1, arg2=0, arg3=0, arg4=0) // requires crypto.so
	if arg1 == "help" or arg1 == "-h" then return "AIR || aircrack || aireplay || airmon || wifi cracker"+char(10)+
	"Usage: air -- aircrack menu"+char(10)+
	"-- allows cracking and/or connecting to in-range wifi networks"+char(10)+
	"-- auto-calculates ACKS needed for cracking"+char(10)+
	"-- renames resulting file.cap to [wifi_essid].cap"+char(10)+
	"-- once cracked you may press enter to save the file to current path"+char(10)+
	"---- or type a <b>folder path</b> to move the file to that folder"+char(10)+
	"-- will read .cap files from anywhere on the system"+char(10)+
	"Legend:"+char(10)+
	"Networks appearing in: "+colorGreen+"green"+CT+" have a cracked .cap file"+char(10)+
	"Networks appearing in: "+colorOrange+"orange"+CT+" do not have a cracked .cap file"+char(10)+char(10)+
	"Usage: air [-f|false] -- same as the <b>iwlist</b> command"+char(10)+
	"-- returns wifi networks in range as a string"+char(10)+char(10)+
	"Usage: air [-c] [/path_to_file.cap] -- uses aircrack to return passkey from file.cap"+char(10)+char(10)+
	"Usage: air [-a] [essid|bssid] -- run aireplay on a network from the command line"+char(10)+
	"-- you may supply <b>either</b> bssid or essid, not both"+char(10)+char(10)+
	"Advanced: A wifi network might have a <b>nested wifi signal</b> within it"+char(10)+
	"-- select option [<b>h</b>] within air to activate detection of nested wifi signals"+char(10)+
	"-- you must be on the nested signal's host wifi network in order to detect and connect to it"+char(10)+
	"-- this allows bypassing firewalls in many instances"+char(10)+
	"-- this does not translate through GLASSPOOL"+char(10)+char(10)+
	"NOTE: you may use:"+char(10)+
	"----: <b>ifconfig ["+colorLightBlue+"-w</color>] [essid|bssid]"+char(10)+
	"-- to manually connect to a wifi network"+char(10)+
	"-- see <b>ifconfig -h</b> for more"
	print("AirMenu v 0.1.3, by Plu70")
	is_it_known = function(a)
		chrom = ""
		line = a.split(" ")
		//p = "/"
		//if globals.currentPath != "/" then p = globals.currentPath + "/"
		//file = localmachine.File(p + line[2]+".cap")
		file = command.tree("/",line[2]+".cap",1,"N")
		if file then
			chrom = colorGreen
		else
			chrom = colorOrange
		end if
		parsed_data = chrom + a + CT
		return parsed_data
	end function
	data_stream = function(alist)
		data = ""
		i = 0
		for element in alist
			data = data + "[" + colorWhite + i + CT + "] " + is_it_known(element) + char(10)
			i = i + 1
		end for
		return data
	end function

	scan_wifi = function(waitFor=false,detect_hidden,wego)
		if waitFor == "-a" then waitFor == "a"
		print(command.ifconfig)
		dev = localmachine.network_devices
		dsp = dev.split(char(10))
		wl = false
		if DEBUG then print "debug: is_net_act: "+localmachine.is
		if not localmachine.active_net_card == "WIFI" then 
			print("air: error: network is inactive",0,1)
			return 0 
		end if
		mon = false
		if not globals.crypto then print("<size=75%>Warning: crypto.so not found; aireplay is unavailable")
		if not crypto.airmon("start", "wlan0") then print("<size=75%>Warning: monitor mode not enabled"+char(10)+"-- aireplay unavailable",0,2) else mon = true
		print(colorGreen+"- - - - - - - - - - - - - - - - - - - - - - -"+CT)
		print(format_columns("DEV NAME MON"+char(10)+dev))
		bssid = "temp"
		essid = "temp"
		power = "temp"
		ip = localmachine.public_ip
		if detect_hidden == 2 then print("Probing for nested signals on local network: "+char(10)+ip)
		print("<align=center><b>(>|<)</b></align>")
		networks = localmachine.wifi_networks("wlan0")
		output = []
		if DEBUG then print("dh: "+detect_hidden)
		if detect_hidden == 2 then
			if not localmachine.is_network_active then
				print("No network detected.")
				return 1
			end if
			router = get_router( ip )
			if not router then return "air: router not found"
			clist = router.devices_lan_ip
			if DEBUG then print("clist: "+clist)
			output = []
			for c in clist
				rw = get_router(c)
				if typeof(rw) != "router" then continue
				if DEBUG then print(rw.local_ip)
				if rw.local_ip == router.local_ip then continue
				if DEBUG then 
					for r in rw 
						print r 
					end for 
				end if					
				if rw.essid_name and networks.indexOf(rw.essid_name) == null then
					wire = rw.bssid_name+ " 100% " +rw.essid_name
					output.push(wire)
				end if
			end for
			if output.len then
				print( "Found "+output.len+" nested wireless signal(s): ")
				print(output.join(char(10)) + char(10) + "<b>- - - - - - - - - - - - - - - - </b>")
			else
				print("No nested wireless signals found.")
			end if
		end if
		networks = networks + output
		print(data_stream(networks))
		//waitFor = false
		//if a1 and a1 == "false" then waitFor = "false"
		if not waitFor then waitFor = user_input("Select a network # ( m=manual, h=detect_hidden, q=quit )"+char(10)+":> ")
		if waitFor == "h" or waitFor == "H" then
		 	if globals.GLASSPOOL then 
				print(colorOrange+"Aborting: Operation not possible via GLASSPOOL."+CT)
				return 0
			end if
			return 2
		end if
		if waitFor isa string and waitFor.to_int isa number then waitFor = waitFor.to_int
		if waitFor < networks.len and waitFor >= 0 and typeof(waitFor) == "number" then	
			memory = networks[waitFor].split(" ")
			print(memory)
			bssid = memory[0]
			power = memory[1]
			essid = memory[2]
		else
			if waitFor == "m" then
				bssid = user_input("bssid:> ")
				essid = user_input("essid:> ")
				if bssid == "" or essid == "" then return 0
				power = user_input("estimated_power must be non-zero. If internal (hidden) wifi use 100 or 100%  "+char(10)+"estimated_power:> ")
				if power == "" then return 0
				memory = [bssid, power, essid]
			else
				if wego then 
					for net in networks
						net = net.split(" ")
						if wego == net[0] or wego == net[2] then 
							bssid = net[0]
							power = net[1]
							essid = net[2]
						end if
					end for
				else 
					return 0
				end if
			end if
		end if
		passw = null
		cap_fl = command.tree("/",essid+".cap",1,"N")
		if typeof(cap_fl) == "file" then passw = crypto.aircrack( cap_fl.path )
		if passw and not wego then
			print(passw + "@" + bssid)
			print("Connection status: [" + localmachine.connect_wifi("wlan0", bssid, essid, passw) + "]"+char(10))
			wait(1)
			return detect_hidden
		end if
		max = (300000 / (( power.remove("%").val) + 15 ))
		if typeof(max) != "number" then return colorError+"air: critical error; max acks == "+max
		print
		print colorGold+"AIR: Options:"
		print(colorGold+"["+colorWhite+"C</color>]redentials -- connect to the wifi network using the known key"+char(10)+"-- requires knowing the key")
		if max > 20000 then print colorWhite+"vvvvvvvv "+colorCyan+"recommended"+CT+" vvvvvvvv"
		print(colorGold+"["+colorWhite+"B</color>]rutus -- attempt to brute force the wifi key using tables/tp"+char(10)+"-- can take upwards of 20 minutes")
		if max > 20000 then print colorWhite+"^^^^^^^^ "+colorCyan+"recommended"+CT+" ^^^^^^^^"
		print
		if max <= 20000 then print colorWhite+"vvvvvvvv "+colorCyan+"recommended"+CT+" vvvvvvvv"
		print(colorCyan+"["+colorWhite+"A</color>]ir -- uses aireplay and aircrack"+char(10)+"-- obtains the key through packet sniffing"+char(10)+"-- time to crack is based on signal strength"+char(10)+"-- acks_needed == 300000 / (pwr + 15)"+char(10)+":: "+colorCyan+max)
		if max <= 20000 then print colorWhite+"^^^^^^^^ "+colorCyan+"recommended"+CT+" ^^^^^^^^"
		print
		print("Note: "+colorCyan+"press enter"+CT+" to default to using Air (recommended)")
		if wego then brut = "a" else brut = user_input("Please enter your selection: [c/b/<b>A</b>] (anything else to abort)"+char(10)+"||: <b>",0,1)
		if brut == "" then brut = "a"
		if brut != "b" and brut != "c" and brut != "a" then return "aborting..."
		if brut == "b" then
			d_count = 0
			time_s = time
			print("Trying: "+colorGold+dict_a.len+CT+" passwords..."+char(10)+"<b>This may take some time...</b>")
			for d in globals.dict_a
				try = localmachine.connect_wifi("wlan0", bssid, essid, d)
				if try == 1 then
					print(d+"@"+bssid)
					print("Connection status: [" + try + "]"+char(10))
					wait(1)
					return detect_hidden
				end if
				d_count = d_count + 1
				if d_count > 1000 then
					d_count = 0
					print(" working for: "+colorOrange+( (time - time_s) / 60 )+CT+" minutes...")
				end if
				wait(.01)
			end for
		end if
		if brut == "c" then
			ur_p = user_input("network credentials (q=quit):> ")
			if ur_p == "q" then return "aborting..."
			try = localmachine.connect_wifi("wlan0", bssid, essid, ur_p)
			if try == 1 then print(essid+" @ "+bssid) else try = colorRed+try+CT
			print("Connection status: [" + try + "]"+char(10))
			return detect_hidden
		end if
		// brut == a
		if not mon then
			print("Error: monitor mode not enabled; aborting...",0,1)
			return 0
		end if
		print colorGold+"air: invoking aireplay..."
		print(colorGreen+"Please ensure there are no files named "+colorWhite+"file.cap</color> on this machine.")
		if typeof(command.tree("/","file.cap",1,"N")) == "file" then 
			caps = command.grep("-a","^file.cap$","/")
			cw = colorWhite
			for c in caps
				print "air: "+colorWhite+c.path
				d = user_input("Do you wish to ["+cw+"d"+CT+"]elete, ["+cw+"r"+CT+"]ename, or ["+cw+"m"+CT+"]ove this file?"+char(10)+"Press <b>anything else</b> to skip (file may be overwritten!)"+char(10)+"||: ",0,1).lower
				if d == "d" then print command.rm(c)
				if d == "r" then 
					nn = user_input("Please enter a new name for: "+c.path+char(10)+"(leave blank to abort):> <b>")
					if nn == "" then 
						print ("air: rename aborted...")
						continue 
					end if
					sl = "/"
					if c.parent.path == "/" then sl = ""
					print command.mv(c,c.parent.path+sl+nn)
				end if
				if d == "m" then print command.mv(c,user_input("Please enter the new path for: "+c.path+char(10)+":> <b>"))
			end for
		end if
		//max = (300000 / ( power.remove("%").val) + 15 )
		max = max + 10 // just in case
		if not globals.crypto then return colorError+"<size=75%>air: error: crypto.so not found"
		if globals.DEBUG then print "debug: bssid: "+bssid+" essid: "+essid+" max: "+max
		status = crypto.aireplay(bssid, essid, max)
		if status then print(status) else print("Scan complete.")
		print("Processing...")
		wait(2)
		// find the cap file
		//cap = globals.get_file(home_dir+"/file.cap")
		cap = command.tree("/","file.cap",1,"N")
		if typeof(cap) == "file" then
			catch = cap.move(globals.currentPath, essid+".cap")
			if catch then print(catch)
		else
			print("Error! file.cap not found.")
		end if
		cap = globals.get_file(essid+".cap")
		if not cap then
			print("Error. Failed to rename file.cap to " + essid+".cap")
		else
			print("...file saved as " + essid+".cap")
			print("The key is:<b> "+crypto.aircrack(globals.currentPath + "/" + essid + ".cap")+"</b>")
			if user_input(colorCyan+"Would you like to move "+cap.path+" to another folder? "+char(10)+"[<b>N</b>/y] ||: ",0,1).lower == "y"then
				dir = user_input(colorCyan+"Please enter the destination folder (relative paths accepted): "+char(10)+"(<<b>enter</b>>=abort):> ")
				if dir.trim == "" then return "aborting..."
				return command.mv(cap.path,dir)
			end if
		end if
		return detect_hidden
	end function
	scw = 1
	if arg1 == "-f" then arg1 = "false" // iwlist mode
	if arg1 == "-c" then
		if arg2 then
			cap = globals.get_file(arg2)
			if cap then return "air_crack: key:\n<b>"+crypto.aircrack(cap.path)+"</b>" else return "air_crack: "+arg2+" not found."
		else
			return "usage: air -c [/path_to_file.cap] -- uses aircrack to return passkey from file.cap"
		end if
	end if
	goto = 0
	if arg1 == "-a" then
		if not arg2 then return "air: [-a] expects essid or bssid; aborting..." else goto = arg2 
	end if
	while scw
		scw = scan_wifi(arg1,scw,goto)
		arg1 = 0
		goto = 0
	end while
	return "air: exiting..."
end function
command.probe = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "<u><b>probe || nmap || portscan"+char(10)+char(10)+
	colorWhite+"Usage: probe [optional: ip] [optional: port] -- standard whois and portmap"+char(10)+
	"-- sets global target ip and port when invoked"+char(10)+
	colorWhite+"Usage: probe -f [opt:ip] [opt:port] -- full scan; akes longer "+char(10)+
	"-- gets all reachable, non-firewalled machines on subnet."+char(10)+
	"-- in many cases it will retreive the same machine list as a standard probe"+char(10)+
	colorWhite+"Usage: probe [-s|show] -- display currently loaded portmap and whois info"+char(10)+
	"-- when local on a network, probe each router by LAN ip to probe that subnet"+char(10)+
	colorWhite+"Quick: probe -q [opt:ip] [opt:port] -- quick scan"+char(10)+
	"-- gets only surface level machines on subnet"+char(10)+
	colorWhite+"Quicker: probe -q -- quick localnet scan"+char(10)+
	"Note: in all cases probe will set target ip and target port."+char(10)+char(10)+
	colorWhite+"Legend:"+char(10)+
	colorRed+"-- red: switch or firewall or closed port"+char(10)+
	"-- a switch is a hardware firewall that cannot be disabled"+char(10)+
	"-- internal ports are always open when accessed via lan ip"+char(10)+
	"---- unless they are firewalled"+char(10)+
	colorGreen+"-- green: open port (includes gateway and internal)"+char(10)+
	colorMagenta+"-- magenta: non-switch router/machine with port 8080"+char(10)+
	"-- this port is open only when inside the network"+char(10)+
	colorCyan+"-- cyan: known lib"+char(10)+
	colorGold+"-- gold: unknown lib"+char(10)+
	colorOrange+"-- orange: no database found"+char(10)+
	colorWhite+"-- white: machine/server/phone"+char(10)+
	colorGrey+"-- grey: lanip: not connected to gateway"+char(10)+
	"---- when probing remotely; machine is part of an inner subnet"+char(10)+
	"------ or the machine does not exist or the machine is busted"+char(10)+
	"---- when probing locally; the machine does not exist or is busted"+char(10)+
	colorGrey+"-- grey: port info: no lib.so / no response"+char(10)+
	colorLightBlue+"NOTE:"+CT+" if both port info and lan ip are grey;"+char(10)+
	"-- the machine likely does not exist (but not always)"
	if not localmachine.is_network_active then return "probe: no network connection."
	if arg1 == "-b" then 
		if PORT_MAP then return globals.brdc else return "probe: error; no portmap loaded"
	end if
	if arg1 =="-s" or arg1 == "show" then
		if PORT_MAP then return globals.last_whois+char(10)+globals.brdc+char(10)+"- - - - - - - - - - - - - - -"+char(10)+globals.display_portmap(1) else return "probe: error; no portmap loaded"
	end if
	if arg1 then globals.targetIP = arg1
	if arg2 then globals.targetPort = arg2.to_int
	get = 15
	if arg1 == "-f" then
		if arg2 then globals.targetIP = arg2
		if arg3 then globals.targetPort = arg3.to_int
		get = 255
	end if
	if arg1 == "-q" then
		if arg2 then globals.targetIP = arg2 else globals.targetIP = command.ifconfig("-p")
		if arg3 then globals.targetPort = arg3.to_int else globals.targetPort = "router"
		get = 2
	end if
	if not arg1 or not is_valid_ip(globals.targetIP) or (arg1 == "-f" and not arg2) then set_ip
	if not arg2 or ( (arg1 == "-f" or arg1 == "-q") and not arg3) then globals.targetPort = "router"
	if arg4 and arg4 == "1" then
		return who_scan(get,0,1)
	end if
	return who_scan(get,0,0)
	return 0
end function
command.lanpro = function(arg1, arg2=0, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "Usage: lanpro [ip] -- full lan scan"+char(10)+
	"-- returns newline delimited string of lan ip's"+char(10)+
	"-- does not autoset ip or portmap for 5phinx, Use<b> probe [ip]</b>instead."
	if not localmachine.is_network_active then return "lanpro: no network connection."
	get = null
	t = time
	if is_valid_ip(arg1) and not is_lan_ip(arg1) then 
		if get_router(arg1).public_ip == get_router.public_ip then 
			print colorLightBlue+("</b>lanpro: running locally on "+arg1)
			if typeof(get_router(arg1)) == "router" then get = globals.lan_probe(get_router(arg1))
		else
			print colorLightBlue+("</b>lanpro: running remotely on "+arg1)
			get = globals.lan_probe(get_router(arg1),"remote")
		end if
	end if 
	if not arg1 then 
		print colorLightBlue+("</b>lanpro: running locally on local gateway")
		get = globals.lan_probe(get_router)
	end if
	if is_lan_ip(arg1) then 
		print colorLightBlue+("</b>lanpro: running locally on "+arg1)
		if typeof(get_router(arg1)) == "router" then get = globals.lan_probe(get_router(arg1))
	end if
	print colorLightBlue+"lanpro: task complete in "+colorWhite+(time-t)+"</color> seconds"
	if not get then return "lanpro: invalid argument or router unreachable" else return get
end function
command.nsl = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "-h" or arg1 == "help" then	return "<u>nsl || nslookup || reverse ip lookup || domain to ip</u>"+char(10)+
	"Usage: nsl [opt:-t] [ip|domain] -- uses nslookup on ip|domain and returns domain|ip as a string"+char(10)+
	"Example:<b> nsl www.burger.org | probe </b> -- gets the ip of burger.org and pipes to probe."+char(10)+
	"NOTE: nsl will append <b>www.</b> to a domain if it is omitted."+char(10)+
	"Usage: nsl [ip] -- returns domain linked to ip (reverse lookup)"+char(10)+
	"Usage: nsl [domain] -- returns ip linked to domain (normal lookup)"+char(10)+
	"Ope: [-t] -- passing -t as first param will set global targetIP to ip"
	
	if not localmachine.is_network_active then return "nsl: no network connection."
	print "<u>"+colorGold+"= = = = NSLOOKUP = = = ="
	set_targ = false
	if arg1 == "-t" then 
		set_targ = true 
		arg1 = arg2 
		arg2 = arg3 
		arg3 = arg4 
	end if
	if not arg1 then arg1 = command.ifconfig("-p")
	if typeof(arg1) != "string" then return "nsl: invalid input"
	address = arg1
	if typeof(address) != "string" then return "nsl: expects string"
	print "Address: "+address//+char(10)
	if is_valid_ip(address) then 
		if DEBUG then print "debug: reverse nsl lookup"
		who_string = whois(address) 
		if DEBUG then print "debug: who_string: "+who_string
		domain = who_string.split(char(10))[0].split(":")[1]
		print colorLightBlue+"<u>Domain: "
		if set_targ == true then 
			print domain.trim
			return command.target("ip",address,"router") 
		else 
			return domain.trim
		end if
	end if
	prefix = address[0:4]
	if DEBUG then print("debug_prefix:["+prefix+"]")
	if prefix != "www." then address = "www."+address
	if DEBUG then print("debug_address:"+address)
	print(colorLightBlue+"<u>IP: ")
	addy = nslookup(address)
	if DEBUG then print "addy: "+addy
	if set_targ == true then return command.target("ip",addy,"router")
	return addy.trim
end function
command.ping = function(arg1, arg2=0, arg3=0, arg4=0)
	if not arg1 or arg1 == "-h" or arg1 == "help" then return command_info("ping_usage")+char(10)+"Note: returns a string."
	if not localmachine.is_network_active then return "ping: no network connection."
	if not is_valid_ip(arg1) then return command_info("ping_usage")
	time_s = time
	catch = shell.ping(arg1)
	time_e = ( (time - time_s) * 1000 )
	if DEBUG then print("catch: "+catch)
	if catch == true then
		if typeof(catch) == "string" then
			return catch
		else
			print(colorLightBlue+"Ping "+colorWhite+arg1+"</color>: successful"+CT)
			color_time = colorOrange
			if time_e < .03 then color_time = colorGreen
			if time_e > .1 then color_time = colorRed
			return colorLightBlue+"Ping: packet round trip: "+CT+color_time+time_e+CT+colorLightBlue+" ms."+CT
		end if
	else
		return colorRed+"ping: "+arg1+" unreachable."
	end if
	return 0
end function
command.whois = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "-h" or arg1 == "help" then return "WHOIS || whois information || network info"+char(10)+
		"Usage: whois [opt:-t] -- returns local netowrk whois information if no params given"+char(10)+
		"Usage: whois [opt:-t] [ip] --  returns whois information for given ip"+char(10)+
		"--eg: whois 1.1.1.1"+char(10)+
		"Usage: whois [opt:-t] [-nb|--getbox] -- run whois on a loop until a Neurobox Network is found"+char(10)+
		"-- avg runtime is less than 20 seconds"+char(10)+
		"-- search automatically terminates if runtime exceedes 1 minute"+char(10)+
		"Opt: [-t] - passing -t as first argument sets global targetIP to ip"+char(10)+
		"--eg: whois -t 1.2.34"+char(10)+
		"--eg: whois -t -nb"+char(10)+
		"--eg: whois -t"+char(10)+
		"Note: flag order matters: -t must come first if it is used"
		"Note: [-t] option sets targetPort to ""router"" "
	
	set_targ = false
	if arg1 == "-t" then 
		set_targ = true 
		arg1 = arg2 
		arg2 = arg3 
		arg3 = arg4
	end if
	if not arg1 then 
		if set_targ then print command.target("ip", localmachine.public_ip, "router" )
		return "<size=75%>whois: returning localhost whois information:"+char(10)+whois(globals.pubip).replace("Neurobox Network",colorCyan+"<size=125%>_Neurobox_Network_</size>"+CT)
	end if
	if arg1 == "--getbox" or arg1 == "-nb" then 
		found = false
		time_s = time
		while not found 
			if time_s-time>60 then return "whois: search exceeded 60 seconds: terminating search"
			ip = command.rnip("1")
			string = whois(ip)
			if string.indexOf("[Neurobox") != null then 
				found = true
				if set_targ then print command.target("ip",ip,"router")
			end if
		end while
		return string.replace("Neurobox Network",colorCyan+"<size=125%>Neurobox Network</size>"+CT)
	end if 
	if not is_valid_ip(arg1) then 
		arg1 = command.nsl(arg1) 
		if not is_valid_ip(arg1) then return "whois: invalid ip or domain" else print arg1
	end if
	if set_targ then print command.target("ip", arg1, "rotuer")
	print char(10)+"<size=75%>whois: returning info:"
	return whois(arg1).replace("Neurobox Network",colorCyan+"<size=125%>Neurobox Network</size>"+CT)
end function
command.ssh = function(arg1, arg2, arg3=0, arg4="ssh")
	ssh_help = function()
		return "Secure Shell Protocol"+char(10)+"Usage: ssh [user@pass] [ip] [optional:pt (default 22)]"+char(10)+"ssh_usage: ssh [user@-brutus] [ip] [opt:pt] --  remote brute force attack"+char(10)+"e.g. ssh root@1234 1.1.1.1 "+char(10)+"e.g. ssh root@-brutus 1.2.3.4 21 ftp"+char(10)+"Sends shells to BUFFER or you may open immediately."
	end function
	if arg1 == 0 or arg2 == 0 or arg1 == "-h" or arg1 == "help" then return ssh_help
	if not localmachine.is_network_active then return "nsl: no network connection."
	rem_ip = arg2.trim
	rem_pt = 22
	rem_usr = ""
	rem_pass = ""
	if arg1.indexOf("@") >= 0 then
		split = arg1.split("@")
		rem_usr = split[0].trim
		rem_pass = split[1].trim
	else
		return "ssh: expects user@pass [ip]"
	end if
	if arg2 == "-t" then
		rem_ip = globals.targetIP
		if globals.targetPort then rem_pt = globals.targetPort else rem_pt = 22
	end if
	if arg3 and arg3 != "" and arg3 != " " then rem_pt = arg3.to_int
	if typeof(rem_pt) != "number" or not rem_pt then return "Invalid port."
	if not arg4 or (arg4 != "ftp" and arg4 != "ssh") then arg4  = "ssh"
	if rem_ip == "" or rem_pt == "" or rem_usr == "" or rem_pass == "" then return "Error: invalid input."
	if not rem_ip or not rem_pt or not rem_usr or not rem_pass or not arg4 then return "Error: invalid input."
	print("Connecting: "+rem_ip+" "+rem_pt+" "+rem_usr+" "+rem_pass+" "+arg4)
	rem_shell = null
	if rem_pass == "-brutus" then 
		flag = "-s"
		if arg4 == "ftp" then flag = "-S"
		return command.brutus(flag, rem_ip, rem_pt, shell)
	end if
	rem_shell = shell.connect_service( rem_ip, rem_pt, rem_usr, rem_pass, arg4 )
	if typeof(rem_shell) == "shell" or typeof(rem_shell) == "ftpshell" then
		globals.BUFFER.push(rem_shell)
		print("Shell sent to BUFFER. Access via memory_alpha.")
	end if
	if rem_shell then return rem_shell else return "ssh: failed"
end function
command.sniff = function(arg1=0, arg2=0, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "Usage: sniff -- listen to network traffic. Prints a string if connections detected."+char(10)+"-- runs in daemon mode. exits on first sniffed connection (or ctrl+c)."
	if not globals.metaxploit then return "sniff: metaxploit not found"
	localmachine.touch(currentPath, "sniffed")
	opath = currentPath
	if opath == "/" then opath = null
	snout = localmachine.File(currentPath+"/sniffed")
	if not snout then print(colorRed+"Write Error: cannot create"+CT+colorOrange+currentPath+"/sniffed"+CT)
	print(colorRed+"-------sniffing--------"+CT)
	sniffed = globals.metaxploit.sniffer(1)
	if snout.has_permission("w") and snout.has_permission("r") then
		snout.set_content(snout.get_content+char(10)+sniffed)
		print("sniff: output saved to "+snout.path)
	else 
		return "sniff: unable to write "
	end if
	if localmachine.File(program_path+"/encode.src") then print "sniff: encode.src saved to "+program_path+"/encode.src (hopefully...)"
	return command.clipb(sniffed)
end function
command.rshell = function(arg1, arg2, arg3=0, arg4=0)
	if (arg1 == "help" or arg1 == "-h") and arg2=="extra" then return "An <b>rshell</b> will require the following:"+char(10)+"* a server running <b>rshell-server</b>, available from most hack shops."+char(10)+"* rshell-interface software running on the above server (see: <b>rsi -h</b>)"+char(10)+"* running this command (<b>rshell</b>) as follows:"+char(10)+"<b> rshell [ip.of.your.server] [process_name] </b>-- where proces_name is the desired name for the rshell. "+char(10)+"Once connected, access the rshell from the rshell-interface (rsi command)"+char(10)+"n.b. it is recommended to add rshells to the BUFFER and interact with them there, but it is not required, to do so press [4] after selecting a shell from rsi then acces<b> malp</b> and press [5]."
	home = get_custom_object["HOME"]
	if not arg1 or arg1 == "help" or arg1 == "-h" then return "REVERSE SHELL || rshell || reverse shell || back door || backdoor"+char(10)+
	colorWhite+"Usage: rshell [rshell_server_ip] [opt:stealthy_process_name] [opt:port] "+char(10)+
	colorCyan+"</b>Required: [rshell_server_ip] -- the ip of your rshell server"+char(10)+
	"-- use <b>@home</b> to indicate the ip in 5hell.src >> get_custom_object.HOME.ip "+char(10)+
	"-- @home server is currently: ["+colorGold+home.ip+CT+"]"+char(10)+char(10)+
	colorCyan+"</b>Opt: [stealthy_process_name] -- name of the rshell; appears in ps"+char(10)+
	"-- process_name cannot be: dsession, Xorg or kernel_task"+char(10)+
	"-- default name: ps"+char(10)+char(10)+
	colorCyan+"</b>Opt: [port] -- the port on which your rshell server listens"+char(10)+
	"-- default is set in 5hell.src >> gco.home.rshellport"+char(10)+
	"-- default is currently: ["+colorGold+home.rshellport+CT+"]"+char(10)+char(10)+
	"E.G: <b>rshell 123.4.5.06 ps 1337</b> -- while <u>on</u> the victim computer"+char(10)+
	"-- and ip is your rshell server with port 1337 forwarded"+char(10)+
	"E.G: <b>rshell @home not_a_virus</b> -- use default ip and port "+char(10)+
	"E.G: <b>rshell @home</b> -- use default ip, port, name"+char(10)+char(10)+
	"See also: rsi -h"+char(10)+
	"Extra:<b> rshell [-h|help] extra -- display extra help page for general rshell information."
	if not arg2 then arg2 = "ps"
	if not arg3 or typeof(arg3) != "string" then arg3 = home.rshellport else arg3 = arg3.to_int
	if typeof(arg3) != "number" then
		print("rshell: invalid port, defaulting to "+home.rshellport)
		arg3 = home.rshellport
	end if
	if globals.metaxploit then return metaxploit.rshell_client(arg1,arg3,arg2) else return "rshell: metaxploit.so not found"
end function
command.scrub = function(arg1, arg2=0, arg3=0, arg4=0)
	if arg1 == "-h" or arg1 == "help" then return "logs || log scrubbing || proxy management || scp"+char(10)+
	"Usage: scrub [opt:-s] -- wipe logs of all proxies using kraken "+char(10)+
	"-- the [-s] option scrubs the logs with a file named 'silentclean' stored on the server"+char(10)+
	"-- this requires a file named silentclean to be somewhere on the proxy"+char(10)+
	"-- it may be an empty file"+char(10)+
	"note: uses the command<b> kraken scrub"
	return command.kraken("scrub", arg1, arg2)
end function
command.prox = function(arg1, arg2=0, arg3=0, arg4=0)
	if arg1 == "-h" or arg1 == "help" then return "KRAKEN shortcut || proxy tunneling"+char(10)+"
	Usage: prox -- use kraken to route through proxy net and open terminal at end"+char(10)+
	"-- equivalent to<b> kraken connect"+char(10)+
	"-- if Map.conf is encrypted you may pass a decryption key as an argument"+char(10)+
	"---- otherwise you will be prompted for the key"
	return command.kraken("connect", arg1, arg2)
	return 0
end function
if DEBUG then print("<size=75%>loading ...kraken.5pk...(10.875b)</size>")
// gonna have to completely reqrite kraken, otherwise it's going to become impossible to maintain
command.kraken = function(arg1, arg2=0, arg3=0, arg4=0) // release the kraken!
	kraken_help = function()
		return "proxy management || release the kraken || upload || download || rental server"+char(10)+
		"Usage: kraken [opt: upload_path] -- propagate file or folder to all proxies"+char(10)+
		"-- uses ~/Config/Map.conf"+char(10)+
		"-- does <b>not</b> scrub the log after uploading"+char(10)+char(10)+
		"Usage: kraken prox -- tunnel through each proxy and start_terminal on the last"+char(10)+
		"-- each proxy uses ssh to connect to the next, in order"+char(10)+
		"-- start_terminal will be used on the endpoint proxy"+char(10)+
		"-- scrubs the logs before starting the terminal"+char(10)+
		"--note: this mode has been aliased to the "+colorCyan+"prox"+CT+" command (<b>prox -h</b>)"+char(10)+
		"Usage: kraken prox [opt:"+colorLightBlue+"-g"+CT+"] -- tunnel through each proxy <b>w/o</b> starting the terminal"+char(10)+
		"-- opens the final shell in the chain in "+colorLightBlue+"glasspool"+CT+" instead"+char(10)+
		"-- all shells in the chain remain in the "+colorOrange+"BUFFER"+char(10)+char(10)+
		"Usage: kraken scrub -- tunnel through proxy chain and corrupt the log on each"+char(10)+
		"--note: this mode has been aliased to the "+colorCyan+"scrub"+CT+" command (<b>scrub -h</b>)"+char(10)+
		"-- <b>kraken scrub / scrub</b> will:"+char(10)+
		"---- corrupt the log on each proxy in the chain"+char(10)+
		"---- remove /etc/passwd from each proxy in the chain"+char(10)+
		"---- lock file permissions on each proxy in the chain"+char(10)+char(10)+
		"Usage: kraken [buffer] -- shells will be sent to BUFFER with no further action"+char(10)+char(10)+
		//"New: kraken [command] [-s] -- run silentclean each proxy after the command"+char(10)+
		//"--eg: kraken /root/rkit -s"+char(10)+char(10)+
		"Usage: kraken add [opt:ip] [opt:pass] -- add items to Map.conf"+char(10)+char(10)+
		"Usage: kraken del [index] -- remove the entry at index"+char(10)+
		"Usage: kraken show [opt:-p] -- display proxy list"+char(10)+
		"-- passing<b> -p</b> will display the list with passwords"+char(10)+char(10)+
		"Usage: kraken [-l|logs]  -- download system.log from proxies and then scrub"+char(10)+
		"-- system.logs are saved as: <b>system-#.log"+char(10)+
		"-- # is in the reverse order of the proxy chain"+char(10)+
		"---- the <b>endpoint</b> log will have the lowerst number"+char(10)+
		"-- logs are<b> not</b> overwritten on each run; mind your drive space"+char(10)+char(10)+
		colorGold+"Usage: kraken -- launch the kraken proxy management menu"+char(10)+
		char(10)+
		"NOTE: kraken will only scrub logs when using:"+char(10)+
		"-- scrub, prox, [-l|logs]"+char(10)+char(10)+
		colorGold+"Encryption"+CT+colorWhite+" and "+CT+colorGold+"Kraken"+char(10)+
		"-- kraken will [offer to] decrypt Map.conf if it is encrypted"+char(10)+
		"---- files decrypted this way will be re-encrypted"
	end function
	if arg1 == "-h" or arg1 == "help" then return kraken_help
	map_path = home_dir + "/Config/Map.conf"
	map_file = globals.get_file(map_path)
	kraken_done = function(msg="kraken: task complete")
		if outer.isenc then print command.file("-e",outer.map_file.path,outer.enckey)
		return msg
	end function
	if not map_file then
		print( "kraken: map.conf not found. " )
		mak_map = user_input("Create it? [Y/n] ||: ",0,1)
		if mak_map.lower == "n" then return "aborting..."
		print localmachine.touch(home_dir+"/Config", "Map.conf")
		map_file = globals.get_file(map_path)
		if map_file then print(home_dir+"/Config/Map.conf created.") else return "kraken: write error!"
	end if
	isenc = false
	enckey = 0
	if map_file.is_binary then 
		if globals.crypto.is_encrypted(map_file.path) == 1 then
			print colorGold+"kraken: Map.conf is encrypted"
			if globals.GLASSPOOL then print colorWarning+"kraken: warning "+colorLightBlue+"GLASSPOOL"+CT+" is active"+char(10)+"<b><size=75%>-- the active cryptoLib must match the active shell!"+char(10)+"<b><size=75%>---- other wise the wrong file will be targetted"
			isenc = true
			enckey = arg2
			if arg2 == "-p" or arg1 == "del" then enckey = arg3 
			if arg1 == "add" then enckey = arg4
			if not enckey then enckey = command.cob("get","HOME.map_key") 
			if globals.DEBUG then print "debug: map path: "+map_file.path+char(10)+"-- arg1: "+arg1+", enckey: "+enckey
			print command.file("-d",map_file.path,enckey)
		else
			return "kraken: "+colorError+"</b>cannot open binary file: "+map_file.path
		end if
		if map_file.is_binary then return "kraken: "+colorWarning+"decryption failed; aborting..."
	end if
	map_contents = map_file.get_content
	//map read
	print(colorCyan+"Initializing Kraken v 0.9.5 by Plu70..."+CT)
	time_s = time
	MAP = {}
	MAP.accounts = {"accounts":[{"user":"user","ip":"ip","password":"password"}]}

	MAP.init = function(map_string)
		if map_string == "" then //return "Kraken: empty Map.conf"
			map_string = "{""accounts"":[],""historyConnections"":[]}"
		end if
	  MAP.accounts = slice(map_string, 12).split("}")
	end function

	proxy = {}
	proxy.accounts = {}
	proxy.set = function(i,k,v,ik,iv,pk,pv)
	  proxy.accounts[i] = {k:v,ik:iv,pk:pv}
	end function
	proxy.show = function(show_pass)
		ps = null
		i = 0
		for pr in proxy.accounts
			if show_pass == "-p" then ps = "root@"+pr.value.password+" "
			print("["+colorWhite+i+CT+"]<b> "+ps+pr.value.ip+" </b>")
			i = i + 1
		end for
	  return 0
	end function
	proxy.add = function(ip,pass)
	  proxy.accounts[proxy.accounts.len] = {"user":"root","ip":ip,"password":pass}
	  return "added: root@"+pass+" "+ip
	end function
	proxy.del = function(int)
	  if proxy.accounts.hasIndex(int.to_int) then
	    tar = proxy["accounts"][int.to_int]["ip"]
	    proxy.accounts.remove(int.to_int)
	    return "deleted: "+tar
	  else
	    return "invalid index"
	  end if
	end function

	proxy.save = function()
		out = {"accounts":[],"historyConnections":[]}
		for i in proxy.accounts
			out.accounts.push(i.value)
		end for
		string = "{""accounts"":["+out.accounts.join(",")+"],""historyConnections"":[]}"
		final = ""
		for char in string
			if char != " " then final = final + char
		end for

		// if Map.conf is meant to be binary, convert final to code
		// -- write Map.conf.src with code
		// -- make Map.conf and copy it over Map.conf.src then rename to Map.conf 

		map_source = "if get_custom_object.hasIndex(""kraken_password"") and get_custom_object.kraken_password == ""password"" then get_custom_object.kraken_map = """+final+""" else exit ""kraken: access denied;get_custom_object.remove(""kraken_password"");exit ""kraken: write complete"""
		make_map = false
		if make_map == true then 
			map_file = command.poke(map_path)
			map_folder = map_path.replace("/Map.conf","")
			if typeof(map_file) != "file" then return "kraken: cannot create Map.conf"+char(10)+"-- "+map_file
			map_file.move(map_folder,"Map.conf.src")
			map_file.set_content(map_source)
			globals.shell.build(map_file.path,map_folder) 
			map_conf = globals.get_file(map_path)
			if not map_conf then return "kraken: failed to build Map.conf"
			map_conf.move(map_path.replace("/Map.conf",""),"Map.conf.src") 
			map_conf.move(map_path.replace("/Map.conf",""),"Map.conf") 
			return "kraken: successfully built Map.conf"
		end if

		new_map = globals.get_file(map_path)
		if not new_map then return "kraken: error; Map.conf vanished!"
		if new_map.has_permission("w") then new_map.set_content(final) else return "kraken: write error, Map.conf not saved!"
		outer.map_file = new_map
		//if outer.isenc then print command.file("-e",new_map.path,outer.enckey)
		return kraken_done(colorGold+"</b>kraken: saved map to "+new_map.path)
	end function

	MAP.parse = function()
	  accts = []
	  m_size = MAP["accounts"].len
	  for m in MAP["accounts"]
	    //print(m_size)
	    m_size = m_size - 1
	    m = m.replace("{","")
	    m = slice(m,1)
	    //print(m)
	    if m and m_size > 1 then accts.push(m.split(","))
	  end for
	  i = 0
	  for a in accts
	    //print(format_columns(a[0] + " " + a[1] + " " + a[2] ))
	    line = a[0].split(":")
	    key = line[0]
	    key = slice(key,1,-1)
	    val = line[1]
	    val = slice(val,1,-1)
	    nums = a[1].split(":")
	    ik = nums[0]
	    ik = slice(ik,1,-1)
	    iv = nums[1]
	    iv = slice(iv,1,-1)
	    pass = a[2].split(":")
	    pk = pass[0]
	    pk = slice(pk,1,-1)
	    pv = pass[1]
	    pv = slice(pv,1,-1)
	    proxy.set(i,key,val,ik,iv,pk,pv)
	    i = i + 1
	  end for
	end function

	scrub = false
	secure = false
	connect = false
	glass = false
	get_logs = false
	map_file = localmachine.File(home_dir + "/Config/Map.conf")
	//MAP.init(map_file.get_content)
	MAP.init(map_contents)
	MAP.parse
	time_e = (time - time_s)
	//if isenc then print command.file("-e",map_file.path,enckey)
	print("...init completed in ["+colorOrange+time_e+CT+"] seconds.")
	print(colorCyan+"////////////////////////////////////////////////////////"+CT)
	waitFor = null
	if arg1 then waitFor = arg1
	print("Proxy net consists of "+proxy["accounts"].len + " nodes: ")
	print(colorOrange+"</b>!Kraken will no longer scrub your proxy logs by default!<b>"+CT)
	print(colorOrange+"</b>Run:<b> scrub</b> or<b> kraken scrub </b>manually to corrupt logs."+CT)
	print(colorOrange+"</b>Logs <u>will</u> be scrubbed for: <b>kraken connect</b> and the <b>prox</b> command.")
	last_shell = shell
	if not waitFor then waitFor = user_input("["+colorCyan+"/path/to_file_or_folder"+CT+"] = upload to all proxies and BUFFER shells"+char(10)+"["+colorWhite+"prox"+CT+"] route through proxies and open shell at last proxy "+char(10)+"["+colorWhite+"-l"+CT+"] download (then scrub) proxy logs and BUFFER shells"+char(10)+"["+colorWhite+"scrub"+CT+"] scrub logs on all proxies and BUFFER shells"+char(10)+"["+colorWhite+"show"+CT+"] show ips of proxies in map"+char(10)+"["+colorWhite+"add"+CT+"] add proxy to map "+char(10)+"["+colorWhite+"del"+CT+"] remove proxy from map "+char(10)+"["+colorWhite+"buffer"+CT+"] = add all proxies to BUFFER without scrubbing"+char(10)+"[help] show help"+" [q]=quit "+char(10)+"kraken:> ",0,0)
	if globals.DEBUG then "debug: user input: "+arg1+" "+arg2+" "+arg3+" "+arg4+"-- waitFor: "+waitFor
	if waitFor == "q" or waitFor == "Q" or waitFor == "" then return kraken_done("Aborting...")
	if waitFor == "help" or waitFor == "-h" then return kraken_help
	if typeof(waitFor) == "file" then waitFor = waitFor.path
	if typeof(waitFor) != "string" then return kraken_done("kraken: invalid input: expects file_object or string")
	if waitFor == "show" then
		//if waitFor.split(" ").len > 1 then 
		proxy.show(arg2)
		return kraken_done//proxy.show(arg2)
	end if
	wf = waitFor.split(" ")[0]
	if waitFor == "add" then
		nip = arg2
		npa = arg3
		if not arg2 then nip = user_input("add_ip:> ")
		if nip == "" then return kraken_done("krake: aborting...")
		if not arg3 then npa = user_input("add_pass:> ",1,0)
		if npa == "" then return kraken_done("kraken: aborting...")
		if not is_valid_ip(nip) then return kraken_done("kraken: invalid ip.")
		if npa == "" or npa == " " then return kraken_done("kraken: invalid password.")
		print("Adding: "+nip+char(10)+proxy.add(nip, npa))
		proxy.show
		return proxy.save
	end if
	if waitFor == "del" then
		proxy.show
		del_me = arg2
		if not del_me then del_me = user_input("del# (q=quit):> ")
		if del_me == "" or del_me == " " or del_me.lower == "q" then return kraken_done("aborting...")
		print(proxy.del(del_me))
		proxy.show
		return proxy.save
	end if
	if not localmachine.is_network_active then return colorError+"</b>kraken: <b>no network connection!"
	if wf == "-l" or wf == "logs" then
		get_logs = true
		if localmachine.File("/root/logs") then
			print("kraken: found /root/logs/ ")
		else
			mklog = user_input("kraken: /root/logs not found"+char(10)+"-- create it? [<b>Y</b>/n] ||: ",0,1)
			if mklog == "n" then return kraken_done( "kraken: aborting...")
			localmachine.create_folder("/root", "logs")
			if localmachine.File("/root/logs") then print("kraken: created /root/logs") else return kraken_done( "kraken: write error: unable to create /root/logs")
		end if
		print("kraken: saving proxy logs to /root/logs")
		print
		print "NOTE: logs are numbered in reverse order;"+char(10)+
		"-- the first in Map.conf will have <b>highest</b> number"+char(10)+
		"-- the endpoint proxy will have the lowest number"
		print("e.g. 5 total proxies: the first in map.conf will be saved as system-5.log and the last will be system-1.log")
		print("<size=85%><u>logs will not be overwritten when re-running this command; mind your drive space.</u></size>")
	end if
	buffer = false
	if waitFor == "buffer" then buffer = true
	if waitFor == "-l" or waitFor == "scrub" or waitFor == "connect" or waitFor == "prox" then
		scrub = true
		if waitFor == "connect" or waitFor == "prox" then
			connect = true
			if not proxy["accounts"].len then return kraken_done( "kraken: no proxy found.")
			if arg2 == "-g" then
				connect = false 
				glass = true 
			end if
		end if
	else
		scrub = false
	end if
	if waitFor == "secure" then secure = true
	fileOrFolder = "scrub"
	if not scrub and not buffer then fileOrFolder = localmachine.File(waitFor)
	if not fileOrFolder then return kraken_done( "kraken: file not found.")
	upload_path = "scrub"
	if not scrub and not buffer then upload_path = fileOrFolder.path
	destination_path = "scrub"
	if not scrub and not buffer then destination_path = fileOrFolder.parent.path
	if not scrub and not buffer then print("Uploading "+upload_path+" to "+destination_path+"...")
	remote = null
	for prx in proxy["accounts"]
		print("<b>Connecting: </b>" + prx.value.user + "@" + "***************" + " " + prx.value.ip)
		remote = last_shell.connect_service(prx.value.ip, 22, prx.value.user, prx.value.password)
		if typeof(remote)  != "shell" then return kraken_done( "kraken: connection failed.")
		if not scrub and not buffer then shell.scp(upload_path, destination_path, remote)
		BUFFER.push(remote)
		last_shell = remote
	end for
	if not remote then return kraken_done( "kraken: connection error")
	o = 0
	for el in range(1,proxy["accounts"].len)
		o = o - 1
		if get_logs then
			print(colorCyan+"Fetching log: "+CT+char(10)+BUFFER[o].scp("/var/system.log","/root/logs",globals.shell))
			got_log = localmachine.File("/root/logs/system.log")
			if got_log then
				wait(1)
				oi = str(o)
				while got_log.rename("system"+oi+".log") == "There is already a file with that name, please choose another one."
					oi = oi+str(o)
				end while
				print("Kraken: pulled log to<b> /root/logs/system"+oi+".log </b>")
			else
				if get_logs then print(colorOrange+"</b>Kraken: log missed!<b>"+CT)
			end if
		end if
		if secure then print command.glasspool("-d","kore -sc || return",BUFFER[0])
		if scrub then
			print("Scrubbing log...")
			root = BUFFER[o].host_computer.File("/")
			root.chmod("o-rwx", 1)
			root.chmod("g-rwx", 1)
			root.chmod("u-rwx", 1)
			pwf = remote.host_computer.File("/etc/passwd")
			if pwf then pwf.delete
			if arg2 == "-s" or arg3 == "-s" then
				catch = BUFFER[o].launch("/root/rkit/silentclean")
				//_cascade // exit if cascade
				if catch then
					print(catch)
				else
					print("<b>Scrubbed.</b>")
				end if
			else
				catch = rclean(BUFFER[o])
				if catch then
					print(catch)
				else
					print("<b>Scrubbed.</b>")
				end if
			end if
		end if
	end for
	//if isenc then print command.file("-e",enckey)
	print colorCyan+"kraken: all shells sent to "+colorOrange+"BUFFER"
	print(colorCyan+"-- task complete in [</b>"+colorOrange+(time - time_s)+colorCyan+"<b>] seconds."+CT)
	print(colorCyan+"////////////////////////////////////////////////////////"+CT)
	if connect or glass then 
		if DEBUG then print "debug: connect: "+connect+char(10)+"debug: glass: "+glass
		hold = globals.shell 
		globals.shell = remote
		if connect == true then print command.psudo("-l",remote) else print command.glasspool(remote) // we want glass to mimic connect's behavior if the user uses start_terminal after using glass
		globals.shell = hold 
	end if
	return kraken_done
end function

//////data3a5e////////////////
command.liber = function(arg1, arg2, arg3=0, arg4=0) // requires metaxploit.so
	if not metaxploit then return "Error: metaxploit.so not found"
	//if GLASSPOOL then return "liber: local use only."
	if not arg1 or arg1 == "help" or arg1 == "-h" then return "library version info || LIBER || metaLib version || liber te"+char(10)+
	"<b>Usage: liber [/path/lib_file|MetaLib] -- returns library name and version"+char(10)+
	"--e.g: liber /usr/cache/libhttp.so -- get name and version "+char(10)+
	"--e.g: bios -m | liber"+char(10)+
	"<b><color=white>Usage: liber [-l] [libname] -- returns version info for libname located in /lib/"+char(10)+
	"--e.g: liber [-l] libssh.so -- get info for /lib/libssh.so"+char(10)+
	"<b>Usage: liber [-l] -- print version info for all libraries in /lib"+char(10)+
	"<b>Usage: liber [/folder] -- print version info for all libraries in folder"+char(10)+
	"--e.g: liber /usr/libcache"+char(10)+
	"<b>Usage: liber [-i] [/path/lib_file] -- returns an imported lib object from path"+char(10)+
	"-- equivalent to <b>bios -i [/path]</b>"+char(10)+
	"-- [-i] is for API objects such as metaxploit, crypto, blockchain, aptclient, etc"+char(10)+
	"---- user <b>meta link [-l|-r]</b> to link metalib or netsession objects"+char(10)+
	"--e.g: liber [-i] [/lib/blockchain.so] | malp -- imports lib and pipes to malp (BUFFER)"+char(10)+
	"NOTE : liber is limited to the scope of the <b>metaxploit</b> object currently in use."+char(10)+
	"NOTE : liber will color code results if database.csv exists"+char(10)+
	"---- "+colorOrange+"orange means the library is unkown"+char(10)+
	"---- "+colorCyan+"cyan means the library is known"+char(10)+
	colorWhite+"Usage: liber [-r|-lr] [path|libname] -- run as above but return raw output"
	color_on = true
	if arg1 == "-r" then 
		color_on = false 
		arg1 = arg2
		arg2 = arg3 
		arg3 = arg4
	end if
	l_path = arg1
	if typeof(l_path) == "MetaLib" then return arg1.lib_name+" v "+arg1.version
	if typeof(l_path) != "string" and typeof(l_path) != "file" then return "liber: invalid type: expects file, string, or metalib"
	if arg1 == "-i" then 
		if not arg2 then arg2 = user_input("path to lib:> ").lower.trim
		if arg2 == "" then return "liber: -i expects a path"
		print colorWhite+"<u>liber: running command.bios -i "+arg2+CT+"</u>"
		return command.bios(arg1,arg2)
	end if
	if arg1 == "-l" or arg1 == "-lr" then 
		if arg1 == "-lr" then color_on = false 
		if arg1 == "-lr" then arg1 = "-l"
		if arg2 and typeof(arg2) == "string" then l_path = "/lib/"+arg2 else l_path = "/lib"
		if arg2 and typeof(arg2) != "string" then print "liber: expects path as a string."
	end if
	if DEBUG then print("liber: l_path = "+l_path+" and is a "+typeof(l_path))
	if typeof(l_path) == "string" then lib_file = globals.get_file(l_path)
	if typeof(l_path) == "file" then lib_file = l_path
	if not lib_file then return("File not found.")
	if DEBUG then print("got: "+typeof(lib_file))
	print colorGreen+"<u>==========liber=========="
	buf = []
	if lib_file.is_folder then
		for f in lib_file.get_files
			lib = metaxploit.load(f.path)
			if typeof(lib) != "MetaLib" then
				//buf.push("liber: "+lib_file.path+ ": unknown format")
				if DEBUG then print "debug: skiping: "+typeof(lib)
			else
				buf.push( lib.lib_name + " v " + lib.version )
			end if
		end for
	else
		lib = metaxploit.load(lib_file.path)
		if typeof(lib) != "MetaLib" then
			//buf.push("liber: "+lib_file.path+ ": unknown format")
			if DEBUG then print "debug: skiping: "+typeof(lib)
		else
			buf.push( lib.lib_name + " v " + lib.version )
		end if
	end if
	// check libs in buf against database
	//print "<size=75%>liber: searching for database..."
	//datbas = command.tree("/","database.csv",1,"N")
	// if DEBUG then print "debug: datbas: "+datbas
	// if DEBUG then 
	// 	if typeof(datbas) == "file" then print "debug: "+datbas.path 
	// end if
	hold_silence = globals.SILENT
	if not DEBUG then globals.SILENT = 2 else globals.SILENT = 0
	datbas = command.grep("-a","^database.csv")
	if not DEBUG then globals.SILENT = hold_silence
	//if datbas and datbas.has_permission("r") then 
	//	dbase_data = datbas.get_content.split(char(10))
	if datbas.len then 
		dbase_data = []
		for dbf in datbas 
			if typeof(dbf) == "file" and dbf.has_permission("r") then dbase_data = dbase_data+dbf.get_content.split(char(10))
		end for

		db_buf = []
		for db_entry in dbase_data
			if db_entry.indexOf("Hooked:") != null then continue
			db_buf.push(db_entry)
		end for
		dbase_data = db_buf
		if DEBUG then print "debug: buf: "+char(10)+buf
		if DEBUG then print "debug: buf size: "+buf.len
		if DEBUG then print "debug: dat size: "+dbase_data.len
		b_index = 0 // buf index
		d_index = 0 // dbase_data index
		color_known = colorCyan+"</b>"
		color_unkwn = colorOrange+"</b>"
		for entry in buf 
			if DEBUG then print "debug: entry: "+entry
			if DEBUG then 
				print "-- B["+b_index+"] -- "
				print "-- B["+buf[b_index]+"]"
			end if
			if color_on then 
				if dbase_data.indexOf(entry) != null then buf[b_index] = color_known+entry+CT else buf[b_index] = color_unkwn+entry+CT 
			end if
			b_index = b_index + 1
			d_index = 0
		end for
	else 
		print "liber: database.csv not found or read protected;"
		print "-- skipping database check"
	end if
	if DEBUG then print "debug: buf: "+char(10)+buf
	return format_columns(buf.join(char(10)))
end function
//////////////////BEGIN DATABASER/////////////////
//// this code really puts the 'hell' in 5hell //
command.db = function(arg1, arg2, arg3=0, arg4=0)
    if not globals.metaxploit then return colorRed+"</b>db: error: metaxploit is not loaded"
    remote = false
    pre_load = false
    inject = null
    lib_path = ""
	db_usage = "<b><u>DB || dbaser || Databaser</u>"+char(10)+
	colorLightBlue+"</b>Automated remote port and local lib scanning and databasing."+char(10)+
	colorLightBlue+"</b>Results are sent to the BUFFER."+char(10)+
	colorLightBlue+"Database is saved to <u>~/rkit/database.csv"+char(10)+
	colorOrange+"Logs: </b>logs will be left by db when:"+char(10)+
	"-- a net_session is obtained on a server (not a router):"+char(10)+
	"-- "+colorWhite+"</b>connection established port ##"+char(10)+
	"-- a shell object is obtained on any machine:"+char(10)+
	"-- "+colorWhite+"shell obtained on port ##"+char(10)+
	colorOrange+"Note:</b> logs may be left in other ways. See: "+colorGreen+"help logs"+CT+" for more."+char(10)+char(10)+
	"Note: targetIP and targetPort are set with <b>probe</b> and/or <b>target</b>"+char(10)+char(10)+
	"Note: db will catagorize "+colorOrange+"bounce exploits"+CT+" when it finds them"+char(10)+
	"-- this process, however, is imperfect due to a game update"+char(10)+
	"---- this will be fixed, eventually"+char(10)+
	"-- a "+colorOrange+"bounce exploit"+CT+" is an exploit that:"+char(10)+
	"---- when run on a router and provided with a LAN ip as an inject"+char(10)+
	"---- returns a computer object for the machine at the specified LAN ip"+char(10)+
	"-- db will make an attempt at guessing a LAN ip to use if one is not provided"+char(10)+
	"---- rerun the attack using <b>zap or roil</b> with the desired IP once identified"+char(10)+char(10)+
	colorWhite+"</b>Usage: db ["+colorRed+"-r"+CT+"] [opt:ip] [opt:port] [opt:inject]"+char(10)+
	"-- scans given port and databases results"+char(10)+
	"-- uses targetIP and targetPort if not supplied"+char(10)+
	"-- supplying [-i] for inject results in a prompt"+char(10)+
	"---- enter a lan_ip or password for the inject value at the prompt"+char(10)+
	"Usage: db -r [ip] <color=yellow>*</color> -- db all ports at given ip"+char(10)+
	"Usage: db -r <color=yellow>*</color> -- db all ports of targetIP"+char(10)+char(10)+
	"Usage: db -r -i [opt:ip] -- set an inject value to use to detect bounces"+char(10)+
	"-- prompt for ip if not supplied"+char(10)+
	colorWhite+"</b>Usage: db ["+colorCyan+"-l"+CT+"] [opt:lib_name] [opt:inject]"+char(10)+
	"-- scan a local lib and database resutls"+char(10)+
	"-- brings up menu if lib_name not supplied"+char(10)+
	"-- supplying [-i] for inject results in a prompt"+char(10)+
	"---- enter a lan_ip or password for the inject value at the prompt"+char(10)+
	"Usage: db -l <color=yellow>*</color> -- db all local libs"+char(10)+char(10)+
	"Usage: db -l -i -- choose a lib from the menu and prompt for an inject"+char(10)+
	colorWhite+"</b>Usage: db ["+colorMagenta+"-m|-M"+CT+"] [opt:metaLib|metaxploitLib] [opt:metaxploitLib|metaLib] [opt:inject]"+char(10)+
	"-- scan currently linked metaLib or piped metaLib with currently linked metaxploitLib or piped metaxploitLib"+char(10)+
	"-- unlike other modes, this mode will <b>not</b> link a new metaLib"+char(10)+
	"---- unless a metalib is piped to it"+char(10)+
	"-- instead, it scans the already linked metaLib"+char(10)+
	"-- supplying [-i] for inject results in a prompt"+char(10)+
	"-- when not piping metaxploitLib or metaLib (ie: scanning in place):"+char(10)+
	"---- use <b>meta load [piped_metaLib]</b>, or <b>meta link [ip] [pt]</b>, to choose a metaLib to scan"+char(10)+
	"---- use <b>meta -i [pipe_metaxploitLib]</b> to choose the scanning metaxploitLib"+char(10)+
	"--eg: meta load init.so | meta -i @o myx0 || db -m || meta restore"+char(10)+
	"-- to specify a scanning metaxploitLib object, use:"+char(10)+
	"----:<b> db -m [metaxploitLib]"+char(10)+
	"--eg:<b> meta load init.so | db -m @o myx0 || meta restore"+char(10)+
	"---- see <b>meta help</b> for more"+char(10)+
	"NOTE: passing<b> -M</b> explicitely uses <b>@o myx0</b>"+char(10)+
	"--eg: meta load init.so | db -M"+char(10)+char(10)+
	"N.B.: using -m or -M invokes <b>meta -i [object]</b>"+char(10)+
	"-- you will need to manually <b>meta restore</b> to access the previous metaxploitLib"+char(10)+
	"Note: Use <b>meta link</b> and <b>meta scan</b> to scan without databasing"+char(10)+
	"Note: It is not possible exploit/database libs that are not in the /lib folder"+char(10)+
	"-- you may however <b>scan</b> these libs for vulnerable addresses with <b>meta scan</b>"+char(10)+
	"Note: the default 'inject' is '192.168.0.2' to avoid unintentional password changes"
	if arg1 == "-h" or arg1 == "help" then return(db_usage)
	if typeof(arg1) != "string" or ["-M","-m","-r","-l"].indexOf(arg1) == null then return "db: invalid flag: expects -m|-r|-l"
	if DEBUG then print("In command.db...")
	if GLASSPOOL then print colorWarning+"db: warning "+colorLightBlue+" GLASSPOOL </color>is active!"+char(10)+"<size=75>-- db does not translate through glasspool"+char(10)+"<size=75>-- libraries scanned are linked to the metaxploit object"+char(10)+"<size=75>---- and might not exist on the active shell"+char(10)
	inject = null
	if DEBUG then print("db: arg2: "+arg2+" arg3: "+arg3+" arg4: "+arg4)
    // params: -m -metaLib (scan linked metaLib or piped metaLib)
	if arg1.lower == "-m" then 
		pre_load = true
		print colorLightBlue+"<size=75%></b>db: preparing custom scan..."
		if arg2 != "-i" then 
			if DEBUG then print "debug: db -m: arg2: "+arg2+" arg3: "+arg3+" arg4: "+arg4
			if arg1 == "-M" then 
				mob = command.cob("get","myx0")
				if typeof(mob) == "MetaxploitLib" then print command.meta("-i",mob) else print mob
			end if
			if typeof(arg2) == "MetaxploitLib" then print command.meta("-i",arg2) 
			if typeof(arg3) == "MetaxploitLib" then print command.meta("-i",arg3) 
			if typeof(arg4) == "MetaxploitLib" then print command.meta("-i",arg4) 
			if typeof(arg2) == "MetaLib" then print command.meta(arg2)
			if typeof(arg3) == "MetaLib" then print command.meta(arg3)
			if typeof(arg4) == "MetaLib" then print command.meta(arg4)
			// add some error checking here ^
			// we check for -i after we check for all the other flags
		end if
		if not globals.metaLib then return "db: link, load, or pipe a metaLib before using -m" else print colorLightBlue+"<size=75%></b>db: custom scan ready"
	end if
	if not globals.metaxploit then return "metaxploit.so not found"
    // params: -r|-R -remote (scan remote target)
	if arg1.lower == "-r" then
		remote = true
		if arg2 == "-i" or arg3 == "-i" or arg4 == "-i" then 
			if not arg3 then inject = user_input("db: please supply an inject value"+char(10)+"--: enter a lan ip for a bounce exploit"+char(10)+"--: enter a password for pw change exploits"+char(10)+"inject:>"+colorGold+"</b> ")
			if inject == "" then print colorWarning+"</b>db: ok, using nothing as an inject"
			if arg2 == "-i" and arg3 then inject = arg3 
			if arg3 == "-i" and arg4 then inject = arg4
		end if
		if not arg2 or arg2 == "-i" then
			arg2 = globals.targetIP
			arg3 = globals.targetPort
		end if
        if not is_valid_ip(arg2) and arg2 != "*" then return "db: invalid target ip"
        if is_valid_ip(arg3) then globals.targetIP = arg3
        if is_valid_ip(arg2) then globals.targetIP = arg2
        if arg2 == "*" then 
            if is_valid_ip(arg3) then arg2 = arg3 else arg2 = globals.targetIP
            arg3 = "*"
        end if
        if not globals.targetIP then return "db: error: supply or set a target ip"
        if arg3 == "*" then 
            // get all ports on target
            if is_valid_ip(arg2) then rr = get_router(arg2) else rr = ""
            if typeof(rr) == "router" then 
                locals.ports = rr.used_ports
                if DEBUG then print "debug: rr is a router. ports are: "+ports
            else 
                if DEBUG then print "debug: guessing gateway..."
                gate_guess = arg2.split("\.")
                gate_guess[-1] = "1"
                gate_guess = gate_guess.join(".")
                rr = get_router(gate_guess)
                if typeof(rr) == "router" then 
                    locals.ports = rr.used_ports
                    if DEBUG then print "debug: rr found a router. ports are: "+ports
                else 
                    return "db: target has non-standard gateway."+char(10)+"db: try again with gateway ip"
                end if
            end if
            if DEBUG then 
                if ports.len > 0 then print "debug: port[0]: "+ports[0].port_number else print "debug: no ports found"
            end if
            for port in locals.ports
                p = str(port.port_number)
                print colorCyan+"db: -r "+arg2+ " "+ p // we dont scan the router here. once this finishes, router is scanned below
                command.db(arg1, arg2, p, inject)
            end for 
        end if 
        if arg3 == 0 or arg3 == "0" then arg3 = "router"
        if typeof(arg3) == "number" then arg3 = str(arg3)
        if arg3 != "router" and arg3 != "*" then
            globals.targetPort = arg3.to_int
        else
            globals.targetPort = "router"
        end if
	end if
	// params: -l|-L -local_libs (/lib) (scan local lib)
	if arg1 == "-l" or arg1 == "-L" then
		remote = false
		if arg2 and arg2 != "-i" then
			if arg2 == "*" then          ///////// wildcard! babY! ////////////
				lib_f = localmachine.File("/lib")
				if not lib_f then return "db: /lib folder not found!"
				libs = lib_f.get_files
				for l in libs  
					arg2 = l.name
					print colorCyan+"db: -l "+arg2
					command.db(arg1,arg2,inject)
				end for 
				return 0
			end if
			lib_path = "/lib/"+arg2
		else 
			lib_path = "/lib/"+globals.get_lib("L").split(" ")[0]
			if DEBUG then print("lib_path "+lib_path)
		end if
	end if
	// arg: -f|-F -path_to_file (add file or folder to db)
	if arg1.lower == "-f" then
		return "depricated function"
	end if
	// params: -i -inject (inject value)
    //if arg2 == "-i" or arg3 == "-i" or arg4 == "-i" then inject = user_input("enter a lan ip or password for injects:> ")
	if DEBUG then print "debug: purging xploits"
	command.purge("-x", "y")
	DATA = []
	lib_info = function()
		if typeof(globals.metaLib) != "MetaLib" then return "MetaLib: error 266"
		info = globals.metaLib.lib_name + " v " + globals.metaLib.version
		return info
	end function
	locals.load_lib = function()  // remote false
		globals.metaLib = metaxploit.load(lib_path)
		if globals.metaLib then
			if DEBUG then print(lib_info)
		else
			return "Error. File not found."
		end if
	end function
	get_lib = function() // remote true
		if globals.targetPort == "router" then
			globals.net_session = globals.metaxploit.net_use( globals.targetIP )
		else
			globals.net_session = globals.metaxploit.net_use( globals.targetIP , globals.targetPort )
		end if
		if globals.net_session then
			globals.metaLib = globals.net_session.dump_lib
		else
			print("Error. Can't establish net session.")
			return
		end if
		if DEBUG then print("debug: db: lib_info"+lib_info)
	end function
	if remote then
		if not pre_load then get_lib // pre_load == true means db the currently loaded metaLib (wip)
	else
		if not pre_load then locals.load_lib // this means we don't link or load a lib here
	end if
	if not globals.metaLib then return colorRed+"meta: unable to link/load net_session/metaLib"
	DATA.push(lib_info)
	if globals.metaLib then print(colorCyan+"scanning library: " + lib_info + char(10))

	ok = function(ip)
		if is_valid_ip(ip) then 
			ip = ip.split("\.")
			if ip[3] == "1" then return false
			return true				
		end if
		return false
	end function

	lan_inject = "192.168.0.2"
	if is_valid_ip(globals.targetIP) and not is_lan_ip(globals.targetIP) then // / / /
		remr = get_router(globals.targetIP)
		if typeof(remr) == "router" then 
			rdev = remr.devices_lan_ip.shuffle 
			if DEBUG then print "debug: rdev: "+rdev
			uip = ""
			for ip in rdev
				if ok(ip) then 
					uip = ip 
					break
				end if
			end for
			
			if not is_valid_ip(uip) then lan_inject = remr.local_ip else lan_inject = uip
		end if
	end if

	if is_lan_ip(globals.targetIP) then 
		lan_inject = globals.targetIP.split("\.") 
		if not ok(lan_inject) then 
			lan_inject[3] = "2"
			lan_inject = lan_inject.join(".")
		else 
			lan_inject = globals.targetIP
		end if
	end if

	
	pass_inject = "*"
	check_bounce = false
	if globals.metaLib.lib_name == "kernel_router.so" or ( localmachine.is_network_active and typeof(get_router(localmachine.local_ip)) ) == "router" then check_bounce = true
	
	// new result types and libs exist; more classifications needed
	if typeof(inject) == "string" then pass_inject = inject 
	if is_lan_ip(inject) then lan_inject = inject

	// if not inject or inject.trim == "" then
	// 	if globals.metaLib.lib_name == "kernel_router.so" or typeof(get_router(localmachine.local_ip)) == "router" then 
	// 		if is_lan_ip(globals.targetIP) then
	// 			inject = globals.targetIP
	// 		else
	// 			rtt = ""
	// 			if localmachine.is_network_active then rtt = get_router(targetIP) //else return "db: error: no active network connection"
	// 			if typeof(rtt) == "router" then
	// 				ports = rtt.used_ports
	// 				if ports.len then pt = ports[0] else pt = 0
	// 				if typeof(pt) == "port" then
	// 					inject = pt.get_lan_ip
	// 				else
	// 					inject = rtt.local_ip
	// 				end if
	// 			else
	// 				inject = localmachine.local_ip
	// 			end if
	// 		end if
	// 	else 
	// 		print colorCyan+"</b>db: using default inject: ""192.168.0.2"""
	// 		inject = "192.168.0.2"
	// 	end if 
	// end if
	// if inject == "" then inject = "192.168.0.2"

	// if is_valid_ip(inject) then 
	// 	lan_inject = inject 
	// else 
	// 	if is_lan_ip(globals.targetIP) then
	// 		lan_inject = globals.targetIP
	// 	else
	// 		rtt = ""
	// 		if localmachine.is_network_active then rtt = get_router(targetIP) else return "db: error: no active network connection"
	// 		if typeof(rtt) == "router" then
	// 			ports = rtt.used_ports
	// 			if ports.len then pt = ports[0] else pt = 0
	// 			if typeof(pt) == "port" then
	// 				lan_inject = pt.get_lan_ip
	// 			else
	// 				inject = rtt.local_ip
	// 			end if
	// 		else
	// 			lan_inject = localmachine.local_ip
	// 		end if
	// 	end if
	// 	if typeof(inject) == "string" then pass_inject = inject 
	// end if
	memory = metaxploit.scan(globals.metaLib)
	globals.MEMORY = memory
	if not memory then print("no exploits detected.")
    globals.meta_scan = []
	_user_color = function( string )
		cc = colorGreen
		if string == "???" then cc = colorWhite
		if string == "guest" then cc = colorWhite 
		if string == "root" then cc = colorRed
		return cc+string+CT
	end function
	_object_color = function( string )
		cc = colorWhite
		if string == "file" then cc = colorGreen
		if string == "computer" then cc = colorCyan
		if string == "shell" then cc = colorGold
		if string == "firewall_disable" or string == "password_change" then cc = colorOlive
		return cc+string+CT
	end function
	for mem in memory
		address = metaxploit.scan_address(globals.metaLib, mem).split("Unsafe check:")
        globals.meta_scan.push(address)
		for add in address
			if add == address[0] then continue
			value = add[add.indexOf("<b>")+3:add.indexOf("</b>")]
			value = value.replace("\n", "")
			result = globals.metaLib.overflow(mem, value, pass_inject) ////////////////////// FIRE //////////////////
			if not result and check_bounce == true then //result == null then
				print colorOrange+"checking for bounce (this process is not perfect)..."
				if DEBUG then print "in db: preparing to overflow: "+ mem + " " + val + " " + lan_inject
				result = globals.metaLib.overflow(mem, value, lan_inject)
				if result then
					DATA.push("Hooked: " + globals.checkUser(result) + " " + typeof(result) + ":bounce with " + mem + " " + value)
					print("Hooked: " + _user_color(globals.checkUser(result)) + " " + _object_color(typeof(result)) + colorOrange+":bounce</color></b> with " + mem + " " + value)
					globals.XPLOITS.push(mem + " " + value + " " + globals.checkUser(result) + " " + typeof(result)+":bounce")
					globals.BUFFER.push(result)
					continue
				end if
			end if
			result_type = typeof(result)
			if result == 1 or result == 0 then // firewall or password change; for now, needs more types depending on specific libs
				if check_bounce == true then // firewall
					result_type = "firewall_disable"
				else 
					result_type = "password_change"
				end if
			end if
			DATA.push("Hooked: " + globals.checkUser(result) + " " + result_type + " with " + mem + " " + value)
			print("Hooked: " + _user_color(globals.checkUser(result)) + " " + _object_color(result_type) + " with " + mem + " " + value)
			globals.XPLOITS.push(mem + " " + value + " " + globals.checkUser(result) + " " + result_type)
			if result then globals.BUFFER.push(result)
		end for
	end for

	print colorOrange+"- - - - - - - - - - - - - - - - - - - - "
	// find rkit and database.csv, confirm db.csv is in rkit
	// if no database.csv then create database.csv in rkit if present or current path if not
	/////////////////////////////////////////////////////////////
	locals.rkit = command.tree("/","rkit",1,"N")
	if not rkit then locals.rkit = globals.get_file(currentPath)

	all_dat = command.grep("-a","^database.csv")
	current_data = []
	datafile = null 
	exts = []
	if DEBUG then print "debug: all_dat: "+all_dat
	for d in all_dat
		if typeof(d) != "file" then continue
		if DEBUG then print "debug: name: "+ d.name
		exts.push(d.name.remove("database.csv").to_int)
	end for
	if exts.len < 1 then exts = [""] else exts.sort
	latest = "database.csv"+exts[-1]
	if DEBUG then print "debug: latest: "+latest
	for d in all_dat 
		if typeof(d) != "file" then continue
		if DEBUG then print "debug: name: "+ d.name
		if d.name == latest then datafile = d
	end for
	if not datafile then 
		print" db: unable to locate database.csv"
		print "-- creating database.csv in "+ rkit.path
		slash = "/"
		if rkit.path == "/" then slash = ""
		print command.poke(rkit.path+slash+"/database.csv")
		datafile = globals.get_file(rkit.path+slash+"/database.csv")
		if not datafile then return colorError+"</b>db: write error: permission denied"
	end if
	//locals.datafile = command.tree("/","database.csv",1,"N")
	// if typeof(rkit) == "file" and rkit.is_folder then 
	// 	datafile = command.tree(rkit.path,"database.csv",1,"N")
	// 	if not datafile then datafile = command.tree("/","database.csv",1,"N")
	// 	if not datafile then 
	// 		print "tree: unable to locate database.csv"
	// 		print "db: creating database.csv in "+rkit.path
	// 		localmachine.touch(rkit.path, "database.csv")
	// 		datafile = localmachine.File(rkit.path+"/database.csv")
	// 		if not datafile then return "db: write error: permission denied."
	// 	else 
	// 		if datafile.parent.name != "rkit" then 	
	// 			print "db: database.csv found outside of rkit"
	// 			print "db: attempting: "+colorWhite+"</b>mv "+datafile.path+" "+rkit.path 
	// 			print datafile.move(rkit.path,"database.csv")
	// 		end if
	// 	end if
	// else
	// 	print "db: rkit not detected."
	// 	if datafile then 
	// 		print "db: found "+datafile.path
	// 	else
	// 		print "db: creating database.csv in current path..."
	// 		localmachine.touch(currentPath, "database.csv")
	// 		datafile = localmachine.File(currentPath+"/database.csv")
	// 		if not datafile then return "db: write error: permission denied."
	// 	end if	
	// end if
//////////////////////////////////////
	//if not datafile then return("db: database.csv not found")
	if datafile.has_permission("w") then print "db: writing database to: "+datafile.path else return "db: write error: permission denied."
	current_data = ""
	if DEBUG then print command.file(datafile.path)
	if datafile.has_permission("r") then current_data = datafile.get_content.trim.split(char(10)) else return "db: read error: permission denied."
	if DEBUG then print "debug: database before splice: "+current_data.join(char(10)).len
	//prepare the output
	while current_data.indexOf(lib_info) >= 0
		buf_top = current_data[:current_data.indexOf(lib_info)]
		buf_bot = current_data[current_data.indexOf(lib_info):]
		buf_bot.pull
		tag = buf_bot.pull
		while tag and tag.indexOf("Hooked:") >= 0
			if buf_bot.len then tag = buf_bot.pull else tag = null
		end while
		if tag then buf_top.push(tag)
		current_data = buf_top[0:]
		if buf_bot.len then current_data = current_data[0:]+buf_bot[0:]
	end while
	//write output to database.csv
	//debug_loop = 0
	limit = 159990
	if DEBUG then print "debug: database size before write is: "+current_data.join(char(10)).len 
	if DEBUG then print "debug: DATA size before write is: "+DATA.join(char(10)).len
	current_data = current_data.join(char(10))
	DATA = DATA.join(char(10))
	if current_data.len + DATA.len > limit then
		print "db: "+colorOrange+" warning: database size exceeds 160kb"+char(10)+colorOrange+"db: creating new database.csv..."
		new_path = datafile.path.values 
		up = new_path.pop
		if typeof(up.to_int) == "number" then up = up.to_int+1 else up = "v"+(up+1)
		new_path = new_path+up.join("")
		command.poke(new_path)
		newdatafile = globals.get_file(new_path)
		if not newdatafile then return "db: write failed; could not create new database.csv"+up
		datafile.set_content(current_data.trim)
		datafile = newdatafile
		current_data = DATA

		//debug_loop = debug_loop + 1
		//if DEBUG then print "debug: trim loop: "+debug_loop
		if DEBUG then print "debug: trim write size is: "+current_data.len 
	end if
	catch = null 
	if datafile.len > 0 then datafile.set_content(current_data.trim+char(10)+DATA.trim)
	if DEBUG then print command.file(datafile.path)
	if DEBUG then print datafile.get_content
	if catch then return(catch)
	return 0
end function///////////////END DATABASER//////////////////
command.linkdb = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "Link Database || databaser || xploits"+char(10)+char(10)+
	colorWhite+"Uasage: linkdb [string:target_lib] [optional:path_to_database|ip|@home] [opt:-y] "+char(10)+
	"-- link an entry in the database that matches target_lib"+char(10)+
	"-- eg:<b> linkdb 1.0.1"+char(10)+
	"-- eg:<b> linkdb ssh"+char(10)+
	"-- eg:<b> linkdb "" libsh.so v 1.0.1 "" -y"+char(10)+
	"-- prompts to link any entry that matches or partially matches target_lib"+char(10)+
	"---- cycles through all matches"+char(10)+
	"-- passing [<b>-y</b>] skips the prompt and links the first match"+char(10)+char(10)+
	colorCyan+"Usage: linkdb [target_lib] [ip|@home] [opt:-y] -- uses connect_service to access remote database for linking"+char(10)+
	"-- by default, will use @HOME settings"+char(10)+
	"-- passing an ip other than @home results in a prompt for user, pass, port"+char(10)+
	"-- eg:<b> linkdb kernel @home "+char(10)+
	"---- connects to machine at target ip and prompts to link any entry that matches 'kernel' "+char(10)+char(10)+
	colorCyan+"Usage: linkdb [target_lib] [/path] [opt:-y] -- link using the database at path"+char(10)+
	"--eg:<b> linkdb "" libssh.so v 1.2.3 "" /root/otherdata/database.csv -y"+char(10)+char(10)+
	"NOTE: The database may now exist as multiple database.csv[N] files in multiple locations"+char(10)+
	"--ie: database.csv, database.csv1, database.csv2,..."+char(10)+
	"-- both <b>db</b> and <b>linkdb</b> will now utilize all of these files found on a system"
	if not arg1 then return "linkdb: invalid input" else print colorCyan+"</b><size=75%>linkdb: searching for database..."
	link = function(buf,a,y)
		print("<size=75%>linkdb: purging XPLOITS...")
		print command.purge("-x","y")
		//buf = f.get_content.split(char(10))
		found_it = false
		done = 0 //"Database: "+a+" not found. Scan required."
		for line in buf
			if line.indexOf(a) >= 0 and not found_it then
				wait_for = "y"
				if not y then wait_for = user_input("<size=75%>Database: found "+line+char(10)+"<size=75%>Link this database? [Y/n]"+char(10)+"||: ",0,1)
				if wait_for != "n" and wait_for != "N" then
					print(colorLightBlue+"<size=75%>linkdb: preparing to link: "+colorOrange+"</b>"+line)
					globals.XPLOITS = []
					globals.MEMORY = null
					found_it = line
					print colorOrange+"<size=75%>linkdb: database link for "+colorWhite+found_it+"</color> successful"
					done = 1
					continue
				else
					continue
				end if
			end if
			line = line.split(" ")
			if found_it and line.indexOf("Hooked:") == 0 then
				globals.XPLOITS.push(line[line.indexOf("with")+1]+ " " +line[line.indexOf("with")+2]+ " " +line[line.indexOf("Hooked:")+1]+ " " +line[line.indexOf("Hooked:")+2])
			else
				if found_it then
					found_it = false
					return done
				end if
			end if
		end for
		return done
	end function
	
	if arg1 == "no_network" then return 0 //// ???????wtf
	boo = 0
	files = []
	if arg2 and arg2.lower == "-y" then 
		boo = 1
		arg2 = 0
	end if	
	if arg4 and arg4.lower == "-y" then boo = 1
	if arg3 and arg3.lower == "-y" then boo = 1
	if arg2 then 
		// if the passed ip is the home ip , use @home user and pass and port
		// if not, use arg2 for ip and prompt for user and pass and assume port 22 unless arg3 != 0 
		if is_valid_ip(arg2) or arg2 == "@home" then 
			ip = HOME.ip
			if arg2 == "@home" then arg2 = HOME.ip
			port = HOME.loginport 
			user = HOME.user 
			pass = HOME.pass 
			proto = HOME.logingprotocol
			if HOME.ip != arg2 then 
				user = user_input("<size=75%>linkdb: ip doesn't match @home"+char(10)+"<size=75%>-- please enter the login username"+char(10)+"(<<b>enter</b>>=abort):> <b>") 
				if user == "" then return "aborting..."
				pass = user_input("<size=75%>-- please enter the login password"+char(10)+"(<<b>enter</b>>=abort):> <b>")
				if pass == "" then return "aborting..."
				port = user_input("<size=75%>-- please enter the login port:"+char(10)+"(<<b>enter</b>="+colorWhite+"22"+CT+"):> <b>").to_int
				if typeof(port) != "number" then port = 22
				if port < 0 then port = 22
				print "<size=75%>linkdb: connecting: "+colorGrey+user+"@"+pass+" on: "+ip+" : "+port
			else 
				print "<size=75%>linkdb: using @home credentials"
			end if
			rems = globals.shell.connect_service(ip,port,user,pass,proto)
			if typeof(rems) != "shell" then return "linkdb: connection failed; check credentials "
			files = command.grep("-a","^database.csv","/",rems)
		else 
			file = globals.get_file(arg2)
			if not file then return "linkdb: "+arg2+" does not lead to a valid database; aborting...." else files = [file]
		end if
	else 
		files = command.grep("-a","^database.csv","/")
	end if

	alldata = []
	if files.len < 1 then return colorOrange+"<size=75%>linkdb: database not found"
	for f in files 
		if typeof(f) == "file" and f.has_permission("r") then alldata = alldata + f.get_content.split(char(10))
	end for
	// if file and file.has_permission("r") then 
		catch = link(alldata,arg1,boo) // catch is 0 on failure
		if catch then
			print(catch) 
			return 0 // return 0 on success
		else 
			return "linkdb: database entry not found"+char(10)+
			colorLightBlue+"-- run "+colorWhite+"db</color> or meta scan"
		end if
	// end if
	print "linkdb: database.csv not found"+char(10)+"-- run db to create it" // print this, do NOT return this or everything breaks
	return 0
end function
command.meta = function(arg1, arg2, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "Metaxploit || MetaxploitLib || exploits || XPLOITS || MetaLib || Hack"+char(10)+
	"<color=yellow>Important note: "+char(10)+
	"A "+colorOrange+"metaxploitLib "+CT+"is the object obtained from include_lib("+colorOrange+"metaxploit.so"+CT+")"+char(10)+
	"<color=yellow>A "+colorLightBlue+"metaLib"+CT+" is the object obtained from metaxploit.load() or net_session.dump_lib"+char(10)+
	"<color=yellow>A net_session object will dump a "+colorLightBlue+"metaLib"+CT+" object"+char(10)+
	"<color=yellow>A "+colorLightBlue+"metaLib"+CT+" gets scanned, a "+colorOrange+"metaxploitLib "+CT+"does the scanning"+char(10)+
	"- - - - - - - - - - - - - - - - - - - - - - - - - - - -  - - - - - - - - - - "+char(10)+
	"The <color=yellow>meta</color> command is used for fine control over "+colorLightBlue+"</b>metaLib"+CT+" and "+colorOrange+"</b>metaxploitLib"+CT+" processes"+char(10)+
	"<b>Usage: meta -- print the currently linked "+colorLightBlue+"</b>metaLib"+CT+" name and version if any"+char(10)+

	colorCyan+"Usage: meta load ["+colorLightBlue+"</b>metaLib"+CT+"] -- directly load a piped metaLib object"+char(10)+
	"-- meta link [metaLib] and meta [metaLib] will also be accepted"+char(10)+
	colorCyan+"Usage: meta load [opt:"+colorLightBlue+"</b>lib_name</color>] -- load a local "+colorLightBlue+"</b>metaLib"+char(10)+
	"-- passing a lib name will link that lib if it is in /lib"+char(10)+
	"-- not passing a lib name will bring up the menu"+char(10)+
	"----- the menu will display libs in the <b>localhost</b>'s /lib folder"+char(10)+
	"----- if using an imported "+colorOrange+"</b>metaxploitLib"+CT+" the list may be wrong"+char(10)+
	"----- selecting a lib from the list that is present on the target <b>will still work</b>, but"+char(10)+
	"--- the "+colorOrange+"</b>metaxploitLib"+CT+" object loads from the lib folder of it's native machine"+char(10)+
	"----- use the command while in glasspool to get the correct contents of /lib "+char(10)+
	"------- if you have an available shell/computer that matches the metaxploitLib"+char(10)+
	colorCyan+"Usage: meta load ["+colorLightBlue+"</b>/full/path</color>] -- load a local "+colorLightBlue+"</b>metaLib</color> from path"+char(10)+
	"-- only libs in /lib may be exploited"+char(10)+
	"-- libs loaded from outside of /lib may not not"+char(10)+
	"---- they may still have their name, version, and patch status checked"+char(10)+
	"-- full paths only"+char(10)+
	"---- the file checked is on the machine linked to the metaxploit object"+char(10)+
	colorCyan+"Usage: meta link [opt:"+colorLightBlue+"</b>ip</color>] [opt:"+colorLightBlue+"</b>port</color>] -- link a remote net_session "+char(10)+
	"-- dumps the "+colorLightBlue+"</b>metaLib"+CT+" from the net_session and loads it"+char(10)+
	"-- uses global targetIP and targetPort if ip and port are not passed"+char(10)+
	"-- passing ip and port sets global targetIP and targetPort"+char(10)+
	"-- if ip is passed without port; defaults to targetPort (or router if not set)"+char(10)+
	colorGold+"</b>Note: both link and load will attempt to run <b>linkdb</b> on the "+colorLightBlue+"</b>metaLib"+char(10)+
	colorCyan+"</b>Usage: meta scan -- scans the loaded "+colorLightBlue+"</b>metaLib</color> and loads vulns to memory"+char(10)+
	"-- uses the currently active "+colorOrange+"</b>MetaxploitLib"+CT+" object"+char(10)+
	"-- does NOT update the database"+char(10)+
	"-- equivalent to 5phinx [1]"+char(10)+
	"-- use db -r or db -l or db -m for databasing"+char(10)+
	"-- use zap or roil or 5phinx [A] or [2] after scanning to fire the exploits"+char(10)+
	colorCyan+"</b>Usage: meta [-i|import] [path|"+colorOrange+"</b>metaxploitLib</color></b>] -- import a new "+colorOrange+"metaxploitLib "+CT+" object"+char(10)+
	"-- imports from a path or from a piped object"+char(10)+
	"-- use <b>meta restore</b> to revert to the <u>previously used</u>"+colorOrange+" metaxploitLib"+CT+" object"+char(10)+
	colorCyan+"</b>Usage: meta "+colorLightBlue+"</b>return</color> -- return the currently linked"+colorLightBlue+"</b> metaLib"+CT+" object"+char(10)+
	colorCyan+"</b>Usage: meta ["+colorOrange+"</b>-x"+CT+"] -- return the current "+colorOrange+"</b>metaxploitLib"+CT+" object"+char(10)+
	"- - - - - - - - - - - - - - - - - - - - -  - - - - - - - - - - - - - - - "+char(10)+char(10)+
	"Next: once a metaLib or net_session is linked:"+char(10)+
	"-- scan the imported object with <b>meta scan</b> or <b>db -m</b>"+char(10)+
	"-- if not using db use roil to send all attacks at once"+char(10)+
	"-- use <b><color=green>db -m</b></color> to force databasing the linked "+colorLightBlue+"metaLib "+char(10)+
	"-- n.b: running db without -m will cause db to look for a new lib to link and overwrite the linked "+colorLightBlue+"metaLib"+char(10)+char(10)+
	"Note: importing a "+colorOrange+"</b>metaxploitLib"+CT+" from your server to a remote target"+char(10)+
	"-- allows using your hardware to scan the target's local libraries."+char(10)+
	"-- Likewise, exporting a remote "+colorLightBlue+"</b>metaLib"+CT+" back to your server "+char(10)+
	"---- allows you to use your hardware to scan the remote libs."+char(10)+
	"-- use <b>bios> along with <b>cob get</b> and <b>cob set</b> to import/export objects"+char(10)+char(10)+
	"eg: <b>meta -i @o myx1 | meta link net.so | meta -i @o myx0 | meta scan"+char(10)+
	"-- a library from the machine connected to myx1 will be scanned using"+char(10)+
	"---- the hardware of the machine connected to myx0"
	if arg1 then

		if typeof(arg1) == "MetaLib" then 
				globals.metaLib = arg1
				print "meta: loaded new <b>MetaLib</b> object"
				return command.linkdb(arg1.lib_name+" v "+arg1.version,"-y")
		end if
	
		if arg1 == "import" or arg1 == "-i" then 
			if not arg2 or (typeof(arg2) != "string" and typeof(arg2) != "MetaxploitLib") then return "meta: -i expects a metaxploitLib object or a path to a metaxploit.so"
			//print "<size=75%>meta: backing up current metaxploit object"
			//globals.backup_meta = globals.metaxploit
			print "<size=75%>meta: importing MetaxploitLib..."
			globals.metaxploit = null
			target_lib = null
			if typeof(arg2) == "string" then 
				target_lib = globals.get_file(arg2)
				if target_lib then globals.metaxploit = include_lib(target_lib.path)
			end if
			if typeof(arg2) == "MetaxploitLib" then globals.metaxploit = arg2 

			if not globals.metaxploit or typeof(globals.metaxploit) != "MetaxploitLib" then 
				globals.metaxploit = globals.backup_meta
				if typeof(arg2) == "string" then reason = "-- invalid path" else reason = "-- invalid input"
				return "meta: metaxploit import failed: "+char(10)+reason+char(10)+"meta: backup metaxploit restored"
			end if
			return colorWhite+"<u>meta: a new metaxploitLib has been imported!"+char(10)+"<size=75%>-- to revert back to the launch metaxploitLib use:"+char(10)+"<size=75%>---- <b>meta restore"+char(10)+"<size=75%>---- <b>hot_swap_libs</b> option in <b>aptm"
		end if
	
		if arg1 == "restore" then 
			if globals.backup_meta then 
				globals.metaxploit = globals.backup_meta 
				if typeof(globals.metaxploit) == "MetaxploitLib" then return "meta: backup metaxploitLib restored" else return colorRed+"meta: error! backup metaxploitLib corrupted!"+char(10)+"-- use <b>meta -i [/path]</b> to manually restore"
			else 
				return "meta: no backup metaxploitLib to restore"
			end if
		end if
	
		if not globals.metaxploit then return "metaxploit.so not found"
	
		if arg1 == "link" or arg1 == "-r" then
			arg = 0
			if arg2 and typeof(arg2) == "MetaLib" then 
				globals.metaLib = arg2
				print colorLightBlue+"</b><size=75%>meta: linked new <b>MetaLib</b> object"
				return command.linkdb(arg2.lib_name+" v "+arg2.version,"-y")
			end if
			if not localmachine.is_network_active then return "meta: no network connection!"
			arg = "Y"
			if arg2 and is_valid_ip(arg2) then globals.targetIP = arg2
			if arg3 and (typeof(arg3.to_int) == "number" or arg3 == "router") then globals.targetPort = arg3.to_int
			if globals.targetIP then // and globals.targetPort then
				ldb = command.linkdb(get_lib(arg),"-y") // edit get_lib to take 3rd param: auto link
				if ldb then print ldb+char(10)+"meta: returning..."
				return globals.metaLib
			else
				return "meta: invalid target IP"
			end if
		end if
	
		if arg1 == "load" or arg1 == "-l" then 
			if arg2 and typeof(arg2) == "MetaLib" then 
				globals.metaLib = arg2
				print colorLightBlue+"</b><size=75%>meta: loaded new <b>MetaLib</b> object:"
				ldb = command.linkdb(arg2.lib_name+" v "+arg2.version,"-y")
				if ldb then print ldb+char(10)+"meta: returning..."
				return globals.metaLib
			end if
			arg = "L"
			scan_this_lib = arg2
			ldb = command.linkdb(get_lib(arg,scan_this_lib),"-y") //else return "meta: invalid metaLib"// edit get_lib to take 3rd param: auto link
			if ldb then print ldb+char(10)+"meta: returning..."
			return globals.metaLib
		end if
	
		if arg1 == "return" then return globals.metaLib

		if arg1 == "-x" then return globals.metaxploit
	
		if arg1 == "scan" then
			if not globals.metaxploit then return colorRed+"meta: error: metaxploitLib not found"
			if globals.metaLib then
				//get_lib
				globals.scan_memory
			else
				print("meta: please establish a net session"+char(10)+"-- or load a lib with:"+char(10)+"<b>meta link [-l|-r]</b> "+char(10)+"-- before scanning" )
			end if
			return 0
		end if
	
	end if
	
	if not globals.metaxploit then print "meta: metaxploit.so not found" 
	if typeof(globals.metaLib) == "MetaLib" then return globals.metaLib.lib_name + " v " +globals.metaLib.version
	return "meta: no MetaLib linked"
	
end function
command.zap = function(arg1, arg2, arg3="", arg4)
	if arg1 == "help" or arg1 == "-h" then return "ZAP || Single Attack || overflow || exploit || hack"+char(10)+
	"<b>Usage: zap [opt:-r] [opt:index|mem_address] [opt:inject|unsec_value] [opt:inject]"+char(10)+char(10)+
	"Usage: "+colorRed+"zap"+colorWhite+"</b> [opt:-r]</color> -- select attack; Equivalent to 5phinx [A]"+char(10)+
	"-- brings up attack selection menu"+char(10)+
	"-- prompts for inject value"+char(10)+
	"-- if successful prompts to view the object in the BUFFER"+char(10)+
	"---- use the -r flag to skip the BUFFER prompt:"+char(10)+
	"----eg: <b>zap -r"+char(10)+char(10)+
	"Usage: "+colorRed+"zap"+colorWhite+"</b> [opt:-r] [index#] [opt:inject]</color> -- run the attack at index[#], skipping the menu "+char(10)+
	"-- passing an inject value skips the inject prompt after the menu"+char(10)+
	"----eg: <b>zap 1"+char(10)+
	"----eg: <b>zap 1 192.168.0.2"+char(10)+
	"-- passing an inject value is for password change exploits and "+colorOrange+"bounce exploits"+char(10)+
	"-- if successful prompts to view the object in the BUFFER"+char(10)+
	"-- use the -r flag to skip the BUFFER prompt: "+char(10)+
	"----eg: <b>zap -r 1 "+char(10)+
	"-- use use -r and supply an inject to skip inject prompt as well"+char(10)+
	"----eg: <b>zap -r 1 password"+char(10)+char(10)+
	"Usage: "+colorRed+"zap"+colorWhite+"</b> [memory_address] [unsec_value] [opt:inject]</color> -- manually input overflow parameters"+char(10)+
	"-- skips all prompts"+char(10)+
	"--eg: <b>zap 0x2D7A08D5 effectsetfocusonshowso password"+char(10)+char(10)+
	"NOTE: all modes return the result when successful"+char(10)+
	"NOTE: <b>inject</b> should be of type password or LAN IP or left blank, depending on the attack"+char(10)+
	"NB: use the <b>roil</b> command to fire all attacks at once"

	if not metaLib then return "Link metaLib before continuing."
	print colorRed+"<size=75%><u>zap:<color=white> zapping..."
	ret = 0
	if arg1 == "-r" then 
		ret = 1
		arg1 = arg2 
		arg2 = arg3 
		arg3 = arg4 
	end if
	if arg1 and arg1.indexOf(char(32)) != null then 
		a = arg1.split(char(32))
		arg4 = arg3
		arg3 = arg2
		arg2 = a[1]
		arg1 = a[0]
		if typeof(arg1) or typeof(arg2) or typeof(arg3) != "string" then return "zap: error; invalid input"
	end if
	if typeof(arg1) == "string" and typeof(arg1.to_int) != "number" then
		result = null
		//if arg3 then
			if typeof(arg2) != "string" then return "zap: invalid input"
			if arg3 and typeof(arg3) != "string" then arg3 = ""
			result = globals.metaLib.overflow( arg1, arg2, arg3 )
		//else
			//result = globals.metaLib.overflow( arg1, arg2 )
		//end if
		if result and result != 1 then 
			print "malp: sending "+typeof(result)+" to "+colorOrange+" BUFFER..."
			globals.BUFFER.push(result)
		end if
		print colorRed+"</b>zap: "+colorWhite+"</b>returning..."
		return result
	end if

	return globals.select_attack(arg1,arg2,ret)
end function
command.roil = function(arg1, arg2=0, arg3=0, arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "Attack All | Spam Attack | Run all Exploits | Into the Roil"+char(10)+
	"Usage: roil [opt: [inject] | opt: [-p|--prompt]] -- launches hail mary overflow attack "+char(10)+
	"-- equivalent to option [2] in 5phinx"+char(10)+
	"-- optional inject value may be a lan ip or a password, depending on the target"+char(10)+
	"---- if attacking a router: inject should be a lan ip, to be used with a BOUNCE exploit"+char(10)+
	"---- if attacking a server: inject should be a password, to be used with pw change exploits"+char(10)+
	"<b>-- if inject is -p or --prompt then roil will prompt for the following:"+char(10)+
	"---- an inject value (ip or pw)"+char(10)+
	"---- if a <b><color=yellow>shell is found, you will get an Open Shell? prompt"+char(10)+
	"---- if a <b><color=white>computer is found, the computer handler will open"+char(10)+
	"---- if a <b><color=green>file is found, 5hell will run <b>tree</b> on the file object"+char(10)+
	"Note: roil returns zero and sends all objects to the "+colorOrange+"BUFFER."+char(10)+
	"Note: an inject value only matters for password change and bounce exploits"+char(10)+
	"N.B.: roil does <b>not</b> database results; use <b>db</b> instead"+char(10)+
	"-- this may change in the future"
	globals.roil(arg1)
	return 0
end function
command.aptm = function(arg1, arg2, arg3=0, arg4=0) // requires aptclient.so
	if arg1 == "-h" or arg1 == "help" then return "<u>Apt-Get Menu</u>"+char(10)+"Usage: aptm -- apt-get menu: "+char(10)+
	"-- manage apt functions"+char(10)+
	"-- add/remove/search repositories."+char(10)+
	"Usage: aptm [piped_aptclientLib] -- change scope of aptm to supplied lib"+char(10)+
	"-- eg: bios -a | cob set apt | exit"+char(10)+
	"-- when used on a remote 'silent launch' of 5hell"+char(10)+
	"---- pipes aptclientLib to the custom object then exits back to original 5hell"+char(10)+
	"-- cob get apt | aptm"+char(10)+
	"---- pipes aptclientLib to aptm and changes scope of aptm to remote"+char(10)+
	"Advanced: press [7] hot_swap_libs in aptm "+char(10)+
	"-- reloads meta/crypto/apt to use latest versions after updating"+char(10)+char(10)+
	"APT command line options (skips the menu):"+char(10)+
	"Usage: <b>aptm [-i] [filename] [opt: path] </b>-- install filename, if it exists"+char(10)+
	"-- if not provided, the install path will be the repository's default"+char(10)+
	"-- this is usually /bin or /lib or /usr/bin"+char(10)+char(10)+
	"Usage: <b>aptm [-a] [repo_ip] </b>-- add a repository's ip to /etc/apt/sources.txt"+char(10)+char(10)+
	"Usage: <b>aptm [-d] [repo_ip|repo_index] </b>-- remove a repository's ip from /etc/apt/sources.txt"+char(10)+char(10)+
	"Usage: <b>aptm [-u] [/path/filename] </b>-- check for a new version of a file"+char(10)+char(10)+
	"Usage: <b>aptm [-s] [opt:filename] </b>-- search repositories for filename"+char(10)+
	"-- searches all repos in sources.txt"+char(10)+
	"-- shows all available files if no filename is provided"+char(10)+char(10)+
	"Usage: <b>aptm [--hotswap] </b>-- reload metaxploit.so, crypto.so, and aptclient.so from disk"+char(10)+
	"-- searches for and loads the latest version of each lib <b>on disk"+char(10)+
	"---- does not run aptm upgrade"+char(10)+
	"-- this is the same include_lib routine executed at launch"
  	if GLASSPOOL then print(colorOrange+"Ignores Glasspool."+CT)
	// apt menu by Plu70
	if arg1 and typeof(arg1) == "aptclientLib" then
		print "apt-get-menu: importing alternate aptclientLib"+char(10)+"-- pipe the old lib back to restore"+char(10)+"-- eg: liber -i /lib/aptclient.so | aptm"
		globals.apt_get = arg1 
	end if
	if not globals.apt_get and arg1 != "--hotswap" then return "aptm: "+colorRed+"Error: no aptclientLib loaded"+char(10)+"-- reload with: aptm --hotswap"
	apt = {}
	apt.exit = function()
		return 0
	end function
	apt.check_upgrade = function(override=0)
		apt.update
		chk_upg = function(check)
			need_up = apt_get.check_upgrade(check)
			if need_up == check+" does not exist in this filesystem" and check.split("/").len == 1 then need_up = apt_get.check_upgrade("/lib/"+check)
			if need_up == 1 then
				sp = check.split("/")
				nm = sp.pop
				if sp != [] then
					print("__")
					apt_get.install(nm, sp.join("/"))
				else
					print("__")
					apt_get.install(nm)
				end if
				return "apt-get: "+check+" upgrade complete"
			else
				return "apt-get: "+check+" no upgrades found"+char(10)+"-- "+need_up
			end if
		end function
		if typeof(arg2) == "string" and arg2 != "" then cup = arg2 else cup = user_input("upgrade file_name or /path"+char(10)+":> ")
    	if not cup or cup == "" or cup == " " then return print("aborting...")
		if DEBUG then print "debug: aptm: searching for: "+cup
		//f = get_shell.host_computer.File(cup)
		f = globals.get_file(cup)
		if f and f.is_folder then
			files = f.get_files
			print("Checking: "+f.path+char(10)+"Found: "+files.len+" files.")
			for sub in files
				print(chk_upg(sub.path))
			end for
			return print("Batch complete.")
		end if
    	if f then 
			return print(chk_upg(f.path)) 
		else 
			return "aptm: warning: file not found on system at given path"+char(10)+
			"-- if the lib is not located in /lib, you must use an absolute path"+char(10)+
			"-- if you are using a remote aptclientlib.so;"+char(10)+
			"---- rerun with <b>aptm -U [libname|path]</b> to force the upgrade"
		end if
			return print(chk_upg(cup)) // when using a remote aptclientlib, a file may be on the target that is not on the attacking machine
	end function
	apt.add_repo = function()
		apt.update
	  	if typeof(arg2) == "string" and is_valid_ip(arg2)then a = arg2 else a = user_input("Add repo ip:> ")
			if is_valid_ip(a) then return print(apt_get.add_repo(a)) else return "aptm: invalid repo ip"
	end function
	apt.del_repo = function()
		apt.update
		rl = apt.list_repos
		if rl.len < 1 then return print("aptm: no repositories to delete")
		i = 0
		for r in rl 
			print colorGreen+"["+colorWhite+i+CT+"] "+colorYellow+r
		end for
		if arg2 and ( (typeof(arg2) == "string" and arg2 != "" ) or typeof(arg2.to_int) == "number") then
			a = arg2
		else
			a = user_input("Delete repo ip or index (<<b>enter<b>>=abort):> ")
		end if
		if a == "" then return print("aptm: aborting...")
		if not is_valid_ip(a) then 
			if typeof(a.to_int) != "number" then return "aptm: invalid index or ip"
			a = a.to_int
			if a >= 0 and a < rl.len then a = rl[a] else return print("aptm: invalid index")
		end if
		return print(apt_get.del_repo(a)) 
	end function
	apt.list_repos = function()
		apt.update
		sources = globals.get_file("/etc/apt/sources.txt")
		if not sources then return print(colorWarning+"aptm: can't find or create sources.txt!")
		if sources.has_permission("r") then sources = sources.get_content else return print(colorWarning+"aptm: sourcs.txt is read protected")
		sources = sources.split(char(10))
		for line in sources 
			sources[sources.indexOf(line)] = line.split(":")[0].split("""")[1]
		end for
		reps = []
		for s in sources 
			if is_valid_ip(s) then reps.push(s)
		end for
		return reps
	end function
	apt.install = function()
		if typeof(arg2) == "string" and arg2 != "" then return print(apt_get.install(arg2,arg3)) else return print(apt_get.install(user_input("Install File(<<b>enter</b>>=abort):><b> "), user_input("Install Directory (<<b>enter</b>>=default)"+char(10)+":> ")))
	end function
	apt.search = function()
		apt.update
		if typeof(arg2) == "string" and arg2 != "" then a = arg2 else a = (user_input("search (<<b>enter</b>>=all):> "))
		return print(apt_get.search(a))
	end function
	apt.show = function()
		apt.update
		print("_____________________________________________"+char(10))
		rb = apt_get.show(user_input("Show repo (<<b>enter</b>>=all):> "))
	  return print(char(10)+rb)
	end function
	apt.hot_swap = function()
		globals.super_import
		print "aptm: libraries hot_swapped."
		return 1
	end function
	apt.update = function()
	  print "<size=75%>Updating repositories..."
	  return print(apt_get.update)
	end function
	
	// check for cli launch args
	apting = false 
	if not arg2 then arg2 = ""
	if not arg3 then arg3 = ""
	paf = function()
		outer.apting = true 
		outer.arg2 = 0
	end function
	// switch(variable)
		// 	case( condition, @action )
		//  case( condition, @action )
		//  case(...)
	// default( @action )
	switch(arg1)
		case("-u", @apt.check_upgrade)
		case("-i", @apt.install)
		case("-a", @apt.add_repo)
		case("-d", @apt.del_repo)
		case("-s", @apt.search)
		case("--hotswap", @apt.hot_swap)
	default( @paf )
	
	//apting = true
	while apting
		apt.update
		i = 0
		for c in apt.indexes
			print("["+colorWhite+i+CT+"] - apt-get."+"<b>"+c+"</b>")
			i = i + 1
		end for
		//print("["+colorWhite+i+CT+"] - Exit")
		a_choice = user_input("(q=quit)||: ",0,1).to_int
		if a_choice == 0 or a_choice == "q" then return 0
		if typeof(a_choice) != "number" or a_choice >= i or a_choice < 0 then continue
		print(apt.indexes[a_choice])
		ap = apt[apt.indexes[a_choice]]
		ap
		print("_____________________________________________")
		print
	end while
	return 0
end function
command.smtp = function(arg1,arg2=0,arg3=0,arg4=0)
	if arg1 == "help" or arg1 == "-h" then return "SMTP || MAIL USER LIST"+char(10)+"Usage: smtp [ip] [port] -- return mail user list if ip/port is running smtp mail server"+char(10)+"-- user target ip and target port if not supplied"
	tar_ip = 0
	tar_port = 0
	if not globals.crypto then return "smtp: crypto.so not found"
	if arg1 then 
		if is_valid_ip(arg1) then tar_ip = arg1
	else 
		if globals.targetIP then tar_ip = globals.targetIP else return "smtp: invalid or unsupplied ip address"
	end if
	if arg2 and typeof(arg2.to_int) == "number" then tar_port = arg2.to_int
	if not tar_port then 
		if globals.targetPort then tar_port = globals.targetPort else tar_port = 25 // return "smtp: invalid or unsupplied port"
	end if
	print colorGreen+"smtp: pulling from "+CT+colorWhite+tar_ip+colorGreen+": "+CT+tar_port+CT+"..."
	ml = globals.mail_user_list(tar_ip,tar_port)
	if not ml then return "smtp: mail server not found" else return ml
end function
command.osint = function(option_flags, octet_rules, user_name, spool)
    if not option_flags or option_flags == "help" or option_flags == "-h" then return " osint || open source information || OSINT || fuzzer"+char(10)+
    colorWhite+"Usage: osint [option] [ip_octet_rules] [user_name] [bool:spool]"+char(10)+
	"-- scour domains for valid emails using: user_name@domain"+char(10)+
	"note: a mail account is required to use this function"+char(10)+
    colorGold+"</b>Options:"+char(10)+
	"  "" ""  [-l|list] -- return output as a list of domain strings"+char(10)+
    "  "" ""  [-s|space] -- return output as a string of single spaced domains"+char(10)+
    "  "" ""  [-n|newline] -- return output as a string of domains; one per line"+char(10)+
    "  "" ""  [-c|comma] -- return output as a comma separated value "+char(10)+
    colorGold+"</b>Octet Rules:"+char(10)+
    "Input method:"+colorWhite+"list"+CT+" -- supply a list with 8 indexes containing ints or string:ints corresponding-"+char(10)+
    "to the minimum and maximum values for each octet, in order. This means if our octets are:"+char(10)+
    "<b>k.j.i.h</b> and the ip range we want is 1.1.1.1 to 115.1.1.255, the list would be:"+char(10)+
    "<b>[1,115,1,1,1,1,1,255]</b><color=white>"+char(10)+
	"-- where [0] is k_min, [1] is k_max, [2] is j_min, [3] is j_max, and so on."+char(10)+
    "-- incomplete octet rules or out-of-bounds entries will return an error. "+char(10)+
    "Input method:"+colorWhite+"string"+CT+" -- supply a string, without spaces, formed as follows:"+char(10)+
    colorCyan+" oc1_min-oct1_max"+CT+"."+colorCyan+"oct2_min-oct2_max"+CT+"."+colorCyan+"oct3_min-oct3_max"+CT+"."+colorCyan+"oct4_min-oct4_max "+char(10)+
    "--eg: 1-200.1-1.0-234.1-255"+char(10)+
    colorGold+"</b>User name:"+char(10)+
    "Input: any npc user name "+char(10)+
    colorGold+"Spool:"+char(10)+
	"-- bool:[1|0] pass a positive value for the 'spool' parameter to write results to disk"+char(10)+
    "-- writes to current_path/spool.osint"+char(10)+
	colorGold+"Output:"+char(10)+
	"--  osint will perform a whois lookup on each ip"+char(10)+
    "---- parse the string for the ip's domain"+char(10)+
    "---- attempt to locate username@domain to determine if it exists"+char(10)+
    "---- on positive hit, push domain to output buffer"+char(10)+
    "---- return results based on options"
	// banner
	print colorLightBlue+"<u><size=125%>OS"+colorWhite+"int npc finder v0.9 by Plu</color>70"
	// handle error checking and input validation
	if not octet_rules or (typeof(octet_rules) != "string" and typeof(octet_rules) != "list") then return "osint: invalid octet rules: expects list or string"
	if not user_name or typeof(user_name) != "string" then return "osint: invalid user name: expects string "
	// confirm mail account is active 
	if not globals.inbox then 
		print "Please login to a mail account then return here to continue: "
		command.mail 
	end if
	if not globals.inbox then return "osint: please login to a mail account before continuing"
	// prepare octet rules
	if typeof(octet_rules) == "string" then 
		octet_buff = octet_rules.split("\.")
		octet_rules = []
		for pair in octet_buff
			p = pair.split("-")
			if p.len != 2 then return "osint: malformed octet rules: expects list or string:"+char(10)+"[k_s,k_e,j_s,j_e,i_s,i_e,h_s,h_e]"+char(10)+"k_s-ke.j_s-j_e.i_s-i_e.h_s-h_e"
			if p[0] > p[1] then return "osint: octet max must be less than or equal to octet min"
			octet_rules.push(p[0])
			octet_rules.push(p[1])
		end for
	end if 
	l = 0
	for o in octet_rules
		if typeof(o) != "number" and typeof(o) == "string" then o = o.to_int
		if typeof(o) != "number" then return "osint: malformed octet rules: expects list:[int|string] or string:"+char(10)+"[k_s,k_e,j_s,j_e,i_s,i_e,h_s,h_e]"+char(10)+"k_s-ke.j_s-j_e.i_s-i_e.h_s-h_e"
		octet_rules[l] = o
		l = l + 1
	end for
	if octet_rules.len != 8 then return "osint: malformed octet rules: expects list or string:"+char(10)+"[k_s,k_e,j_s,j_e,i_s,i_e,h_s,h_e]"+char(10)+"k_s-ke.j_s-j_e.i_s-i_e.h_s-h_e"
    if octet_rules[1] == 0 then return "osint: octet_1_max must be greater than 0"
		// handle option flags to set delimiter
    delim = ""
	verbose = false
    if option_flags == "-cv" or option_flags == "-c" then
        delim = ","
		if option_flags == "-cv" then verbose = true
    end if 
	if option_flags == "-nv" or option_flags == "-n" then
        	delim = char(10)
			if option_flags == "-nv" then verbose = true
    end if 
	if option_flags == "-lv" or option_flags == "-l" then
        delim = "list"
		if option_flags == "-lv" then verbose = true
    end if 
	if option_flags == "-sv" or option_flags == "-s" then 
        delim = char(32)
		if option_flags == "-sv" then verbose = true
    end if
    // check for the output file if spool flag is set
    spool_file = null
    if spool then
        spool_file = command.poke("spool.osint")
        if not spool_file or typeof(spool_file) != "file" then
            return "error: please create spool.osint before continuing"
        end if
    end if
	// prepare the output buffer list
    d_list = []
	cycle = 0
    // generate the output by iterating through IP octet ranges
	print "osint: scanning... "+char(10)+colorWhite+"<size=125%><align=center>>.>"
    for k in range(octet_rules[0], octet_rules[1])  // assuming [start, end] for each octet
        for j in range(octet_rules[2], octet_rules[3])
            for i in range(octet_rules[4], octet_rules[5])
                for h in range(octet_rules[6], octet_rules[7])
                    ip = str(k) + "." + str(j) + "." + str(i) + "." + str(h)
                    // Validate IP format and check if its a LAN IP
                    if not is_valid_ip(ip) or is_lan_ip(ip) then continue
                    // Perform WHOIS lookup and parse the result
                    who_string = whois(ip)
					if who_string.indexOf("[Neurobox") != null then who_string = who_string.split(char(10)) else continue
					//the following got nerfed, can't check if an email exists this way any more
                    if DEBUG then print "debug: in osint loop: domain: "+domain
                    // Attempt to send mail and check if user exists
					if who_string[0].indexOf(": ") == null then continue
                    domain = who_string[0].split(": ")[1].remove("www.")
                    targ = user_name + "@" + domain
                    if verbose or DEBUG then print "osint: attempting: "+ip+" : "+targ
					if globals.inbox.send(targ,"do not reply","your account has been suspended due to non payment") != "Mail not delivered" then 
						d_list.push(targ)
						print colorWhite+targ
						// Write the output to spool file if spool is true
						if spool then
							print("osint: writing results to:" + spool_file.path)
							result = spool_file.set_content(d_list.join(char(10)))
							if result != 1 then
								print "error: unable to write to spool file"
							end if
						end if
					end if 
					wait(2.5)
					if cycle % 1000 == 0 then wait(.1)
					if DEBUG then print "scanning..."
					cycle = cycle + 1
                end for
            end for
        end for
    end for
    
    // Return the output as per the specified delimiter
    if delim == "list" then
        return d_list
    else
        return d_list.join(delim)
    end if
end function
command.fetch = function(arg1,arg2,arg3,arg4)
	if arg1 == "help" or arg1 == "-h" then return "SPOT || FETCH || MetaxploitLib || krberos"+char(10)+char(10)+
	colorGold+"</b>Usage: fetch [-b] [shell_object|path] [path|shell_object] "+char(10)+
	"-- download the system.log and all binaries in /home from target shell"+char(10)+
	"--eg:"+colorGold+"</b> fetch -b @B 1 /root"+char(10)+
	"--eg:"+colorGold+"</b> zap | fetch -b /root"+char(10)+
	"--eg:"+colorGold+"</b> rsi -r 1 | fetch -b"+char(10)+
	colorGold+"Usage: fetch [-l] [shell_object|path] [path|shell_object]"+char(10)+
	"-- as above but only files ending in <b>.log</b>"+char(10)+
	colorGold+"</b>Usage: fetch [shell_object] -- obtain a MetaxploitLib object from a supplied shell"+char(10)+
	"-- uploads metaxploit.so to /home/guest"+char(10)+
	"-- creates a source file in /home/guest"+char(10)+
	"-- builds and runs the file"+char(10)+
	"-- places the MetaxploitLib in the <b>custom object</b> under index:"+colorGold+" fetched"+char(10)+
	"-- 'spots' out the files; moves them all to an empty file named '.'"+char(10)+
	"-- returns the MetaxploitLib as an object"+char(10)+
	"--eg:"+colorGold+"</b> zap | fetch"+char(10)+char(10)+
	"NOTE: does <b>not</b> scrub the log; does not use rm to remove files"+char(10)+
	"-- don't forget to scrub the log, if necessary"+char(10)+
	"NOTE: This is not a jump file. It is a spot file. That is all."
	if arg1 == "-b" or arg1 == "-l" then 
		shl = null 
		pth = globals.currentPath
		if typeof(arg2) == "shell" then shl = arg2 else shl = arg3
		if typeof(arg2) == "string" then pth = arg2 else pth = arg3
		print colorOrange+"fetch: getting binaries..."
		if typeof(shl) != "shell" then return "fetch: -b expects shell, got: "+typeof(arg2) 
		if typeof(pth) != "string" then print "fetch: invalid destination path;"+char(10)+"-- defaulting to: "+pth
		if DEBUG then print "debug: in fetching from "+shl+" to "+pth
		if arg1 == "-b" then return globals.get_binaries(shl,pth) else return globals.get_binaries(shl,pth,1)
	end if
	//
	if typeof(arg1) != "shell" then return 0
	print colorGold+"</b>fetch: fetching MetaxploitLib from: "+char(10)+colorWhite+"</b>"+arg1.host_computer.public_ip+ " <b>:</b> "+arg1.host_computer.local_ip
	//my_x = globals.get_file(meta_path)
	my_x = globals.get_file(MetaxploitLib.path)
	if not my_x then my_x = command.grep("-f","metaxploit.so")
	if typeof(my_x) != "file" then return "fetch: failed: metaxploit.so not found" 
	my_perms = my_x.permissions.values 
	pr = my_perms[-3]
	pw = my_perms[-2]
	px = my_perms[-1]
	print colorGold+"</b>-- preparing payload..."
	print colorGold+"</b>-- setting permissions..."
	ctch = command.perms("o+rwx",my_x.path)
	if ctch then print ctch
	print my_x.path + " " + my_x.permissions
	print colorGold+"</b>-- uploading payload..."
	print globals.shell.scp(my_x.path,"/home/guest",arg1)
	print colorGold+"</b>-- restoring permissions..."
	if pr == "-" then pr = "r" else pr = ""
	if pw == "-" then pw = "w" else pw = ""
	if px == "-" then px = "x" else px = ""
	ctch = command.perms("o-"+pr+pw+px,my_x.path)
	if ctch then print ctch
	print my_x.path + " " + my_x.permissions
	arg1.host_computer.touch("/home/guest","...src")
	imp = arg1.host_computer.File("/home/guest/...src")
	if not imp then 
		return colorGold+"</b>fetch: infiltration failed, cannot write to /home/guest" 
	else 
        print colorGold+"</b>fetch: spot file created: "+char(10)+imp.path+ " " +imp.permissions
	end if
	mole = "get_custom_object.fetched = include_lib(""/home/guest/metaxploit.so"")"
	imp.set_content(mole)
	print colorGold+"</b>-- clearing out fetched cache..."
	if get_custom_object.hasIndex("fetched") then get_custom_object.remove("fetched")
	print colorGold+"</b>-- building spot file..."
	ctch = arg1.build(imp.path,imp.parent.path)
	if ctch then print ctch 
	print colorGold+"</b>-- launching payload..."
	globals.stack_pool("up")
	arg1.launch("/home/guest/..")
	//_cascade // exit if cascade
	globals.stack_pool("down")
	print colorGold+"</b>-- spotting metaxploit and source files..."
	imp.set_content("")
	imp.move("/home/guest","metaxploit.so")
	imp.move("/home/guest","..")
	if typeof(arg1.host_computer.File("/home/guest/.Trash")) == "file" then imp.move("/home/guest/.Trash","..")
	print colorWarning+"</b><size=75%>fetch: a file deletion log has <b>not</b> been left, however:"+char(10)
	print "<size=75%>-- and empty spot file has been left at: "+colorWhite+imp.path+char(10)+"<size=75%>-- if you are able to get root on the target"+char(10)+"<size=75%>---- consider removing this file and scrubbing the log, anyway"
	if get_custom_object.hasIndex("fetched") then
	  print "cob: set <b>fetched</b> to <b>"+get_custom_object.fetched
	  print colorGold+"</b>fetch: task complete; returning..."
	  return get_custom_object.fetched	
	else 
	  print "fetch: failed to obtain remote MetaxploitLib"
	  return 0
	end if
	return 0
end function
command.porter = function(arg1, arg2, arg3=0, arg4=0)
	if not arg2 or arg1 == "help" or arg1 == "-h" then return "Usage: porter [port] [comma,or,newline,separated,ip,list] --  print lib version of service on port, if any, for given ip address(es)"
	if not localmachine.is_network_active then return "nsl: no network connection."
	r_buf = []
	ip = arg2
	if ip.split(char(10)).len > 1 then
		ip = ip.split(char(10))
		ip = ip.join(",")
	end if
	array = false
	if ip.indexOf(",") >= 0 then
		ip = ip.split(",")
		array = true
	else
		i = ip
		ip = [i]
	end if
	a_size = 1
	if array then a_size = ip.len
	port = 0
	if arg1 then port = arg1.to_int else port = 0
	time_s = time
	print(colorLightBlue+"- - - - - - - - - - - - - - - - - - - - -"+CT)
	print(colorLightBlue+"<align=center><b>(>|<)</b></align>"+CT)
	for r in range(1, a_size)
		i = ip[r-1]
		if not localmachine.is_network_active then return "porter: no network connection found."
		rtr = get_router(i)
		if typeof(rtr) != "router" then continue
		if port then
			pinfo = null
			png = rtr.ping_port(port)
			if png then pinfo = rtr.port_info(png)
			if pinfo then r_buf.push(i+" "+port+": "+pinfo)
		else
			pinfo = rtr.kernel_version
			if pinfo then r_buf.push(i+" router: "+pinfo)
		end if
	end for
	if r_buf == [] then r_buf.push("Porter: No_results_found.")
	print(colorLightBlue+"Porter: task complete in "+colorOrange+(time - time_s)+colorLightBlue+" seconds."+CT)
	save = "y"//user_input("Send results to clipb? [y/N] "+char(10)+"||: ",0,1)
	if save.lower == "y" then command.clipb(r_buf.join(char(10)))
	return colorLightBlue+"Porter: clipped"+CT+char(10)+format_columns(r_buf.join(char(10)))+char(10)+colorLightBlue+" - - - - - - - - - - - - - - - - - - - - "+CT
end function
command.infil = function(sh_ob,par=0,arg2,arg3)
	cgo = colorGold+"</b>"
	cw = colorWhite+"</b>"
    cr = colorRed+"</b>"
	if @sh_ob == "help" or @sh_ob == "-h" then return "Infil || infiltrate || infiltration || upload rkit"+char(10)+
	cw+"Usage: "+cgo+"infil"+cw+" ["+cgo+"shell_object"+CT+"] -- automatic door kicker"+char(10)+
	"-- uploads rkit to /home/guest on target shell and then launches 5hell"+char(10)+
	"-- does not accept launch params;"+char(10)+
	"---- include desired launch behavior in rkit/do.rc before upload"+char(10)+
	"--eg: <b>zap | infil"+char(10)+
	"NOTE: the /home/guest destination is hard coded as this is always open on "+char(10)+
	"-- untouched npc machines"+char(10)+
	"-- create a macro that mimics infil's behavior (perms, scpm, perms, run)"+char(10)+
	"-- to use a different destination folder"
	if typeof(@sh_ob) != "shell" then return "usage: infil [shell_object]"+char(10)+"-- or:<b> infil -h "
    kit = null
    kit = command.tree("/","rkit","1","N")
    if typeof(kit) != "file" then return cr+"infil: rkit not found; aborting..." else cgo+"infil: found: "+kit.permissions+" "+kit.path

    kperms = kit.permissions.values
    kpx = kperms[-1]
    kpw = kperms[-2]
    kpr = kperms[-3]
    print cgo+"infil: changing rkit permissions to <b>o+rwx</b> for upload..."
    print command.perms("-r","o+rwx", kit.path)
    print cgo+"infil: uploading..."
    copytrue = command.scpm("-u",kit.path,"/home/guest",sh_ob)
    print cgo+"infil: restoring permissions..."
    if kpx == "-" and kpw == "-" and kpr == "-" then
        print command.perms("-r","o-rwx", kit.path)
    else
        if kpx == "-" then kpx = "x" else kpx = ""
        if kpw == "-" then kpw = "w" else kpw = ""
        if kpr == "-" then kpr = "r" else kpr = ""
        print command.perms("-r", "o-"+kpr+kpw+kpx, kit.path)
    end if
    print kit.permissions+" "+kit.owner+" "+kit.group+" "+kit.size+" "+kit.path
    if copytrue == "scp: failed" then return copytrue else print copytrue
    print cgo+"infil: successfully uploaded rootkit: "+kit.path+char(10)+cgo+"-- to: /home/guest/rkit"

    if typeof(sh_ob) == "ftpshell" then return cr+"infil: unable to launch via ftpshell; returning..."
    
    print colorWhite+"<size=75%></b>Initializing sshfs "+colorLightBlue+"</b>glasspool</color> protocol..."+CT
    //print colorWhite+"</b><size=65%>-- preparing to run "+colorRed+"</b>5</color>hell silently on the target..." // this is no longer possible, will always show in procs if shell.launch is used

    print colorWhite+"<size=75%><u>-- injecting process <u>"+cgo+"/home/guest/rkit/5hell</u></color> into 0x"+colorLightBlue+"</b>0B"+floor(rnd * 10)+floor(rnd * 10)+floor(rnd * 10)+"5C"+floor(rnd * 10)+"...</u></size>"
    print command.run("/home/guest/rkit/5hell",par,sh_ob)
    //_cascade // exit if cascade
    globals.update_path
    return cgo+"<size=75%>infil: infiltration complete"
end function
command.flood = function(fip,fpt,c,d)
	if fip == "help" or fip == "-h" then return "flood connection || ddos || denial of service

Usage: <b>flood [opt:ip] [opt:port]</b> -- ddos a target server running a service
-- uses global target ip and/or port if not supplied
-- sets global target ip and/or port if supplied
-- obtains both net_session and metalib on target
-- initiates flood_connection on the net_session

Usage: <b>flood [net_session]</b> -- runs flood_connection on the piped object
-- does not alter targetIP or targetPort

<b>N.B.: if a DDOS attack is successful, the target will be temporarily offline.
That is: it will be rebooted.
The number if instances required to DDOS a target <b>depends on the network speed</b>
of the target. Each instance must be run <b>from a unique network</b>. Since players
are limited in the number of terminal windows they may open, the player may need
<b>other players</b> to attack the target in unison to be successful."
	if not globals.metaxploit then return colorWarning+"flood: no metaxploitLib loaded!"
	if fip and not is_valid_ip(fip) then
		if not is_valid_ip(globals.targetIP) then return "flood: please set or supply a target ip" else fip = globals.targetIP 
	end if
	if not fip then return "flood: invalid ip; aborting..."
	if not fpt then 
		if not globals.targetPort or globals.targetPort != "router" then fpt = 0 else fpt = globals.targetPort
	end if
	if typeof(fpt) != "number" and typeof(fpt.to_int) != "number" then return "flood: invalid port; aborting..."
	print command.target(fip,fpt)
	catch = command.meta("link",fip,fpt)
	if typeof(catch) == "MetaLib" then 
		print colorLightBlue+"Opening the flood-gates!"+char(10)+colorWarning+"-- use <</b>ctrl+c<b>> to cancel"
		print globals.net_session.flood_connection
	end if
	return 0
end function
command.curl = function(a,b,c,d)
	if a == "help" or a == "-h" then return "Usage: curl [opt:shell|file|computer] -- display the website.html, if readable"
	if a and typeof(a) != "shell" and typeof(a) != "computer" and typeof(a) != "file" then return "curl: invalid object type"
	return globals.curl(a)
end function
command.netdump = function(a,b,c,d)
	if a == "help" or a == "-h" then return "Usage: netdump [opt:-r]"+char(10)+
	"-- returns information for the currently linked net_session"+char(10)+
	"-- use <b>bios -n</b> to obtain the raw NetSession object"
	// needs: -g -- num gateway connections, -p -- num port forwards, -ru -- num registered users, -u -- is user active, -r -- is root active
	if globals.net_session then return globals.netdump.join(char(10)) else return "netdump: no net_session"
end function
